
<!doctype html>
<html lang="fi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="color-scheme" content="light" />
    <title>Rengashotelli</title>
    <style>
      :root {
        --bg: #edf2f7;
        --card: #ffffff;
        --text: #1f2937;
        --subtext: #4b5563;
        --border: #e2e8f0;
        --primary: #0e7afe;
        --danger: #b42336;
        --muted-bg: #f8fafc;
        --muted-border: #dbe4ee;
        --shadow: 0 10px 28px rgba(15, 23, 42, 0.08);
        --radius: 16px;
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--text);
        background: radial-gradient(1200px 700px at 20% 0%, #ffffff 0%, var(--bg) 55%, #e6eef8 100%);
      }
      .app { min-height: 100%; display: flex; flex-direction: column; }
      .topbar {
        position: sticky; top: 0; z-index: 5;
        background: rgba(237, 242, 247, 0.82);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(226, 232, 240, 0.9);
      }
      .topbar-inner {
        max-width: 1100px; margin: 0 auto; padding: 14px 16px;
        display: flex; align-items: center; gap: 12px;
      }
      .brand { display: flex; flex-direction: column; line-height: 1.05; gap: 2px; min-width: 180px; }
      .brand .title { font-weight: 900; letter-spacing: 0.2px; }
      .brand .subtitle { font-size: 12px; color: var(--subtext); }
      .nav { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .nav button {
        appearance: none; cursor: pointer;
        border: 1px solid var(--muted-border);
        background: var(--muted-bg);
        color: #334155;
        padding: 9px 12px;
        border-radius: 999px;
        font-weight: 800;
        font-size: 13px;
      }
      .nav button.active {
        border-color: rgba(14, 122, 254, 0.35);
        background: rgba(14, 122, 254, 0.09);
        color: #0b4fb8;
      }
      .nav-spacer { flex: 1; }
      .session-chip {
        border: 1px solid var(--muted-border);
        background: white;
        border-radius: 999px;
        padding: 8px 10px;
        display: flex; gap: 8px; align-items: center;
        max-width: 420px;
      }
      .session-chip .hotel { font-weight: 900; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .session-chip .who { font-size: 12px; color: var(--subtext); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .container { width: 100%; max-width: 1100px; margin: 0 auto; padding: 16px; flex: 1; }
      .card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); }
      .card.pad { padding: 14px; }
      .row { display: flex; gap: 12px; flex-wrap: wrap; }
      .col { flex: 1; min-width: 260px; }
      .h1 { margin: 0; font-size: 22px; font-weight: 900; }
      .p { margin: 6px 0 0 0; color: var(--subtext); font-size: 14px; line-height: 1.35; }
      .field { display: flex; flex-direction: column; gap: 6px; margin: 10px 0; }
      .label { font-weight: 900; font-size: 12px; color: #334155; letter-spacing: 0.2px; }
      .label .req { color: var(--danger); }
      input, select, textarea {
        width: 100%; border: 1px solid var(--border); border-radius: 12px;
        padding: 10px 12px; font-size: 14px; background: #fff; outline: none;
      }
      textarea { min-height: 90px; resize: vertical; }
      input:focus, select:focus, textarea:focus { border-color: rgba(14, 122, 254, 0.6); box-shadow: 0 0 0 3px rgba(14, 122, 254, 0.12); }
      .btn-row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px; }
      .btn {
        appearance: none; cursor: pointer;
        border: 1px solid rgba(14, 122, 254, 0.35);
        background: rgba(14, 122, 254, 0.10);
        color: #0b4fb8;
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 900;
      }
      .btn.primary { border-color: rgba(14, 122, 254, 0.65); background: var(--primary); color: white; }
      .btn.ghost { border-color: var(--muted-border); background: white; color: #334155; }
      .btn.danger { border-color: rgba(180, 35, 54, 0.35); background: rgba(180, 35, 54, 0.10); color: var(--danger); }
      .btn:disabled { opacity: 0.55; cursor: not-allowed; }
      .pill {
        display: inline-flex; gap: 8px; align-items: center;
        border-radius: 999px; padding: 6px 10px;
        border: 1px solid var(--muted-border);
        background: var(--muted-bg);
        color: #334155;
        font-weight: 900; font-size: 12px; white-space: nowrap;
      }
      .pill.mono { font-family: var(--mono); font-weight: 800; }
      .list { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
      .item {
        background: white; border: 1px solid var(--border); border-radius: 14px;
        padding: 12px; display: flex; gap: 10px; align-items: flex-start;
      }
      .item .main { flex: 1; min-width: 240px; }
      .item .title { font-weight: 900; }
      .item .meta { margin-top: 4px; color: var(--subtext); font-size: 13px; line-height: 1.3; }
      .item .actions { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .divider { height: 1px; background: var(--border); margin: 12px 0; }
      .muted { color: var(--subtext); }
      .danger-text { color: var(--danger); font-weight: 900; }

      .toast-wrap { position: fixed; right: 12px; bottom: 12px; z-index: 50; display: flex; flex-direction: column; gap: 10px; width: min(420px, calc(100vw - 24px)); }
      .toast { border-radius: 14px; border: 1px solid var(--border); background: white; box-shadow: var(--shadow); padding: 12px; }
      .toast .t { font-weight: 900; }
      .toast .m { margin-top: 4px; color: var(--subtext); font-size: 13px; line-height: 1.35; }
      .toast.success { border-color: rgba(6, 78, 59, 0.22); background: rgba(212, 241, 223, 0.65); }
      .toast.error { border-color: rgba(180, 35, 54, 0.25); background: rgba(255, 227, 230, 0.75); }
      .toast.warning { border-color: rgba(154, 52, 18, 0.20); background: rgba(255, 247, 237, 0.85); }
      .toast.info { border-color: rgba(14, 122, 254, 0.20); background: rgba(14, 122, 254, 0.06); }

      .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.55); z-index: 60; display: none; align-items: flex-end; justify-content: center; padding: 14px; }
      .modal-backdrop.open { display: flex; }
      .modal { width: min(720px, 100%); border-radius: 18px; background: white; border: 1px solid var(--border); box-shadow: var(--shadow); padding: 14px; }
      .modal .head { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; }
      .modal .head .ttl { font-weight: 900; font-size: 18px; }
      .modal .head .x { appearance: none; border: 1px solid var(--muted-border); background: white; border-radius: 10px; padding: 6px 10px; font-weight: 900; cursor: pointer; }
      .modal .body { margin-top: 10px; }
      .modal .msg { color: var(--subtext); line-height: 1.35; }

      .menu { position: relative; }
      .menu-pop {
        position: absolute; right: 0; top: calc(100% + 8px);
        min-width: 220px; background: white; border: 1px solid var(--border);
        border-radius: 14px; box-shadow: var(--shadow); padding: 8px;
        display: none; z-index: 20;
      }
      .menu-pop.open { display: block; }
      .menu-pop button {
        width: 100%; text-align: left; border-radius: 12px;
        border: 1px solid transparent; background: transparent;
        padding: 10px 10px; font-weight: 900; cursor: pointer;
        color: #0f172a;
      }
      .menu-pop button:hover { background: var(--muted-bg); border-color: var(--muted-border); }
      .menu-pop button.danger { color: var(--danger); }

      @media (max-width: 860px) {
        .brand { min-width: 0; }
        .session-chip { display: none; }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="topbar-inner">
          <div class="brand">
            <div class="title">Rengashotelli</div>
            <div class="subtitle" id="brandSub">Web</div>
          </div>
          <div class="nav" id="nav" style="display:none">
            <button data-tab="dashboard">Etusivu</button>
            <button data-tab="worklist">Työlista</button>
            <button data-tab="customers">Asiakkaat</button>
            <button data-tab="rows">Rivit</button>
            <button data-tab="calendar">Kalenteri</button>
            <button data-tab="settings">Asetukset</button>
          </div>
          <div class="nav-spacer"></div>
          <div class="session-chip" id="sessionChip" style="display:none">
            <div class="hotel" id="chipHotel">—</div>
            <div class="who" id="chipWho">—</div>
          </div>
        </div>
      </div>
      <div class="container" id="root"></div>
    </div>

    <div class="toast-wrap" id="toasts"></div>

    <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="head">
          <div class="ttl" id="modalTitle"></div>
          <button class="x" id="modalCloseBtn">Sulje</button>
        </div>
        <div class="body" id="modalBody"></div>
      </div>
    </div>

    <script>
      // ==========================================================
      // Config (copied from App.js)
      // ==========================================================
      const SUPABASE_URL = "https://xbxmysfxbkcrjsxjtzkz.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_8e1s0Fj93ydy900tLpAwHQ_BAfVDGUq";

      // ==========================================================
      // Helpers
      // ==========================================================
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

      function escapeHtml(s) {
        return String(s || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function normalizeRole(role) {
        return String(role || "").trim().toLowerCase();
      }
      function isAdminRole(role) {
        return normalizeRole(role) === "admin";
      }

      function appNowMs() {
        return Date.now();
      }
      function todayStrLocal() {
        const d = new Date(appNowMs());
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      }
      function addDaysIso(isoDate, days) {
        const d = new Date(`${isoDate}T00:00:00Z`);
        d.setUTCDate(d.getUTCDate() + days);
        return d.toISOString().slice(0, 10);
      }
      function getMondayIso(isoDate) {
        const d = new Date(`${isoDate}T00:00:00Z`);
        const day = d.getUTCDay(); // 0=su,1=ma
        const delta = day === 0 ? -6 : 1 - day;
        d.setUTCDate(d.getUTCDate() + delta);
        return d.toISOString().slice(0, 10);
      }
      function prettyPlate(v) {
        return v ? String(v).toUpperCase() : "—";
      }
      function normalizePlate(v) {
        return String(v || "").toUpperCase().replace(/[\s-]/g, "");
      }
      function prettyLocation(v) {
        const s = String(v || "").trim();
        return s || "—";
      }
      function isSeasonPaid(v) {
        if (v === true) return true;
        if (v === false || v === null || v === undefined) return false;
        const s = String(v).trim().toLowerCase();
        return ["true", "t", "1", "yes", "kyllä", "paid", "maksettu"].includes(s);
      }
      function getStatusMeta(statusValue, opts = {}) {
        const raw = String(statusValue || "").trim();
        const lower = raw.toLowerCase();
        const isWaiting = opts?.isWaiting === true || lower === "odottaa noutoa";
        const isWorking = opts?.isWorking === true || lower === "työn alla";
        const isDelivered = lower === "luovutettu";
        const isStored = lower === "varastossa";
        const isDeleted = lower === "poistettu";
        const label = isWorking ? "Työn alla" : isWaiting ? "Odottaa noutoa" : (raw || "—");
        if (isWorking) return { label, bg: "#eaf7ef", border: "#c8e6d3", color: "#1f6f4a" };
        if (isWaiting) return { label, bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
        if (isDelivered) return { label, bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" };
        if (isStored) return { label, bg: "#d4f1df", border: "#7fc59b", color: "#064e3b" };
        if (isDeleted) return { label, bg: "#ffe3e6", border: "#f2a3ad", color: "#8a1023" };
        return { label, bg: "#f1f5f9", border: "#dbe4ee", color: "#334155" };
      }
      function formatActor(name, role) {
        const n = String(name || "").trim();
        const r = String(role || "").trim();
        if (n && r) return `${n} (${r})`;
        if (n) return n;
        if (r) return r;
        return "—";
      }

      const STAFF_APPROVAL_TAG = "[ODOTTAA ADMIN-HYVAKSYNTAA]";
      function ensureAdminApprovalTag(notes) {
        const txt = String(notes || "").trim();
        if (txt.toUpperCase().includes(STAFF_APPROVAL_TAG)) return txt;
        if (!txt) return STAFF_APPROVAL_TAG;
        return `${STAFF_APPROVAL_TAG}\n${txt}`;
      }
      function hasStaffApprovalTag(value) {
        return String(value || "").toUpperCase().includes(STAFF_APPROVAL_TAG);
      }
      function stripStaffApprovalTag(notes) {
        const lines = String(notes || "").split(/\r?\n/);
        const filtered = lines.filter((line) => String(line || "").trim().toUpperCase() !== STAFF_APPROVAL_TAG);
        const out = filtered.join("\n").trim();
        return out || null;
      }
      function normalizeNameKey(value) {
        return String(value || "").trim().toLowerCase();
      }
      function isPendingRowApproval(row) {
        if (!row || row.deleted) return false;
        if (hasStaffApprovalTag(row?.notes)) return true;
        const createdRole = normalizeRole(row?.created_by_role);
        const updatedRole = normalizeRole(row?.updated_by_role);
        return createdRole === "staff" && updatedRole !== "admin";
      }
      function isPendingCustomerApproval(customer) {
        if (!customer || customer.poistettu === true) return false;
        const createdRole = normalizeRole(customer?.created_by_role || customer?.luonut_rooli);
        const updatedRole = normalizeRole(customer?.updated_by_role || customer?.paivittanyt_rooli);
        return createdRole === "staff" && updatedRole !== "admin";
      }
      function formatPlateDuplicateMessage(plate, duplicateRow) {
        const plateTxt = prettyPlate(plate);
        const owner = String(duplicateRow?.customer || "").trim() || "tuntematon asiakas";
        const location = prettyLocation(duplicateRow?.location);
        const whereTxt = location ? ` (${location})` : "";
        return `Rekisteri ${plateTxt} on jo kirjattu asiakkaalle ${owner}${whereTxt}.`;
      }

      // ==========================================================
      // Toasts (in-app notifications)
      // ==========================================================
      const toastRoot = $("#toasts");
      let toastId = 1;
      function toast(variant, title, message, ms = 3500) {
        const id = toastId++;
        const el = document.createElement("div");
        el.className = `toast ${variant || "info"}`;
        el.innerHTML = `<div class="t"></div><div class="m"></div>`;
        el.querySelector(".t").textContent = String(title || "Ilmoitus");
        el.querySelector(".m").textContent = String(message || "");
        toastRoot.appendChild(el);
        const t = setTimeout(() => {
          el.remove();
          clearTimeout(t);
        }, ms);
        return id;
      }

      // ==========================================================
      // Modal
      // ==========================================================
      const modalBackdrop = $("#modalBackdrop");
      const modalTitle = $("#modalTitle");
      const modalBody = $("#modalBody");
      const modalCloseBtn = $("#modalCloseBtn");
      let modalOnClose = null;

      function closeModal() {
        modalBackdrop.classList.remove("open");
        modalBackdrop.setAttribute("aria-hidden", "true");
        modalTitle.textContent = "";
        modalBody.innerHTML = "";
        const cb = modalOnClose;
        modalOnClose = null;
        if (typeof cb === "function") cb();
      }
      modalCloseBtn.addEventListener("click", closeModal);
      modalBackdrop.addEventListener("click", (e) => {
        if (e.target === modalBackdrop) closeModal();
      });
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modalBackdrop.classList.contains("open")) closeModal();
      });

      function openModal(title, html, { onClose } = {}) {
        modalOnClose = typeof onClose === "function" ? onClose : null;
        modalTitle.textContent = String(title || "");
        modalBody.innerHTML = html || "";
        modalBackdrop.classList.add("open");
        modalBackdrop.setAttribute("aria-hidden", "false");
      }

      function modalConfirm(title, message, buttons) {
        const btns = Array.isArray(buttons) && buttons.length ? buttons : [{ text: "OK" }];
        const html = `
          <div class="msg">${escapeHtml(String(message || ""))}</div>
          <div class="btn-row" style="justify-content:flex-end; margin-top: 12px;">
            ${btns.map((b, idx) => {
              const kind = String(b?.kind || "");
              const cls = kind === "danger" ? "btn danger" : (kind === "primary" ? "btn primary" : "btn ghost");
              return `<button class="${cls}" data-modal-btn="${idx}">${escapeHtml(String(b?.text || "OK"))}</button>`;
            }).join("")}
          </div>
        `;
        openModal(title || "Vahvista", html);
        $$('[data-modal-btn]', modalBody).forEach((btn) => {
          btn.addEventListener('click', () => {
            const idx = parseInt(btn.getAttribute('data-modal-btn'), 10);
            const b = btns[idx] || null;
            closeModal();
            if (b && typeof b.onPress === 'function') b.onPress();
          });
        });
      }

      function modalPromptPin({ title, message, prefill = "" }) {
        return new Promise((resolve) => {
          const html = `
            <div class="msg">${escapeHtml(String(message || "Syötä PIN."))}</div>
            <div class="field" style="margin-top: 10px;">
              <div class="label">PIN</div>
              <input id="pinPromptInput" type="password" autocomplete="one-time-code" />
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="pinPromptCancel">Peruuta</button>
              <button class="btn primary" id="pinPromptOk">OK</button>
            </div>
          `;
          openModal(title || "PIN", html, { onClose: () => resolve("") });
          const input = $("#pinPromptInput", modalBody);
          input.value = String(prefill || "");
          setTimeout(() => input.focus(), 0);
          $("#pinPromptCancel", modalBody).addEventListener("click", () => {
            closeModal();
            resolve("");
          });
          $("#pinPromptOk", modalBody).addEventListener("click", () => {
            const v = String(input.value || "").trim();
            closeModal();
            resolve(v);
          });
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              const v = String(input.value || "").trim();
              closeModal();
              resolve(v);
            }
          });
        });
      }
      // ==========================================================
      // API
      // ==========================================================
      function makeApi(options = {}) {
        const base = `${SUPABASE_URL}/rest/v1`;
        const getSessionPin = typeof options?.getSessionPin === "function" ? options.getSessionPin : () => "";
        const getSessionIdentity = typeof options?.getSessionIdentity === "function" ? options.getSessionIdentity : () => ({ username: "", role: "", pinSource: "" });

        function resolvePin(pin) {
          const direct = String(pin || "").trim();
          return direct || String(getSessionPin() || "").trim();
        }

        async function request(path, { method = "GET", body, preferReturn = false } = {}) {
          const url = `${base}${path}`;
          const res = await fetch(url, {
            method,
            headers: {
              apikey: SUPABASE_ANON_KEY,
              "Content-Type": "application/json",
              Accept: "application/json",
              ...(preferReturn ? { Prefer: "return=representation" } : {}),
            },
            body: body ? JSON.stringify(body) : undefined,
          });
          const text = await res.text();
          let data = null;
          try { data = text ? JSON.parse(text) : null; } catch { data = text; }
          if (!res.ok) {
            const msg = data?.message || data?.error_description || text || "Supabase error";
            throw new Error(msg);
          }
          return data;
        }

        const normalizeRpcObject = (res) => (Array.isArray(res) ? (res[0] || {}) : (res || {}));
        const normalizeRoleValue = (value) => {
          const v = String(value || "").trim().toLowerCase();
          return v === "admin" ? "admin" : (v === "staff" ? "staff" : "");
        };
        const parseRpcBoolean = (res, key) => {
          if (typeof res === "boolean") return res;
          if (typeof res === "string") {
            const txt = res.trim().toLowerCase();
            if (txt === "true" || txt === "t" || txt === "1") return true;
            if (txt === "false" || txt === "f" || txt === "0") return false;
          }
          if (Array.isArray(res)) {
            if (typeof res[0] === "boolean") return res[0];
            if (res[0] && typeof res[0] === "object" && key in res[0]) return !!res[0][key];
          }
          if (res && typeof res === "object" && key in res) return !!res[key];
          return null;
        };

        async function callBoolRpc(fnName, keyName, code, pin) {
          const bodies = [{ p_hotel_code: code, p_pin: pin }, { hotel_code: code, pin }];
          let missing = false;
          for (const body of bodies) {
            try {
              const out = await request(`/rpc/${fnName}`, { method: "POST", body });
              const parsed = parseRpcBoolean(out, keyName);
              if (typeof parsed === "boolean") return { ok: true, value: parsed };
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes(`Could not find the function public.${fnName}`)) { missing = true; continue; }
              throw e;
            }
          }
          return missing ? { ok: false, reason: "missing_function" } : { ok: false, reason: "invalid_response" };
        }

        async function fetchPinIdentity(code, pin) {
          const variants = [{ p_hotel_code: code, p_pin: pin }, { hotel_code: code, pin }];
          for (const body of variants) {
            try { return normalizeRpcObject(await request(`/rpc/get_pin_identity`, { method: "POST", body })); }
            catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.get_pin_identity")) continue;
              throw e;
            }
          }
          return null;
        }

        async function safeHotelDisplayName(code) {
          try {
            const rows = await request(`/hotels?hotel_code=eq.${encodeURIComponent(code)}&select=display_name,hotel_name,nimi,name,title&limit=1`);
            const row = rows?.[0];
            if (!row || typeof row !== "object") return "";
            const candidates = [row.display_name, row.hotel_name, row.nimi, row.name, row.title];
            for (const value of candidates) if (typeof value === "string" && value.trim()) return value.trim();
            return "";
          } catch { return ""; }
        }

        async function enrichVerifiedIdentity(base, code, pin) {
          const out = (base && typeof base === "object") ? { ...base } : {};
          out.ok = true;
          out.hotel_code = String(out?.hotel_code || code || "").trim() || code;
          if (!String(out?.display_name || "").trim()) {
            const displayName = await safeHotelDisplayName(code);
            out.display_name = displayName || out.hotel_code;
          }

          const currentRole = normalizeRoleValue(out?.role);
          const currentSource = String(out?.source || "").trim().toLowerCase();
          const currentUsername = out?.username ?? null;

          if (!currentRole || !currentSource || currentUsername === null || currentUsername === "") {
            const ident = await fetchPinIdentity(code, pin);
            if (ident && ident.ok === true) {
              const identRole = normalizeRoleValue(ident?.role);
              if (!currentRole && identRole) out.role = identRole;
              if (!currentSource && String(ident?.source || "").trim()) out.source = String(ident.source).trim();
              if ((currentUsername === null || currentUsername === "") && ident?.username !== undefined) out.username = ident.username;
            } else if (ident && ident.ok === false) {
              return { ok: false, reason: String(ident?.reason || "wrong_pin") };
            }
          }

          let finalRole = normalizeRoleValue(out?.role);
          if (!finalRole) {
            const adminGate = await callBoolRpc("check_hotel_admin_pin", "check_hotel_admin_pin", code, pin);
            if (adminGate.ok && adminGate.value === true) {
              finalRole = "admin";
              if (!String(out?.source || "").trim()) out.source = "master";
            } else {
              finalRole = "staff";
            }
          }
          out.role = finalRole;
          if (!String(out?.source || "").trim()) out.source = finalRole === "admin" ? "master" : "user";
          if (out.username === undefined) out.username = null;
          return out;
        }

        async function verifyHotelWithPin(hotelCode, pin) {
          const code = String(hotelCode || "").trim();
          const p = String(pin || "").trim();
          if (!code) return { ok: false, reason: "missing_hotel_code" };
          if (!p) return { ok: false, reason: "missing_pin" };

          try {
            const verifyBodies = [{ p_hotel_code: code, p_pin: p }, { hotel_code: code, pin: p }];
            let verifyMissingFn = false;
            let lastVerifyOut = null;
            for (const body of verifyBodies) {
              try {
                const res = await request(`/rpc/verify_hotel_with_pin`, { method: "POST", body });
                const out = normalizeRpcObject(res);
                if (!out || typeof out !== "object") { lastVerifyOut = { ok: false, reason: "invalid_response" }; continue; }
                if (out?.ok !== true) { lastVerifyOut = out; continue; }
                return await enrichVerifiedIdentity(out, code, p);
              } catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.verify_hotel_with_pin")) { verifyMissingFn = true; continue; }
                throw e;
              }
            }
            if (lastVerifyOut && lastVerifyOut.ok !== true) {
              const ident = await fetchPinIdentity(code, p);
              if (ident && ident.ok === true) return await enrichVerifiedIdentity(ident, code, p);
              return lastVerifyOut;
            }
            if (!verifyMissingFn) return { ok: false, reason: "invalid_response" };
            throw new Error("Could not find the function public.verify_hotel_with_pin");
          } catch (e) {
            const msg = String(e?.message || "");
            if (!msg.includes("Could not find the function public.verify_hotel_with_pin")) throw e;

            const ident = await fetchPinIdentity(code, p);
            if (ident && ident.ok === true) return await enrichVerifiedIdentity(ident, code, p);
            if (ident && ident.ok === false) return { ok: false, reason: String(ident?.reason || "wrong_pin") };

            const adminGate = await callBoolRpc("check_hotel_admin_pin", "check_hotel_admin_pin", code, p);
            if (adminGate.ok && adminGate.value === true) {
              return await enrichVerifiedIdentity({ ok: true, hotel_code: code, role: "admin", username: null, source: "master" }, code, p);
            }
            if (adminGate.ok && adminGate.value === false) return { ok: false, reason: "wrong_pin" };

            const masterGate = await callBoolRpc("check_hotel_pin", "check_hotel_pin", code, p);
            if (masterGate.ok && masterGate.value === true) {
              return await enrichVerifiedIdentity({ ok: true, hotel_code: code, role: "admin", username: null, source: "master" }, code, p);
            }
            if (masterGate.ok && masterGate.value === false) return { ok: false, reason: "wrong_pin" };

            return { ok: false, reason: "missing_function", message: "Backendistä puuttuu verify_hotel_with_pin (ja fallbackit)." };
          }
        }

        function getActorIdentity() {
          const raw = getSessionIdentity() || {};
          const pinSource = String(raw?.pinSource || "").trim().toLowerCase();
          const username = String(raw?.username || "").trim();
          const role = normalizeRole(raw?.role) || null;
          const actorUsername = username || (pinSource === "master" ? "master" : "");
          return { username: actorUsername || null, role };
        }

        function actorFieldsForInsert() {
          const actor = getActorIdentity();
          const out = {};
          if (actor.username) { out.created_by_name = actor.username; out.updated_by_name = actor.username; }
          if (actor.role) { out.created_by_role = actor.role; out.updated_by_role = actor.role; }
          return out;
        }

        function actorFieldsForUpdate() {
          const actor = getActorIdentity();
          const out = {};
          if (actor.username) out.updated_by_name = actor.username;
          if (actor.role) out.updated_by_role = actor.role;
          return out;
        }

        function deliveredFieldsForPatch(patch = {}) {
          if (!patch || typeof patch !== "object") return {};
          const hasOwn = (key) => Object.prototype.hasOwnProperty.call(patch, key);
          const statusLower = String(patch?.status || "").trim().toLowerCase();
          const hasOutDate = hasOwn("out_date");
          const outDate = patch?.out_date;
          const marksDelivered = statusLower === "luovutettu" || (hasOutDate && outDate !== null && String(outDate || "").trim() !== "");
          const clearsDelivered = hasOutDate && (outDate === null || String(outDate || "").trim() === "");
          if (!marksDelivered && !clearsDelivered) return {};
          if (clearsDelivered) return { delivered_by_name: null, delivered_by_role: null };
          const actor = getActorIdentity();
          return { delivered_by_name: actor.username || null, delivered_by_role: actor.role || null };
        }

        function isActorColumnMissingError(message) {
          const msg = String(message || "");
          return (
            msg.includes("created_by_name") || msg.includes("created_by_role") ||
            msg.includes("updated_by_name") || msg.includes("updated_by_role") ||
            msg.includes("delivered_by_name") || msg.includes("delivered_by_role")
          );
        }

        const mapFromDb = (row) => ({
          id: row.id,
          hotel_code: row.hotel_code,
          customer: row.nimi ?? row.customer,
          phone: row.puhelin ?? row.phone,
          plate: row.rekisteri ?? row.plate,
          tire_size: row.sahkoposti ?? row.tire_size,
          location: row.hyllypaikka ?? row.location,
          last_location: row.last_hyllypaikka ?? row.last_location,
          pickup_date: row.nouto_paiva ?? row.pickup_date,
          status: row.tila ?? row.status,
          notes: row.huomiot ?? row.notes,
          season_fee_paid: row.season_fee_paid,
          deleted: row.poistettu ?? row.deleted,
          rev: row.versio ?? row.rev,
          updated_at: row.paivitetty ?? row.updated_at,
          created_at: row.luotu ?? row.created_at,
          created_by_name: row.luonut_nimi ?? row.created_by_name ?? row.created_by_username ?? row.created_by ?? row.creator_name ?? row.creator ?? null,
          created_by_role: row.luonut_rooli ?? row.created_by_role ?? row.creator_role ?? null,
          updated_by_name: row.paivittanyt_nimi ?? row.updated_by_name ?? row.updated_by_username ?? row.updated_by ?? row.last_modified_by ?? row.editor_name ?? row.editor ?? null,
          updated_by_role: row.paivittanyt_rooli ?? row.updated_by_role ?? row.editor_role ?? null,
          delivered_by_name: row.luovuttanut_nimi ?? row.delivered_by_name ?? row.out_by_name ?? null,
          delivered_by_role: row.luovuttanut_rooli ?? row.delivered_by_role ?? row.out_by_role ?? null,
          out_date: row.ulos_pvm ?? row.out_date,
          in_date: row.sisaan_pvm ?? row.in_date,
          waiting_pickup: row.odottaa_noutoa ?? row.waiting_pickup ?? ((row.tila || row.status || "").toLowerCase() === "odottaa noutoa"),
          working: row.tyon_alla ?? row.working ?? ((row.tila || row.status || "").toLowerCase() === "työn alla"),
        });

        const mapToDb = (payload) => ({
          nimi: payload.customer ?? null,
          puhelin: payload.phone ?? null,
          rekisteri: payload.plate ?? null,
          sahkoposti: payload.email ?? payload.tire_size ?? null,
          hyllypaikka: payload.location ?? null,
          last_hyllypaikka: payload.last_location ?? null,
          nouto_paiva: payload.pickup_date ?? null,
          tila: payload.status ?? null,
          huomiot: payload.notes ?? null,
          season_fee_paid: payload.season_fee_paid ?? false,
          poistettu: payload.deleted ?? false,
          versio: payload.rev,
          ulos_pvm: payload.out_date ?? null,
          sisaan_pvm: payload.in_date ?? null,
        });

        const mapPatchToDb = (payload = {}) => {
          const out = {};
          if (payload.customer !== undefined) out.nimi = payload.customer;
          if (payload.phone !== undefined) out.puhelin = payload.phone;
          if (payload.plate !== undefined) out.rekisteri = payload.plate;
          if (payload.tire_size !== undefined) out.sahkoposti = payload.tire_size;
          if (payload.email !== undefined) out.sahkoposti = payload.email;
          if (payload.location !== undefined) out.hyllypaikka = payload.location;
          if (payload.last_location !== undefined) out.last_hyllypaikka = payload.last_location;
          if (payload.pickup_date !== undefined) out.nouto_paiva = payload.pickup_date;
          if (payload.status !== undefined) out.tila = payload.status;
          if (payload.notes !== undefined) out.huomiot = payload.notes;
          if (payload.season_fee_paid !== undefined) out.season_fee_paid = !!payload.season_fee_paid;
          if (payload.deleted !== undefined) out.poistettu = payload.deleted === true;
          if (payload.out_date !== undefined) out.ulos_pvm = payload.out_date;
          if (payload.in_date !== undefined) out.sisaan_pvm = payload.in_date;
          if (payload.waiting_pickup !== undefined) out.odottaa_noutoa = payload.waiting_pickup;
          if (payload.working !== undefined) out.tyon_alla = payload.working;
          return out;
        };

        let tireActorColumnsSupported = null;
        let customerActorColumnsSupported = null;

        return {
          request,
          verifyHotelWithPin,
          getHotelMasterName: async (hotelCode) => {
            const code = String(hotelCode || "").trim();
            if (!code) return null;
            try {
              const rows = await request(`/hotels?hotel_code=eq.${encodeURIComponent(code)}&select=master_name&limit=1`);
              const value = rows?.[0]?.master_name;
              if (typeof value === "string" && value.trim()) return value.trim();
              return null;
            } catch { return null; }
          },

          listTires: (hotelCode) => request(`/tires?hotel_code=eq.${encodeURIComponent(hotelCode)}&poistettu=eq.false&order=paivitetty.desc&limit=200`).then((rows) => (rows || []).map(mapFromDb)),

          listCustomers: (hotelCode) => request(`/customers?hotel_code=eq.${encodeURIComponent(hotelCode)}&poistettu=eq.false&order=paivitetty.desc&limit=500`),

          getCustomerByName: (hotelCode, name) => request(`/customers?hotel_code=eq.${encodeURIComponent(hotelCode)}&nimi=eq.${encodeURIComponent(name)}&poistettu=eq.false&limit=1`).then((rows) => (rows && rows[0] ? rows[0] : null)),

          findActiveTireByPlate: async (hotelCode, plate, excludeId = null) => {
            const code = String(hotelCode || "").trim();
            const wanted = normalizePlate(plate);
            if (!code || !wanted) return null;
            const rows = await request(`/tires?hotel_code=eq.${encodeURIComponent(code)}&poistettu=eq.false&select=*&limit=5000`);
            const mapped = (rows || []).map(mapFromDb);
            return mapped.find((r) => {
              if (!r?.id) return false;
              if (excludeId != null && String(r.id) === String(excludeId)) return false;
              return normalizePlate(r.plate) === wanted;
            }) || null;
          },

          addCustomer: async (hotelCode, payload) => {
            const actorFields = customerActorColumnsSupported === false ? {} : actorFieldsForInsert();
            try {
              return await request(`/customers`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, ...payload, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                customerActorColumnsSupported = false;
                return request(`/customers`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, ...payload } });
              }
              throw e;
            }
          },

          updateCustomer: async (id, patch) => {
            const actorFields = customerActorColumnsSupported === false ? {} : actorFieldsForUpdate();
            try {
              return await request(`/customers?id=eq.${id}`, { method: "PATCH", preferReturn: true, body: { ...patch, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                customerActorColumnsSupported = false;
                return request(`/customers?id=eq.${id}`, { method: "PATCH", preferReturn: true, body: patch });
              }
              throw e;
            }
          },

          addTire: async (hotelCode, payload) => {
            const normalizedPayload = { ...payload, in_date: payload?.in_date || todayStrLocal() };
            const actorFields = tireActorColumnsSupported === false ? {} : actorFieldsForInsert();
            let rows;
            try {
              rows = await request(`/tires`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, versio: 1, ...mapToDb(normalizedPayload), season_fee_paid: !!normalizedPayload.season_fee_paid, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                tireActorColumnsSupported = false;
                rows = await request(`/tires`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, versio: 1, ...mapToDb(normalizedPayload), season_fee_paid: !!normalizedPayload.season_fee_paid } });
              } else {
                throw e;
              }
            }
            return rows?.[0] ? mapFromDb(rows[0]) : null;
          },

          updateTire: async (id, expectedRev, patch) => {
            const useActorCols = tireActorColumnsSupported !== false;
            const actorFields = useActorCols ? actorFieldsForUpdate() : {};
            const deliveredFields = useActorCols ? deliveredFieldsForPatch(patch) : {};
            const bodyWithActor = { ...mapPatchToDb(patch), ...deliveredFields, ...actorFields, versio: expectedRev + 1 };
            let rows;
            try {
              rows = await request(`/tires?id=eq.${id}&versio=eq.${expectedRev}`, { method: "PATCH", preferReturn: true, body: bodyWithActor });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0 || Object.keys(deliveredFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                tireActorColumnsSupported = false;
                rows = await request(`/tires?id=eq.${id}&versio=eq.${expectedRev}`, { method: "PATCH", preferReturn: true, body: { ...mapPatchToDb(patch), versio: expectedRev + 1 } });
              } else {
                throw e;
              }
            }
            if (!rows || rows.length === 0) throw new Error("Konflikti: joku ehti muokata tätä riviä. Päivitä lista ja yritä uudelleen.");
            return mapFromDb(rows[0]);
          },

          deleteTireWithPin: async (tireId, hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const res = await request(`/rpc/soft_delete_tire_with_pin`, { method: "POST", body: { tire_id: String(tireId ?? ""), hotel_code: hotelCode, pin: resolvedPin } });
            const out = normalizeRpcObject(res);
            if (out === true || out?.ok === true || out === "true") return true;
            const reason = out?.reason;
            if (reason === "wrong_pin") throw new Error("Väärä PIN.");
            if (reason === "no_rows_matched" || reason === "not_found") throw new Error("Riviä ei löytynyt tai jo poistettu.");
            throw new Error(reason || "Poisto epäonnistui.");
          },

          hardDeleteTireWithPin: async (tireId, hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const res = await request(`/rpc/hard_delete_tire_with_pin`, { method: "POST", body: { tire_id: String(tireId ?? ""), hotel_code: hotelCode, pin: resolvedPin } });
            const out = normalizeRpcObject(res);
            if (out === true || out?.ok === true || out?.deleted === true) return true;
            const reason = out?.reason;
            if (reason === "wrong_pin") throw new Error("Väärä PIN.");
            if (reason === "not_found") throw new Error("Riviä ei löytynyt.");
            throw new Error(reason || "Pysyvä poisto epäonnistui.");
          },

          customerSoftDeleteCascadeWithPin: async (hotelCode, pin, customerId) => {
            const resolvedPin = resolvePin(pin);
            const res = await request(`/rpc/customer_soft_delete_cascade_with_pin`, { method: "POST", body: { hotel_code: hotelCode, pin: resolvedPin, customer_id: String(customerId ?? "") } });
            return normalizeRpcObject(res);
          },

          customerHardDeleteCascadeWithPin: async (hotelCode, pin, customerId) => {
            const resolvedPin = resolvePin(pin);
            const res = await request(`/rpc/customer_hard_delete_cascade_with_pin`, { method: "POST", body: { hotel_code: hotelCode, pin: resolvedPin, customer_id: String(customerId ?? "") } });
            return normalizeRpcObject(res);
          },

          listLocationsAdmin: (hotelCode) => request(`/locations?hotel_code=eq.${encodeURIComponent(hotelCode)}&select=id,code,label,shelf,row_letter,spot&order=shelf&order=row_letter&order=spot`),

          listFreeLocations: (hotelCode) => request(`/locations_free?hotel_code=eq.${encodeURIComponent(hotelCode)}&order=code.asc`),

          addLocation: (hotelCode, shelf, row_letter, spot) => request(`/locations`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, shelf, row_letter, spot, code: `H${String(shelf).padStart(2, "0")}-${row_letter}-${String(spot).padStart(2, "0")}`, label: `Hylly ${String(shelf).padStart(2, "0")} / ${row_letter} / ${String(spot).padStart(2, "0")}` } }),

          deleteLocation: (id) => request(`/locations?id=eq.${id}`, { method: "DELETE" }),

          listHotelUsersWithPin: async (hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const variants = [{ p_hotel_code: hotelCode, p_pin: resolvedPin }, { hotel_code: hotelCode, pin: resolvedPin }];
            for (const body of variants) {
              try {
                const res = await request(`/rpc/list_hotel_users_with_pin`, { method: "POST", body });
                const out = normalizeRpcObject(res);
                return { ...out, users: Array.isArray(out?.users) ? out.users : [] };
              } catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.list_hotel_users_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              }
            }
            return { ok: false, reason: "invalid_response" };
          },

          setHotelUserActiveWithPin: async (hotelCode, pin, username, isActive) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_username: username, p_is_active: !!isActive },
              { hotel_code: hotelCode, pin: resolvedPin, username, is_active: !!isActive },
            ];
            for (const body of variants) {
              try { return normalizeRpcObject(await request(`/rpc/set_hotel_user_active_with_pin`, { method: "POST", body })); }
              catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.set_hotel_user_active_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              }
            }
            return { ok: false, reason: "invalid_response" };
          },

          upsertHotelUserPinWithPin: async (hotelCode, pin, username, newPin, role = "staff", isActive = true) => {
            const resolvedPin = resolvePin(pin);
            try {
              return normalizeRpcObject(await request(`/rpc/upsert_hotel_user_pin_with_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_pin: resolvedPin, p_username: username, p_new_pin: newPin, p_role: role === "admin" ? "admin" : "staff", p_is_active: !!isActive } }));
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.upsert_hotel_user_pin_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              throw e;
            }
          },

          upsertHotelUserPinWithMasterPin: async (hotelCode, masterPin, username, newPin, role = "staff", isActive = true) => {
            try {
              return normalizeRpcObject(await request(`/rpc/upsert_hotel_user_pin_with_master_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_master_pin: String(masterPin || "").trim(), p_username: username, p_new_pin: newPin, p_role: role === "admin" ? "admin" : "staff", p_is_active: !!isActive } }));
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.upsert_hotel_user_pin_with_master_pin")) return { ok: false, reason: "missing_function", message: msg };
              throw e;
            }
          },

          getCalendarWeek: async (hotelCode, weekStart) => {
            const variants = [
              { endpoint: `/rpc/get_calendar_week`, body: { p_hotel_code: hotelCode, p_week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week`, body: { hotel_code: hotelCode, week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week_v2`, body: { p_hotel_code: hotelCode, p_week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week_v2`, body: { hotel_code: hotelCode, week_start: weekStart } },
            ];
            let lastErr = null;
            for (const v of variants) {
              try {
                const res = await request(v.endpoint, { method: "POST", body: v.body });
                const out = normalizeRpcObject(res);
                if (out && typeof out === "object") return out;
              } catch (e) {
                const msg = String(e?.message || "");
                const missing = msg.includes("Could not find the function public.get_calendar_week") || msg.includes("Could not find the function public.get_calendar_week_v2");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            throw lastErr || new Error("Backendistä puuttuu get_calendar_week/get_calendar_week_v2.");
          },

          createBlockWithPin: async (hotelCode, pin, payload) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_start_ts: payload?.start_ts, p_end_ts: payload?.end_ts, p_kind: payload?.kind ?? "tauko", p_title: payload?.title ?? null, p_notes: payload?.notes ?? null },
              { hotel_code: hotelCode, pin: resolvedPin, start_ts: payload?.start_ts, end_ts: payload?.end_ts, kind: payload?.kind ?? "tauko", title: payload?.title ?? null, notes: payload?.notes ?? null },
            ];
            let lastErr = null;
            for (const body of variants) {
              try { return normalizeRpcObject(await request(`/rpc/create_block_with_pin`, { method: "POST", body })); }
              catch (e) {
                const msg = String(e?.message || "");
                const missing = msg.includes("Could not find the function public.create_block_with_pin") || msg.includes("function public.create_block_with_pin(");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            throw lastErr || new Error("Blokin PIN-luontifunktiota ei löytynyt.");
          },

          deleteBlockWithPin: async (hotelCode, pin, blockId) => {
            const resolvedPin = resolvePin(pin);
            const variants = [{ p_hotel_code: hotelCode, p_pin: resolvedPin, p_block_id: blockId ?? null }, { hotel_code: hotelCode, pin: resolvedPin, block_id: blockId ?? null }];
            for (const body of variants) {
              try {
                const out = normalizeRpcObject(await request(`/rpc/delete_block_with_pin`, { method: "POST", body }));
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const missing = msg.includes("Could not find the function public.delete_block_with_pin") || msg.includes("function public.delete_block_with_pin(");
                if (!missing) throw e;
              }
            }
            return { ok: false, reason: "missing_function" };
          },

          createAppointmentWithPin: async (hotelCode, pin, payload) => {
            const resolvedPin = resolvePin(pin);
            const normalizeBay = (v) => {
              const n = parseInt(v, 10);
              return n === 2 ? 2 : 1;
            };
            const variants = [
              {
                endpoint: `/rpc/create_appointment_with_pin`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  start_ts: payload?.start_ts,
                  end_ts: payload?.end_ts,
                  bay: normalizeBay(payload?.bay),
                  customer_name: payload?.customer_name ?? null,
                  phone: payload?.phone ?? null,
                  plate: payload?.plate ?? null,
                  notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_start_ts: payload?.start_ts,
                  p_end_ts: payload?.end_ts,
                  p_bay: normalizeBay(payload?.bay),
                  p_customer_name: payload?.customer_name ?? null,
                  p_phone: payload?.phone ?? null,
                  p_plate: payload?.plate ?? null,
                  p_notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin_v2`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  start_ts: payload?.start_ts,
                  end_ts: payload?.end_ts,
                  bay: normalizeBay(payload?.bay),
                  customer_name: payload?.customer_name ?? null,
                  phone: payload?.phone ?? null,
                  plate: payload?.plate ?? null,
                  notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin_v2`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_start_ts: payload?.start_ts,
                  p_end_ts: payload?.end_ts,
                  p_bay: normalizeBay(payload?.bay),
                  p_customer_name: payload?.customer_name ?? null,
                  p_phone: payload?.phone ?? null,
                  p_plate: payload?.plate ?? null,
                  p_notes: payload?.notes ?? null,
                },
              },
            ];
            let lastErr = null;
            for (const v of variants) {
              try {
                return normalizeRpcObject(await request(v.endpoint, { method: "POST", body: v.body }));
              } catch (e) {
                const msg = String(e?.message || "");
                const missing =
                  msg.includes("Could not find the function public.create_appointment_with_pin") ||
                  msg.includes("Could not find the function public.create_appointment_with_pin_v2") ||
                  msg.includes("create_appointment_with_pin");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            return { ok: false, reason: "missing_function", message: String(lastErr?.message || "create_appointment_with_pin puuttuu backendistä.") };
          },

          deleteAppointmentWithPin: async (hotelCode, pin, appointmentId) => {
            const resolvedPin = resolvePin(pin);
            const key = String(appointmentId ?? "");
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_appointment_id: key },
              { hotel_code: hotelCode, pin: resolvedPin, appointment_id: key },
            ];
            let lastErr = null;
            for (const body of variants) {
              try {
                const out = normalizeRpcObject(await request(`/rpc/cancel_appointment_with_pin`, { method: "POST", body }));
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const missing = msg.includes("Could not find the function public.cancel_appointment_with_pin") || msg.includes("cancel_appointment_with_pin");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            return { ok: false, reason: "missing_function", message: String(lastErr?.message || "cancel_appointment_with_pin puuttuu backendistä.") };
          },

          changeOwnPin: async (hotelCode, username, oldPin, newPin) => normalizeRpcObject(await request(`/rpc/change_hotel_user_pin_with_old_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_username: username, p_old_pin: oldPin, p_new_pin: newPin } })),
        };
      }
      // ==========================================================
      // State
      // ==========================================================
      const state = {
        tab: "dashboard",
        session: {
          ok: false,
          hotelCode: null,
          displayName: null,
          role: null,
          username: null,
          pinSource: null,
          pin: null, // RAM only
          masterName: null,
        },
        security: {
          autoLogoutMinutes: 30,
        },
        lastActivityMs: appNowMs(),
        data: {
          tires: [],
          customers: [],
          blocks: [],
          appointments: [],
          users: [],
          locations: [],
          calendarDate: todayStrLocal(),
        },
        ui: {
          loading: false,
        },
      };

      const api = makeApi({
        getSessionPin: () => String(state.session.pin || "").trim(),
        getSessionIdentity: () => ({
          username: String(state.session.username || "").trim(),
          role: normalizeRole(state.session.role),
          pinSource: String(state.session.pinSource || "").trim().toLowerCase(),
        }),
      });

      function setLoading(v) {
        state.ui.loading = !!v;
        render();
      }

      function bumpActivity() {
        state.lastActivityMs = appNowMs();
      }
      ["click", "keydown", "mousemove", "touchstart"].forEach((ev) => {
        window.addEventListener(ev, () => bumpActivity(), { passive: true });
      });

      setInterval(() => {
        const mins = clamp(parseInt(state.security.autoLogoutMinutes, 10) || 0, 0, 240);
        if (!state.session.ok) return;
        if (!mins) return;
        const idleMs = appNowMs() - state.lastActivityMs;
        if (idleMs > mins * 60 * 1000) {
          logout("Automaattinen kirjaus ulos");
        }
      }, 5000);

      function setSessionFromVerify(verify, pin) {
        state.session.ok = true;
        state.session.hotelCode = String(verify?.hotel_code || "").trim();
        state.session.displayName = String(verify?.display_name || verify?.hotel_code || "").trim();
        state.session.role = normalizeRole(verify?.role || "");
        state.session.username = verify?.username ?? null;
        state.session.pinSource = String(verify?.source || "").trim().toLowerCase() || null;
        state.session.pin = String(pin || "").trim() || null;
      }

      function clearData() {
        state.data.tires = [];
        state.data.customers = [];
        state.data.blocks = [];
        state.data.appointments = [];
        state.data.users = [];
        state.data.locations = [];
        state.data.calendarDate = todayStrLocal();
      }

      function logout(reason) {
        state.session = { ok: false, hotelCode: null, displayName: null, role: null, username: null, pinSource: null, pin: null, masterName: null };
        state.tab = "dashboard";
        clearData();
        state.ui.loading = false;
        $("#nav").style.display = "none";
        $("#sessionChip").style.display = "none";
        if (reason) toast("info", "Ilmoitus", reason);
        render();
      }

      function setTab(tab) {
        state.tab = tab;
        render();
        if (tab === "dashboard" || tab === "rows" || tab === "worklist") ensureLoaded();
        if (tab === "customers") loadCustomers();
        if (tab === "calendar") loadCalendarWeek();
        if (tab === "settings") {
          if (isAdminRole(state.session.role)) {
            loadUsers();
            loadLocations();
          }
        }
      }

      async function ensureLoaded() {
        await Promise.all([loadTires(), loadCustomers()]);
      }

      async function loadTires() {
        if (!state.session.ok) return;
        try {
          state.data.tires = await api.listTires(state.session.hotelCode);
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Rivien lataus epäonnistui");
        }
      }

      async function loadCustomers() {
        if (!state.session.ok) return;
        try {
          const rows = await api.listCustomers(state.session.hotelCode);
          state.data.customers = Array.isArray(rows) ? rows : [];
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Asiakkaiden lataus epäonnistui");
        }
      }

      async function loadCalendarWeek() {
        if (!state.session.ok) return;
        try {
          const weekStart = getMondayIso(state.data.calendarDate);
          const payload = await api.getCalendarWeek(state.session.hotelCode, weekStart);
          state.data.blocks = Array.isArray(payload?.blocks) ? payload.blocks : [];
          state.data.appointments = Array.isArray(payload?.appointments) ? payload.appointments : [];
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Kalenterin lataus epäonnistui");
        }
      }

      async function loadUsers() {
        if (!state.session.ok || !isAdminRole(state.session.role)) return;
        try {
          const res = await api.listHotelUsersWithPin(state.session.hotelCode, state.session.pin);
          if (res?.ok !== true) {
            if (String(res?.reason || "") === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", res?.message || "Käyttäjälistan lataus epäonnistui");
            return;
          }
          let users = Array.isArray(res?.users) ? res.users : [];
          const masterName = state.session.masterName || "Master";
          users = [{ id: "master", username: masterName, role: "admin", is_active: true, is_master: true }, ...users];
          state.data.users = users;
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Käyttäjälistan lataus epäonnistui");
        }
      }

      async function loadLocations() {
        if (!state.session.ok || !isAdminRole(state.session.role)) return;
        try {
          const rows = await api.listLocationsAdmin(state.session.hotelCode);
          state.data.locations = Array.isArray(rows) ? rows : [];
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Hyllypaikkojen lataus epäonnistui");
        }
      }

      async function doLogin(hotelCode, pin) {
        setLoading(true);
        try {
          const verify = await api.verifyHotelWithPin(hotelCode, pin);
          if (!verify?.ok) {
            const reason = String(verify?.reason || "");
            if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else if (reason === "hotel_not_found") toast("error", "Virhe", "Hotellia ei löytynyt.");
            else if (reason === "missing_pin" || reason === "missing_hotel_code") toast("error", "Virhe", "Täytä hotellikoodi ja PIN.");
            else if (reason === "missing_function") toast("error", "Virhe", "Backendistä puuttuu verify_hotel_with_pin-funktio.");
            else toast("error", "Virhe", verify?.message || reason || "Kirjautuminen epäonnistui.");
            return;
          }

          setSessionFromVerify(verify, pin);
          state.session.masterName = await api.getHotelMasterName(state.session.hotelCode);

          $("#nav").style.display = "";
          $("#sessionChip").style.display = "";
          state.tab = "dashboard";

          await ensureLoaded();
          if (isAdminRole(state.session.role)) {
            await Promise.all([loadUsers(), loadLocations()]);
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Kirjautuminen onnistui.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Kirjautuminen epäonnistui");
        } finally {
          setLoading(false);
        }
      }

      async function requirePin({ title, message, forcePrompt = false, prefill = "", requireAdmin = false } = {}) {
        const saved = String(state.session.pin || "").trim();
        if (!forcePrompt && saved) return saved;
        const typed = await modalPromptPin({ title: title || "PIN", message: message || "Syötä PIN.", prefill });
        if (!typed) return "";
        const verify = await api.verifyHotelWithPin(state.session.hotelCode, typed);
        if (!verify?.ok) {
          toast("error", "Virhe", "Väärä PIN.");
          return "";
        }
        if (requireAdmin && !isAdminRole(verify?.role)) {
          toast("error", "Virhe", "Vain admin/master PIN käy tähän toimintoon.");
          return "";
        }
        state.session.pin = typed;
        return typed;
      }
      // ==========================================================
      // Actions
      // ==========================================================
      async function approvePendingRow(row, nextSeasonPaid) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        try {
          const rev = row?.rev;
          if (typeof rev !== "number") throw new Error("Rivin versiotieto puuttuu.");
          const cleanNotes = stripStaffApprovalTag(row?.notes);
          const patch = {};
          if (String(row?.notes || "").trim() !== String(cleanNotes || "").trim()) patch.notes = cleanNotes;
          if (typeof nextSeasonPaid === "boolean") patch.season_fee_paid = nextSeasonPaid;
          await api.updateTire(row.id, rev, patch);
          await loadTires();
          toast("success", "Ilmoitus", "Vahvistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Vahvistus epäonnistui.");
        }
      }

      async function approvePendingCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        try {
          await api.updateCustomer(customer.id, {});
          await loadCustomers();
          toast("success", "Ilmoitus", "Asiakas vahvistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Vahvistus epäonnistui.");
        }
      }

      async function softDeleteRow(row) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä admin/master PIN poistoa varten.", requireAdmin: true });
        if (!pin) return;
        try {
          await api.deleteTireWithPin(row.id, state.session.hotelCode, pin);
          await loadTires();
          toast("success", "Ilmoitus", "Poistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
        }
      }

      async function hardDeleteRow(row) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Vahvista pysyvä poisto", message: "Syötä admin/master PIN pysyvää poistoa varten.", forcePrompt: true, requireAdmin: true });
        if (!pin) return;
        try {
          await api.hardDeleteTireWithPin(row.id, state.session.hotelCode, pin);
          await loadTires();
          toast("success", "Ilmoitus", "Poistettu pysyvästi.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Pysyvä poisto epäonnistui.");
        }
      }

      async function softDeleteCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Poista asiakas", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        try {
          const out = await api.customerSoftDeleteCascadeWithPin(state.session.hotelCode, pin, customer.id);
          if (out?.ok !== true) throw new Error(out?.reason || "Poisto epäonnistui.");
          await ensureLoaded();
          toast("success", "Ilmoitus", `Poistettu (soft). Renkaat: ${out?.tires_soft_deleted ?? 0}`);
        } catch (e) {
          toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
        }
      }

      async function hardDeleteCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Poista asiakas pysyvästi", message: "Syötä admin/master PIN.", forcePrompt: true, requireAdmin: true });
        if (!pin) return;
        try {
          const out = await api.customerHardDeleteCascadeWithPin(state.session.hotelCode, pin, customer.id);
          if (out?.ok !== true) throw new Error(out?.reason || "Pysyvä poisto epäonnistui.");
          await ensureLoaded();
          toast("success", "Ilmoitus", `Poistettu pysyvästi. Renkaat: ${out?.tires_deleted ?? 0}`);
        } catch (e) {
          toast("error", "Virhe", e?.message || "Pysyvä poisto epäonnistui.");
        }
      }

      async function addNewRow(form) {
        const hotelCode = state.session.hotelCode;
        const f = {
          customer: String(form.customer || "").trim(),
          phone: String(form.phone || "").trim(),
          plate: String(form.plate || "").trim(),
          tire_size: String(form.email || "").trim(),
          location: String(form.location || "").trim(),
          status: "Varastossa",
          notes: String(form.notes || "").trim() || null,
          season_fee_paid: !!form.season_fee_paid,
        };
        if (!f.customer || !f.phone || !f.plate || !f.location) {
          toast("error", "Virhe", "Täytä pakolliset kentät: Asiakkaan nimi, Puhelinnumero, Rekisterinumero, Paikka.");
          return;
        }
        try {
          const duplicate = await api.findActiveTireByPlate(hotelCode, f.plate);
          if (duplicate) {
            toast("error", "Virhe", formatPlateDuplicateMessage(f.plate, duplicate));
            return;
          }

          const existing = await api.getCustomerByName(hotelCode, f.customer);
          if (!existing) {
            await api.addCustomer(hotelCode, { nimi: f.customer, puhelin: f.phone, sahkoposti: f.tire_size });
          } else {
            const patch = {};
            if (f.customer && existing.nimi !== f.customer) patch.nimi = f.customer;
            if (f.phone && existing.puhelin !== f.phone) patch.puhelin = f.phone;
            if (f.tire_size && existing.sahkoposti !== f.tire_size) patch.sahkoposti = f.tire_size;
            if (Object.keys(patch).length) await api.updateCustomer(existing.id, patch);
          }

          const canManageSeasonFee = isAdminRole(state.session.role);
          const payload = { ...f };
          if (!canManageSeasonFee) {
            payload.season_fee_paid = false;
            payload.notes = ensureAdminApprovalTag(payload.notes);
          }

          await api.addTire(hotelCode, payload);
          await ensureLoaded();
          toast("success", "Ilmoitus", "Tallennettu.");
          setTab("rows");
        } catch (e) {
          const msg = String(e?.message || "");
          if (msg.toLowerCase().includes("duplicate") || msg.toLowerCase().includes("unique")) {
            toast("error", "Virhe", "Hyllypaikka on jo varattu. Valitse toinen.");
          } else {
            toast("error", "Virhe", msg || "Tallennus epäonnistui.");
          }
        }
      }

      async function updateRowLocation(row, nextLocation) {
        const loc = String(nextLocation || "").trim();
        if (!loc) return toast("error", "Virhe", "Syötä hyllypaikka.");
        try {
          const rev = row?.rev;
          if (typeof rev !== "number") throw new Error("Rivin versiotieto puuttuu.");
          await api.updateTire(row.id, rev, { location: loc });
          await loadTires();
          toast("success", "Ilmoitus", "Hyllypaikka päivitetty.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivitys epäonnistui.");
        }
      }

      function blocksForSelectedDay() {
        const dateIso = state.data.calendarDate;
        const startDay = new Date(`${dateIso}T00:00:00Z`).getTime();
        const endDay = new Date(`${addDaysIso(dateIso, 1)}T00:00:00Z`).getTime();
        return (state.data.blocks || []).filter((b) => {
          const s = new Date(b.start_ts).getTime();
          const e = new Date(b.end_ts).getTime();
          return Number.isFinite(s) && Number.isFinite(e) && e > startDay && s < endDay;
        });
      }

      async function calendarCloseDay() {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Päivän sulku", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        const dateIso = state.data.calendarDate;
        const start = new Date(`${dateIso}T00:00:00`);
        const end = new Date(`${addDaysIso(dateIso, 1)}T00:00:00`);
        try {
          const out = await api.createBlockWithPin(state.session.hotelCode, pin, {
            start_ts: start.toISOString(),
            end_ts: end.toISOString(),
            kind: "CLOSED",
            title: "Suljettu",
            notes: null,
          });
          if (out?.ok === false && out?.reason === "wrong_pin") throw new Error("Väärä PIN.");
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Päivä suljettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivän sulku epäonnistui.");
        }
      }

      async function calendarOpenDay() {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Päivän avaus", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        const dayBlocks = blocksForSelectedDay();
        if (dayBlocks.length === 0) return toast("info", "Ilmoitus", "Ei sulkuja valitulle päivälle.");
        try {
          for (const b of dayBlocks) {
            const out = await api.deleteBlockWithPin(state.session.hotelCode, pin, b.id);
            if (out?.ok === false && out?.reason === "wrong_pin") throw new Error("Väärä PIN.");
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Päivä avattu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivän avaus epäonnistui.");
        }
      }
      // ==========================================================
      // UI
      // ==========================================================
      const root = $("#root");
      const nav = $("#nav");

      nav.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-tab]");
        if (!btn) return;
        setTab(btn.getAttribute("data-tab"));
      });

      function renderTopbar() {
        if (!state.session.ok) return;
        $$("#nav button").forEach((b) => b.classList.toggle("active", b.getAttribute("data-tab") === state.tab));
        $("#chipHotel").textContent = state.session.displayName || state.session.hotelCode || "—";
        const whoName = state.session.username ? String(state.session.username) : (state.session.masterName || "Master");
        const role = isAdminRole(state.session.role) ? "admin" : "staff";
        $("#chipWho").textContent = `Kirjautunut: ${whoName} (${role})`;
      }

      function renderLogin() {
        root.innerHTML = `
          <div class="row">
            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
                  <div>
                    <h1 class="h1">Kirjautuminen</h1>
                    <p class="p">Syötä hotellikoodi ja henkilökohtainen PIN. PIN unohtuessa ota yhteyttä ylläpitäjään.</p>
                  </div>
                  <span class="pill mono">web</span>
                </div>
                <div class="field">
                  <div class="label">Hotellikoodi <span class="req">*</span></div>
                  <input id="loginHotel" placeholder="Syötä saamasi hotellikoodi" autocomplete="off" />
                </div>
                <div class="field">
                  <div class="label">PIN <span class="req">*</span></div>
                  <input id="loginPin" type="password" placeholder="Syötä saamasi henkilökohtainen PIN-koodi" autocomplete="one-time-code" />
                </div>
                <div class="btn-row">
                  <button class="btn primary" id="loginBtn" ${state.ui.loading ? "disabled" : ""}>Kirjaudu / Vahvista</button>
                </div>
                <div class="divider"></div>
                <div class="p" style="margin:0">Ei Supabase Authia. Ei laitetallennusta. Istunto on vain muistissa.</div>
              </div>
            </div>
            <div class="col">
              <div class="card pad">
                <h1 class="h1">Huom</h1>
                <p class="p">Jos avaat tämän suoraan tiedostona ja kirjautuminen ei toimi, aja se paikallisella web-palvelimella (CORS/origin "null").</p>
              </div>
            </div>
          </div>
        `;

        const hotel = $("#loginHotel", root);
        const pin = $("#loginPin", root);
        const btn = $("#loginBtn", root);
        const go = () => doLogin(hotel.value, pin.value);
        btn.addEventListener("click", go);
        pin.addEventListener("keydown", (e) => { if (e.key === "Enter") go(); });
        hotel.addEventListener("keydown", (e) => { if (e.key === "Enter") pin.focus(); });
        setTimeout(() => hotel.focus(), 0);
      }

      function renderDashboard() {
        const tires = state.data.tires || [];
        const customers = state.data.customers || [];
        const pendingRows = tires.filter((r) => isPendingRowApproval(r));
        const activeRowCustomerKeys = new Set(tires.filter((r) => !r?.deleted).map((r) => normalizeNameKey(r?.customer)).filter(Boolean));
        const pendingCustomers = (customers || []).filter((c) => {
          if (!isPendingCustomerApproval(c)) return false;
          const key = normalizeNameKey(c?.nimi || c?.customer);
          if (!key) return true;
          return !activeRowCustomerKeys.has(key);
        });
        const totalPending = pendingRows.length + pendingCustomers.length;
        const canApprove = isAdminRole(state.session.role);

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Etusivu</h1>
                <p class="p">Hotelli: <span style="font-weight:900">${escapeHtml(state.session.displayName || state.session.hotelCode || "")}</span></p>
              </div>
              <div style="display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end;">
                <span class="pill">Rivit: ${tires.length}</span>
                <span class="pill">Asiakkaat: ${customers.length}</span>
                <span class="pill">Odottaa: ${totalPending}</span>
              </div>
            </div>
            <div class="btn-row" style="margin-top: 10px;">
              <button class="btn primary" id="dashNewRow">Uusi rivi</button>
              <button class="btn ghost" id="dashRefresh">Päivitä</button>
            </div>
          </div>

          <div class="row" style="margin-top: 12px;">
            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Odottaa vahvistusta (rivit)</div>
                  <span class="pill">${pendingRows.length}</span>
                </div>
                <div class="list">
                  ${pendingRows.slice(0, 10).map((r) => {
                    const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(r.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(r.plate))}</span></div>
                          <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))} · Luonut: ${escapeHtml(formatActor(r.created_by_name, r.created_by_role))}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                            <span class="pill">Odottaa admin-hyväksyntää</span>
                          </div>
                        </div>
                        <div class="actions">
                          ${canApprove ? `<button class="btn primary" data-approve-row="${escapeHtml(r.id)}">Hyväksy</button>` : ``}
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${pendingRows.length === 0 ? `<div class="muted">Ei odottavia rivejä.</div>` : ``}
                </div>
              </div>
            </div>

            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Odottaa vahvistusta (asiakkaat)</div>
                  <span class="pill">${pendingCustomers.length}</span>
                </div>
                <div class="list">
                  ${pendingCustomers.slice(0, 10).map((c) => {
                    const name = c.nimi || c.customer || "—";
                    const phone = c.puhelin || c.phone || "";
                    const email = c.sahkoposti || c.email || "";
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(name)}</div>
                          <div class="meta">${escapeHtml(phone)} ${email ? "· " + escapeHtml(email) : ""}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill">Odottaa admin-hyväksyntää</span>
                            <span class="pill">Luonut: ${escapeHtml(formatActor(c.created_by_name || c.luonut_nimi, c.created_by_role || c.luonut_rooli))}</span>
                          </div>
                        </div>
                        <div class="actions">
                          ${canApprove ? `<button class="btn primary" data-approve-customer="${escapeHtml(c.id)}">Hyväksy</button>` : ``}
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${pendingCustomers.length === 0 ? `<div class="muted">Ei odottavia asiakkaita.</div>` : ``}
                </div>
              </div>
            </div>
          </div>
        `;

        $("#dashNewRow", root).addEventListener("click", () => openNewRowModal());
        $("#dashRefresh", root).addEventListener("click", () => ensureLoaded());

        $$('[data-approve-row]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-row');
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            modalConfirm("Hyväksy lisätty rivi", "Valitse kausimaksun tila:", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Maksamaton", kind: "primary", onPress: () => approvePendingRow(row, false) },
              { text: "Maksettu", kind: "primary", onPress: () => approvePendingRow(row, true) },
            ]);
          });
        });
        $$('[data-approve-customer]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-customer');
            const customer = (state.data.customers || []).find((c) => String(c.id) === String(id));
            if (!customer) return;
            approvePendingCustomer(customer);
          });
        });
      }
      function renderWorklist() {
        const rows = state.data.tires || [];
        const customers = state.data.customers || [];
        const pendingApprovalRows = rows.filter((r) => isPendingRowApproval(r));
        const activeRowCustomerKeys = new Set(rows.filter((r) => !r?.deleted).map((r) => normalizeNameKey(r?.customer)).filter(Boolean));
        const pendingCustomerApprovals = (customers || []).filter((c) => {
          if (!isPendingCustomerApproval(c)) return false;
          const key = normalizeNameKey(c?.nimi || c?.customer);
          if (!key) return true;
          return !activeRowCustomerKeys.has(key);
        });

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Työlista</h1>
                <p class="p">Näytetään erityisesti odottavat vahvistukset.</p>
              </div>
              <span class="pill">Rivit: ${rows.length}</span>
            </div>
            <div class="btn-row" style="margin-top: 10px;">
              <button class="btn ghost" id="wlRefresh">Päivitä</button>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div style="display:flex; align-items:center; justify-content:space-between;">
              <div style="font-weight:900">Odottaa vahvistusta</div>
              <span class="pill">${pendingApprovalRows.length + pendingCustomerApprovals.length}</span>
            </div>
            <div class="divider"></div>
            <div class="list">
              ${pendingApprovalRows.map((r) => {
                const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(r.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(r.plate))}</span></div>
                      <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))} · Luonut: ${escapeHtml(formatActor(r.created_by_name, r.created_by_role))}</div>
                      <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                        <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                        <span class="pill">Odottaa admin-hyväksyntää</span>
                      </div>
                    </div>
                    <div class="actions">
                      ${isAdminRole(state.session.role) ? `<button class="btn primary" data-approve-row="${escapeHtml(r.id)}">Hyväksy</button>` : `<span class="pill">Ei oikeuksia</span>`}
                    </div>
                  </div>
                `;
              }).join("")}

              ${pendingCustomerApprovals.map((c) => {
                const name = c.nimi || c.customer || "—";
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(name)}</div>
                      <div class="meta">Odottaa admin-hyväksyntää</div>
                    </div>
                    <div class="actions">
                      ${isAdminRole(state.session.role) ? `<button class="btn primary" data-approve-customer="${escapeHtml(c.id)}">Hyväksy</button>` : `<span class="pill">Ei oikeuksia</span>`}
                    </div>
                  </div>
                `;
              }).join("")}

              ${(pendingApprovalRows.length + pendingCustomerApprovals.length) === 0 ? `<div class="muted">Ei odottavia vahvistuksia.</div>` : ``}
            </div>
          </div>
        `;

        $("#wlRefresh", root).addEventListener("click", () => ensureLoaded());

        $$('[data-approve-row]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-row');
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            modalConfirm("Hyväksy lisätty rivi", "Valitse kausimaksun tila:", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Maksamaton", kind: "primary", onPress: () => approvePendingRow(row, false) },
              { text: "Maksettu", kind: "primary", onPress: () => approvePendingRow(row, true) },
            ]);
          });
        });
        $$('[data-approve-customer]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-customer');
            const customer = (state.data.customers || []).find((c) => String(c.id) === String(id));
            if (!customer) return;
            approvePendingCustomer(customer);
          });
        });
      }

      function renderCustomers() {
        const customers = state.data.customers || [];
        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Asiakkaat</h1>
                <p class="p">Lista ei sisällä poistettuja (soft).</p>
              </div>
              <span class="pill">Yhteensä: ${customers.length}</span>
            </div>
            <div class="btn-row">
              <button class="btn ghost" id="custRefresh">Päivitä</button>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div class="field" style="margin:0">
              <div class="label">Hae</div>
              <input id="custSearch" placeholder="Nimi / puhelin / sähköposti" />
            </div>
            <div class="divider"></div>
            <div class="list" id="custList"></div>
          </div>
        `;

        $("#custRefresh", root).addEventListener("click", () => loadCustomers());
        const list = $("#custList", root);
        const search = $("#custSearch", root);

        const renderList = () => {
          const q = String(search.value || "").trim().toLowerCase();
          const filtered = !q ? customers : customers.filter((c) => {
            const name = String(c.nimi || c.customer || "").toLowerCase();
            const phone = String(c.puhelin || c.phone || "").toLowerCase();
            const email = String(c.sahkoposti || c.email || "").toLowerCase();
            return name.includes(q) || phone.includes(q) || email.includes(q);
          });

          list.innerHTML = (filtered.map((c) => {
            const name = c.nimi || c.customer || "—";
            const phone = c.puhelin || c.phone || "";
            const email = c.sahkoposti || c.email || "";
            const pending = isPendingCustomerApproval(c);
            return `
              <div class="item">
                <div class="main">
                  <div class="title">${escapeHtml(name)}</div>
                  <div class="meta">${escapeHtml(phone)} ${email ? "· " + escapeHtml(email) : ""}</div>
                  <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                    ${pending ? `<span class="pill">Odottaa admin-hyväksyntää</span>` : ``}
                    <span class="pill">Luonut: ${escapeHtml(formatActor(c.created_by_name || c.luonut_nimi, c.created_by_role || c.luonut_rooli))}</span>
                    <span class="pill">Päivitetty: ${escapeHtml(formatActor(c.updated_by_name || c.paivittanyt_nimi, c.updated_by_role || c.paivittanyt_rooli))}</span>
                  </div>
                </div>
                <div class="actions">
                  ${isAdminRole(state.session.role) ? `<button class="btn danger" data-cust-soft="${escapeHtml(c.id)}">Poista</button>` : ``}
                  ${isAdminRole(state.session.role) ? `<button class="btn danger" data-cust-hard="${escapeHtml(c.id)}">Poista pysyvästi</button>` : ``}
                </div>
              </div>
            `;
          }).join("")) || `<div class="muted">Ei asiakkaita.</div>`;

          $$('[data-cust-soft]', list).forEach((btn) => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-cust-soft');
              const c = customers.find((x) => String(x.id) === String(id));
              if (!c) return;
              modalConfirm("Poista asiakas", "Poistetaan asiakas ja renkaat (soft).", [
                { text: "Peruuta", kind: "ghost" },
                { text: "Poista", kind: "danger", onPress: () => softDeleteCustomer(c) },
              ]);
            });
          });
          $$('[data-cust-hard]', list).forEach((btn) => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-cust-hard');
              const c = customers.find((x) => String(x.id) === String(id));
              if (!c) return;
              modalConfirm("Poista asiakas pysyvästi", "Poistetaan asiakas ja renkaat tietokannasta (HARD).", [
                { text: "Peruuta", kind: "ghost" },
                { text: "Poista pysyvästi", kind: "danger", onPress: () => hardDeleteCustomer(c) },
              ]);
            });
          });
        };

        search.addEventListener("input", renderList);
        renderList();
      }
      function openNewRowModal() {
        const canManageSeasonFee = isAdminRole(state.session.role);
        const html = `
          <div class="msg">Lisää uusi rivi. Staff: kausimaksu ei valittavissa ja merkintä menee odottamaan admin-hyväksyntää.</div>
          <div class="field">
            <div class="label">Asiakkaan nimi <span class="req">*</span></div>
            <input id="nrName" />
            <div id="nrCustHint" style="margin-top:6px;"></div>
          </div>
          <div class="field">
            <div class="label">Puhelinnumero <span class="req">*</span></div>
            <input id="nrPhone" />
          </div>
          <div class="field">
            <div class="label">Sähköposti</div>
            <input id="nrEmail" />
          </div>
          <div class="field">
            <div class="label">Rekisterinumero <span class="req">*</span></div>
            <input id="nrPlate" />
            <div class="p danger-text" id="nrDup" style="display:none;margin:0"></div>
          </div>
          <div class="field">
            <div class="label">Hyllypaikka <span class="req">*</span></div>
            <input id="nrLoc" placeholder="esim. H01-A-01" />
          </div>
          <div class="field">
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
              <div class="label">Vapaat hyllypaikat</div>
              <button class="btn ghost" id="nrFreeRefresh" type="button">Päivitä</button>
            </div>
            <select id="nrFreeSelect">
              <option value="">Haetaan...</option>
            </select>
            <div class="p" id="nrFreeMeta" style="margin:0"></div>
          </div>
          <div class="field">
            <div class="label">Huomiot</div>
            <textarea id="nrNotes"></textarea>
          </div>
          <div class="field" ${canManageSeasonFee ? "" : "style='opacity:0.6'"}>
            <div class="label">Kausimaksu</div>
            <select id="nrSeason" ${canManageSeasonFee ? "" : "disabled"}>
              <option value="false">Maksamaton</option>
              <option value="true">Maksettu</option>
            </select>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="nrCancel">Peruuta</button>
            <button class="btn primary" id="nrSave">Tallenna</button>
          </div>
        `;

        openModal("Uusi rivi", html);

        const nameEl = $("#nrName", modalBody);
        const phoneEl = $("#nrPhone", modalBody);
        const emailEl = $("#nrEmail", modalBody);
        const locEl = $("#nrLoc", modalBody);
        const custHint = $("#nrCustHint", modalBody);
        const freeSelect = $("#nrFreeSelect", modalBody);
        const freeMeta = $("#nrFreeMeta", modalBody);
        const freeRefreshBtn = $("#nrFreeRefresh", modalBody);

        const plate = $("#nrPlate", modalBody);
        const dup = $("#nrDup", modalBody);
        let dupTimer = null;
        let custTimer = null;
        let lastCustomerKey = "";

        async function refreshFreeLocations() {
          freeRefreshBtn.disabled = true;
          freeSelect.innerHTML = `<option value=\"\">Haetaan...</option>`;
          freeMeta.textContent = "";
          try {
            const rows = await api.listFreeLocations(state.session.hotelCode);
            const items = Array.isArray(rows) ? rows : [];
            const opts = [`<option value=\"\">Valitse vapaa paikka</option>`].concat(
              items.map((r) => {
                const code = String(r?.code || r?.hyllypaikka || r?.location || "").trim();
                const label = String(r?.label || r?.nimi || r?.name || code).trim() || code || "—";
                if (!code) return "";
                return `<option value=\"${escapeHtml(code)}\">${escapeHtml(label)}</option>`;
              }).filter(Boolean)
            );
            freeSelect.innerHTML = opts.join("");
            freeMeta.textContent = items.length ? `${items.length} vapaata` : "Ei vapaita paikkoja";

            const firstCode = items
              .map((r) => String(r?.code || r?.hyllypaikka || r?.location || "").trim())
              .find((v) => !!v);
            if (!String(locEl.value || "").trim() && firstCode) {
              // täytä ensimmäinen ehdotus automaattisesti, jos kenttä tyhjä
              locEl.value = firstCode;
            }
          } catch (e) {
            freeSelect.innerHTML = `<option value=\"\">(Haku epäonnistui)</option>`;
            freeMeta.textContent = e?.message ? String(e.message) : "Haku epäonnistui";
          } finally {
            freeRefreshBtn.disabled = false;
          }
        }

        freeRefreshBtn.addEventListener("click", () => refreshFreeLocations());
        freeSelect.addEventListener("change", () => {
          const v = String(freeSelect.value || "").trim();
          if (v) locEl.value = v;
        });
        refreshFreeLocations();

        function renderCustomerHint(customerRow) {
          if (!customerRow) {
            custHint.innerHTML = "";
            return;
          }
          const p = String(customerRow?.puhelin || customerRow?.phone || "").trim();
          const e = String(customerRow?.sahkoposti || customerRow?.email || "").trim();
          const hasData = !!(p || e);
          const fillable = (p && !String(phoneEl.value || "").trim()) || (e && !String(emailEl.value || "").trim());
          custHint.innerHTML = `
            <div class=\"p\" style=\"margin:0\">Asiakas löytyy rekisteristä${hasData ? `: ${escapeHtml(p)} ${e ? \"· \" + escapeHtml(e) : \"\"}` : \".\"}</div>
            <div class=\"btn-row\" style=\"margin-top:8px; justify-content:flex-end;\">\n              <button class=\"btn ghost\" id=\"nrCustNo\" type=\"button\">Ei nyt</button>\n              <button class=\"btn primary\" id=\"nrCustFill\" type=\"button\" ${fillable ? \"\" : \"disabled\"}>Täytä</button>\n            </div>
          `;
          $("#nrCustNo", modalBody).addEventListener("click", () => {
            custHint.innerHTML = "";
          });
          $("#nrCustFill", modalBody).addEventListener("click", () => {
            if (p && !String(phoneEl.value || "").trim()) phoneEl.value = p;
            if (e && !String(emailEl.value || "").trim()) emailEl.value = e;
            custHint.innerHTML = "";
          });
        }

        nameEl.addEventListener("input", () => {
          const key = String(nameEl.value || "").trim();
          if (!key) {
            lastCustomerKey = "";
            custHint.innerHTML = "";
            clearTimeout(custTimer);
            return;
          }
          if (key === lastCustomerKey) return;
          clearTimeout(custTimer);
          custTimer = setTimeout(async () => {
            const curr = String(nameEl.value || "").trim();
            if (!curr || curr === lastCustomerKey) return;
            lastCustomerKey = curr;
            try {
              const found = await api.getCustomerByName(state.session.hotelCode, curr);
              if (found) renderCustomerHint(found);
              else custHint.innerHTML = "";
            } catch {
              // ignore
            }
          }, 300);
        });

        plate.addEventListener("input", () => {
          const v = String(plate.value || "").trim();
          clearTimeout(dupTimer);
          if (!v) {
            dup.style.display = "none";
            dup.textContent = "";
            return;
          }
          dupTimer = setTimeout(async () => {
            try {
              const found = await api.findActiveTireByPlate(state.session.hotelCode, v);
              if (found) {
                dup.textContent = formatPlateDuplicateMessage(v, found);
                dup.style.display = "";
              } else {
                dup.style.display = "none";
                dup.textContent = "";
              }
            } catch {
              // ignore
            }
          }, 350);
        });

        $("#nrCancel", modalBody).addEventListener("click", closeModal);
        $("#nrSave", modalBody).addEventListener("click", async () => {
          const form = {
            customer: nameEl.value,
            phone: phoneEl.value,
            email: emailEl.value,
            plate: $("#nrPlate", modalBody).value,
            location: locEl.value,
            notes: $("#nrNotes", modalBody).value,
            season_fee_paid: $("#nrSeason", modalBody).value === "true",
          };
          closeModal();
          await addNewRow(form);
        });

        setTimeout(() => nameEl.focus(), 0);
      }

      function openRowDetailsModal(row) {
        const isAdmin = isAdminRole(state.session.role);
        const meta = getStatusMeta(row.status, { isWaiting: row.waiting_pickup, isWorking: row.working });
        const season = isSeasonPaid(row.season_fee_paid)
          ? { t: "Maksettu", bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" }
          : { t: "Maksamaton", bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
        const pending = isPendingRowApproval(row);

        const html = `
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
            <div>
              <div style="font-weight:900; font-size:16px;">${escapeHtml(row.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(row.plate))}</span></div>
              <div class="p" style="margin-top:4px;">${escapeHtml(row.phone || "")} ${row.tire_size ? "· " + escapeHtml(row.tire_size) : ""}</div>
            </div>
            <div class="menu" data-row-menu>
              ${isAdmin ? `<button class="btn danger" data-row-menu-btn>Poista</button>` : ``}
              <div class="menu-pop" id="rowMenuPop">
                <button class="danger" id="rowSoftDel">Poista</button>
                <button class="danger" id="rowHardDel">Poista pysyvästi</button>
              </div>
            </div>
          </div>

          <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap;">
            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
            <span class="pill" style="background:${season.bg};border-color:${season.border};color:${season.color}">${escapeHtml(season.t)}</span>
            ${pending ? `<span class="pill">Odottaa vahvistusta</span>` : ``}
          </div>

          <div class="divider"></div>

          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div class="field" style="flex:1; margin:0">
              <div class="label">Hyllypaikka</div>
              <input id="rdLoc" value="${escapeHtml(String(row.location || ""))}" />
            </div>
            <div style="margin-top: 18px;">
              <button class="btn ghost" id="rdLocSave" style="white-space:nowrap;">Muokkaa</button>
            </div>
          </div>
          <div class="p" style="margin-top: 6px;">${isAdmin ? "Admin voi muokata muitakin tietoja mobiilissa." : "Staff voi muokata vain hyllypaikkaa."}</div>

          <div class="divider"></div>

          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <span class="pill">Luonut: ${escapeHtml(formatActor(row.created_by_name, row.created_by_role))}</span>
            <span class="pill">Päivitetty: ${escapeHtml(formatActor(row.updated_by_name, row.updated_by_role))}</span>
            <span class="pill">Luovutti: ${escapeHtml(formatActor(row.delivered_by_name, row.delivered_by_role))}</span>
          </div>

          <div class="field">
            <div class="label">Huomiot</div>
            <textarea readonly>${escapeHtml(String(row.notes || ""))}</textarea>
          </div>

          ${isAdmin && pending ? `
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn primary" id="rdApprovePaid">Hyväksy (Maksettu)</button>
              <button class="btn primary" id="rdApproveUnpaid">Hyväksy (Maksamaton)</button>
            </div>
          ` : ``}
        `;

        openModal("Rivin tiedot", html);

        const menuBtn = $("[data-row-menu-btn]", modalBody);
        if (menuBtn) {
          const pop = $("#rowMenuPop", modalBody);
          menuBtn.addEventListener("click", () => pop.classList.toggle("open"));
          $("#rowSoftDel", modalBody).addEventListener("click", () => {
            pop.classList.remove("open");
            modalConfirm("Poista rivi", "Poistetaan rivi (soft).", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Poista", kind: "danger", onPress: () => { closeModal(); softDeleteRow(row); } },
            ]);
          });
          $("#rowHardDel", modalBody).addEventListener("click", () => {
            pop.classList.remove("open");
            modalConfirm("Poista rivi pysyvästi", "Poistetaan rivi tietokannasta (HARD).", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Poista pysyvästi", kind: "danger", onPress: () => { closeModal(); hardDeleteRow(row); } },
            ]);
          });
        }

        $("#rdLocSave", modalBody).addEventListener("click", async () => {
          const next = $("#rdLoc", modalBody).value;
          closeModal();
          await updateRowLocation(row, next);
        });

        if (isAdmin && pending) {
          const paid = $("#rdApprovePaid", modalBody);
          const unpaid = $("#rdApproveUnpaid", modalBody);
          if (paid) paid.addEventListener("click", () => { closeModal(); approvePendingRow(row, true); });
          if (unpaid) unpaid.addEventListener("click", () => { closeModal(); approvePendingRow(row, false); });
        }
      }

      function renderRows() {
        const tires = state.data.tires || [];
        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Rivit</h1>
                <p class="p">Staff voi muokata vain hyllypaikkaa. Admin voi hyväksyä ja poistaa.</p>
              </div>
              <span class="pill">Näytetään: ${tires.length}</span>
            </div>
            <div class="btn-row">
              <button class="btn primary" id="rowsNew">Uusi rivi</button>
              <button class="btn ghost" id="rowsRefresh">Päivitä</button>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div class="field" style="margin:0">
              <div class="label">Hae</div>
              <input id="rowsSearch" placeholder="Nimi / rek / paikka" />
            </div>
            <div class="divider"></div>
            <div class="list" id="rowsList"></div>
          </div>
        `;

        $("#rowsNew", root).addEventListener("click", () => openNewRowModal());
        $("#rowsRefresh", root).addEventListener("click", () => loadTires());

        const list = $("#rowsList", root);
        const search = $("#rowsSearch", root);

        const renderList = () => {
          const q = String(search.value || "").trim().toLowerCase();
          const filtered = !q ? tires : tires.filter((r) => {
            const name = String(r.customer || "").toLowerCase();
            const plate = String(r.plate || "").toLowerCase();
            const loc = String(r.location || "").toLowerCase();
            return name.includes(q) || plate.includes(q) || loc.includes(q);
          });

          list.innerHTML = (filtered.map((r) => {
            const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
            const pending = isPendingRowApproval(r);
            const season = isSeasonPaid(r.season_fee_paid)
              ? { t: "Maksettu", bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" }
              : { t: "Maksamaton", bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
            return `
              <div class="item">
                <div class="main">
                  <div class="title">${escapeHtml(r.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(r.plate))}</span></div>
                  <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))}</div>
                  <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                    <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                    <span class="pill" style="background:${season.bg};border-color:${season.border};color:${season.color}">${escapeHtml(season.t)}</span>
                    ${pending ? `<span class="pill">Odottaa vahvistusta</span>` : ``}
                  </div>
                </div>
                <div class="actions">
                  <button class="btn ghost" data-row-open="${escapeHtml(r.id)}">Avaa</button>
                </div>
              </div>
            `;
          }).join("")) || `<div class="muted">Ei rivejä.</div>`;

          $$('[data-row-open]', list).forEach((btn) => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-row-open');
              const row = tires.find((x) => String(x.id) === String(id));
              if (!row) return;
              openRowDetailsModal(row);
            });
          });
        };

        search.addEventListener("input", renderList);
        renderList();
      }
      function renderCalendar() {
        const pad2 = (n) => String(n).padStart(2, "0");
        const isoDateFromLocalTs = (ts) => {
          const d = new Date(ts);
          const y = d.getFullYear();
          const m = pad2(d.getMonth() + 1);
          const day = pad2(d.getDate());
          return `${y}-${m}-${day}`;
        };
        const clockFromTs = (ts) => {
          const d = new Date(ts);
          return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
        };
        const fiWeekdayShort = (iso) => {
          const d = new Date(`${iso}T00:00:00`);
          const map = ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"];
          return map[d.getDay()] || "";
        };
        const weekStart = getMondayIso(state.data.calendarDate);
        const weekEnd = addDaysIso(weekStart, 6);
        const weekDays = Array.from({ length: 7 }, (_, i) => addDaysIso(weekStart, i));

        const blocks = Array.isArray(state.data.blocks) ? state.data.blocks : [];
        const apptsRaw = Array.isArray(state.data.appointments) ? state.data.appointments : [];
        const appts = apptsRaw
          .map((a) => {
            const startMs = new Date(a.start_ts).getTime();
            const endMs = new Date(a.end_ts).getTime();
            const dayIso = isoDateFromLocalTs(a.start_ts);
            const bay = parseInt(a?.bay ?? a?.nosturi ?? a?.lane, 10);
            return { ...a, startMs, endMs, dayIso, bay: bay === 2 ? 2 : 1 };
          })
          .filter((a) => Number.isFinite(a.startMs) && Number.isFinite(a.endMs) && a.endMs > a.startMs);

        const apptsByDay = new Map();
        for (const day of weekDays) apptsByDay.set(day, []);
        for (const a of appts) {
          if (!apptsByDay.has(a.dayIso)) continue;
          apptsByDay.get(a.dayIso).push(a);
        }
        for (const day of weekDays) {
          apptsByDay.get(day).sort((x, y) => x.startMs - y.startMs);
        }

        const dayBlocks = (dayIso) => {
          const startDay = new Date(`${dayIso}T00:00:00Z`).getTime();
          const endDay = new Date(`${addDaysIso(dayIso, 1)}T00:00:00Z`).getTime();
          return blocks.filter((b) => {
            const s = new Date(b.start_ts).getTime();
            const e = new Date(b.end_ts).getTime();
            return Number.isFinite(s) && Number.isFinite(e) && e > startDay && s < endDay;
          });
        };

        const selectedDay = String(state.data.calendarDate || todayStrLocal());
        const selectedBlocks = dayBlocks(selectedDay);
        const selectedClosed = selectedBlocks.length > 0;
        const selectedAppts = apptsByDay.get(selectedDay) || [];

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Kalenteri</h1>
                <p class="p">Viikko: <span style="font-weight:900">${escapeHtml(weekStart)}</span> – <span style="font-weight:900">${escapeHtml(weekEnd)}</span></p>
              </div>
              <div style="display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end;">
                <span class="pill">${selectedClosed ? "Suljettu" : "Auki"}</span>
                <span class="pill">Varaukset (päivä): ${selectedAppts.length}</span>
              </div>
            </div>

            <div class="row" style="margin-top: 10px;">
              <div class="col" style="min-width: 260px;">
                <div class="field" style="margin:0">
                  <div class="label">Viikon valinta</div>
                  <input id="calPick" type="date" value="${escapeHtml(selectedDay)}" />
                </div>
              </div>
              <div class="col" style="min-width: 260px;">
                <div class="btn-row" style="margin-top: 20px; justify-content:flex-end;">
                  <button class="btn ghost" id="calPrevWeek">← Viikko</button>
                  <button class="btn ghost" id="calToday">Tänään</button>
                  <button class="btn ghost" id="calNextWeek">Viikko →</button>
                  <button class="btn ghost" id="calRefresh">Päivitä</button>
                </div>
              </div>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
              <div style="font-weight:900">Viikkonäkymä</div>
              <span class="pill">${appts.length} varausta</span>
            </div>
            <div class="divider"></div>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px;">
              ${weekDays.map((dayIso) => {
                const dayAppts = apptsByDay.get(dayIso) || [];
                const closed = dayBlocks(dayIso).length > 0;
                const isSelected = dayIso === selectedDay;
                return `
                  <div class="card pad" style="box-shadow:none; border-color:${isSelected ? "rgba(14, 122, 254, 0.55)" : "#e2e8f0"}; background:${isSelected ? "rgba(14, 122, 254, 0.04)" : "white"}; cursor:pointer;" data-cal-day="${escapeHtml(dayIso)}">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                      <div style="font-weight:900">${escapeHtml(fiWeekdayShort(dayIso))} ${escapeHtml(dayIso)}</div>
                      <span class="pill">${dayAppts.length}</span>
                    </div>
                    <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                      ${closed ? `<span class="pill">Suljettu</span>` : ``}
                    </div>
                    <div style="margin-top:10px;" class="muted">
                      ${dayAppts.slice(0, 3).map((a) => {
                        const label = `${clockFromTs(a.start_ts)}-${clockFromTs(a.end_ts)} · ${String(a.customer_name || "").trim() || "—"}`;
                        return `<div style="font-size:13px; line-height:1.35; margin-top:4px;">${escapeHtml(label)}</div>`;
                      }).join("")}
                      ${dayAppts.length > 3 ? `<div style="font-size:13px; margin-top:6px;">+${dayAppts.length - 3} lisää</div>` : ``}
                      ${dayAppts.length === 0 ? `<div style="font-size:13px;">Ei varauksia</div>` : ``}
                    </div>
                  </div>
                `;
              }).join("")}
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <div style="font-weight:900; font-size:16px;">${escapeHtml(selectedDay)} · ${escapeHtml(fiWeekdayShort(selectedDay))}</div>
                <div class="p" style="margin-top:4px">Varaukset ja päivän sulku/avaus.</div>
              </div>
              <div class="btn-row" style="margin-top: 0; justify-content:flex-end;">
                <button class="btn primary" id="calNewAppt" ${isAdminRole(state.session.role) ? "" : "disabled"}>Uusi varaus</button>
                <button class="btn primary" id="calClose" ${isAdminRole(state.session.role) ? "" : "disabled"}>Sulje päivä</button>
                <button class="btn danger" id="calOpen" ${isAdminRole(state.session.role) ? "" : "disabled"}>Avaa päivä</button>
              </div>
            </div>

            <div class="divider"></div>

            <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
              <div style="font-weight:900">Varaukset</div>
              <span class="pill">${selectedAppts.length}</span>
            </div>
            <div class="list" style="margin-top:10px;">
              ${selectedAppts.map((a) => {
                const who = String(a.customer_name || "").trim() || "—";
                const plate = String(a.plate || "").trim();
                const phone = String(a.phone || "").trim();
                const notes = String(a.notes || "").trim();
                const time = `${clockFromTs(a.start_ts)}-${clockFromTs(a.end_ts)}`;
                const bay = a.bay === 2 ? "Nosturi 2" : "Nosturi 1";
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(time)} · ${escapeHtml(bay)} · ${escapeHtml(who)}</div>
                      <div class="meta">${plate ? "Rek: " + escapeHtml(plate) : ""}${plate && phone ? " · " : ""}${phone ? "Puh: " + escapeHtml(phone) : ""}${notes ? "<br/>" + escapeHtml(notes) : ""}</div>
                    </div>
                    <div class="actions">
                      ${isAdminRole(state.session.role) ? `<button class="btn danger" data-appt-del="${escapeHtml(String(a.id || ""))}">Poista</button>` : ``}
                    </div>
                  </div>
                `;
              }).join("")}
              ${selectedAppts.length === 0 ? `<div class="muted">Ei varauksia tälle päivälle.</div>` : ``}
            </div>

            <div class="divider"></div>

            <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
              <div style="font-weight:900">Sulut (valittu päivä)</div>
              <span class="pill">${selectedBlocks.length}</span>
            </div>
            <div class="list">
              ${selectedBlocks.map((b) => {
                const s = new Date(b.start_ts);
                const e = new Date(b.end_ts);
                const label = `${s.toLocaleString()} → ${e.toLocaleString()}`;
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(String(b.title || b.kind || "Sulku"))}</div>
                      <div class="meta">${escapeHtml(label)}</div>
                    </div>
                    <div class="actions">
                      <button class="btn danger" data-del-block="${escapeHtml(b.id)}" ${isAdminRole(state.session.role) ? "" : "disabled"}>Poista sulku</button>
                    </div>
                  </div>
                `;
              }).join("")}
              ${selectedBlocks.length === 0 ? `<div class="muted">Ei sulkuja.</div>` : ``}
            </div>
          </div>
        `;

        $("#calPick", root).addEventListener("change", (e) => {
          state.data.calendarDate = String(e.target.value || todayStrLocal());
          loadCalendarWeek();
        });
        $("#calPrevWeek", root).addEventListener("click", () => {
          state.data.calendarDate = addDaysIso(weekStart, -7);
          loadCalendarWeek();
        });
        $("#calNextWeek", root).addEventListener("click", () => {
          state.data.calendarDate = addDaysIso(weekStart, 7);
          loadCalendarWeek();
        });
        $("#calToday", root).addEventListener("click", () => {
          state.data.calendarDate = todayStrLocal();
          loadCalendarWeek();
        });
        $("#calRefresh", root).addEventListener("click", () => loadCalendarWeek());

        $$("[data-cal-day]", root).forEach((el) => {
          el.addEventListener("click", () => {
            const dayIso = el.getAttribute("data-cal-day");
            if (!dayIso) return;
            state.data.calendarDate = dayIso;
            render(); // same week already loaded
          });
        });

        $("#calClose", root).addEventListener("click", () => calendarCloseDay());
        $("#calOpen", root).addEventListener("click", () => calendarOpenDay());

        $("#calNewAppt", root).addEventListener("click", () => {
          if (!isAdminRole(state.session.role)) return;
          const defaultStart = `${selectedDay}T08:00`;
          const defaultEnd = `${selectedDay}T09:00`;
          const customerNames = (state.data.customers || []).map((c) => String(c?.nimi || c?.customer || "").trim()).filter(Boolean);
          const uniquePlates = Array.from(new Set((state.data.tires || []).map((r) => normalizePlate(r?.plate)).filter(Boolean))).slice(0, 200);

          const html = `
            <div class="msg">Uusi varaus (admin/master PIN).</div>
            <div class="row">
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Alkaa</div>
                  <input id="apStart" type="datetime-local" value="${escapeHtml(defaultStart)}" />
                </div>
              </div>
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Päättyy</div>
                  <input id="apEnd" type="datetime-local" value="${escapeHtml(defaultEnd)}" />
                </div>
              </div>
              <div class="col" style="min-width:180px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Nosturi</div>
                  <select id="apBay">
                    <option value="1">1</option>
                    <option value="2">2</option>
                  </select>
                </div>
              </div>
            </div>

            <datalist id="apCustomerList">
              ${customerNames.slice(0, 250).map((n) => `<option value="${escapeHtml(n)}"></option>`).join("")}
            </datalist>
            <datalist id="apPlateList">
              ${uniquePlates.map((p) => `<option value="${escapeHtml(p)}"></option>`).join("")}
            </datalist>

            <div class="field">
              <div class="label">Asiakas</div>
              <input id="apCustomer" list="apCustomerList" placeholder="Asiakkaan nimi" />
            </div>
            <div class="field">
              <div class="label">Puhelin</div>
              <input id="apPhone" placeholder="Puhelinnumero" />
            </div>
            <div class="field">
              <div class="label">Rekisteri</div>
              <input id="apPlate" list="apPlateList" placeholder="ABC-123" />
              <div class="p" id="apPlateHint" style="margin:0"></div>
            </div>
            <div class="field">
              <div class="label">Huomiot</div>
              <textarea id="apNotes"></textarea>
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="apCancel" type="button">Peruuta</button>
              <button class="btn primary" id="apSave" type="button">Tallenna</button>
            </div>
          `;
          openModal("Uusi varaus", html);

          const cEl = $("#apCustomer", modalBody);
          const pEl = $("#apPhone", modalBody);
          const plateEl = $("#apPlate", modalBody);
          const hint = $("#apPlateHint", modalBody);

          cEl.addEventListener("change", () => {
            const key = String(cEl.value || "").trim();
            if (!key) return;
            const match = (state.data.customers || []).find((c) => String(c?.nimi || c?.customer || "").trim() === key);
            if (match && !String(pEl.value || "").trim()) {
              const v = String(match?.puhelin || match?.phone || "").trim();
              if (v) pEl.value = v;
            }
          });
          plateEl.addEventListener("input", () => {
            const norm = normalizePlate(plateEl.value);
            if (!norm) { hint.textContent = ""; return; }
            const row = (state.data.tires || []).find((r) => normalizePlate(r?.plate) === norm);
            if (row) {
              hint.textContent = `Hyllypaikka: ${String(row.location || row.last_location || "—")}`;
              if (!String(cEl.value || "").trim() && String(row.customer || "").trim()) {
                cEl.value = String(row.customer || "").trim();
              }
              if (!String(pEl.value || "").trim() && String(row.phone || "").trim()) {
                pEl.value = String(row.phone || "").trim();
              }
            } else {
              hint.textContent = "";
            }
          });

          $("#apCancel", modalBody).addEventListener("click", closeModal);
          $("#apSave", modalBody).addEventListener("click", async () => {
            const startVal = String($("#apStart", modalBody).value || "").trim();
            const endVal = String($("#apEnd", modalBody).value || "").trim();
            const bay = parseInt($("#apBay", modalBody).value, 10) || 1;
            const customer_name = String($("#apCustomer", modalBody).value || "").trim() || null;
            const phone = String($("#apPhone", modalBody).value || "").trim() || null;
            const plate = String($("#apPlate", modalBody).value || "").trim() || null;
            const notes = String($("#apNotes", modalBody).value || "").trim() || null;
            if (!startVal || !endVal) return toast("error", "Virhe", "Täytä alku ja loppu.");
            const startIso = new Date(startVal).toISOString();
            const endIso = new Date(endVal).toISOString();
            if (new Date(endIso).getTime() <= new Date(startIso).getTime()) return toast("error", "Virhe", "Aika ei kelpaa.");

            closeModal();
            const pin = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN varaukseen.", requireAdmin: true });
            if (!pin) return;
            try {
              const out = await api.createAppointmentWithPin(state.session.hotelCode, pin, { start_ts: startIso, end_ts: endIso, bay, customer_name, phone, plate, notes });
              if (out?.ok !== true) {
                const reason = String(out?.reason || "");
                if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
                else toast("error", "Virhe", out?.message || reason || "Varauksen luonti epäonnistui.");
                return;
              }
              await loadCalendarWeek();
              toast("success", "Ilmoitus", "Varaus tallennettu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Varauksen luonti epäonnistui.");
            }
          });
        });

        $$("[data-appt-del]", root).forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-appt-del");
            if (!id) return;
            modalConfirm("Poista varaus?", "Poistetaanko varaus?", [
              { text: "Peruuta", kind: "ghost" },
              {
                text: "Poista",
                kind: "danger",
                onPress: async () => {
                  const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä admin/master PIN.", requireAdmin: true });
                  if (!pin) return;
                  const out = await api.deleteAppointmentWithPin(state.session.hotelCode, pin, id);
                  if (out?.ok !== true) {
                    const reason = String(out?.reason || "");
                    if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
                    else toast("error", "Virhe", out?.message || reason || "Poisto epäonnistui.");
                    return;
                  }
                  await loadCalendarWeek();
                  toast("success", "Ilmoitus", "Varaus poistettu.");
                },
              },
            ]);
          });
        });

        $$('[data-del-block]', root).forEach((btn) => {
          btn.addEventListener('click', async () => {
            const id = btn.getAttribute('data-del-block');
            const pin = await requirePin({ title: "Poista sulku", message: "Syötä admin/master PIN.", requireAdmin: true });
            if (!pin) return;
            const out = await api.deleteBlockWithPin(state.session.hotelCode, pin, id);
            if (out?.ok === false && out?.reason === "wrong_pin") return toast("error", "Virhe", "Väärä PIN.");
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Sulku poistettu.");
          });
        });
      }

      function openAddLocationModal() {
        const html = `
          <div class="msg">Lisää hyllypaikka.</div>
          <div class="row">
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Hylly (numero)</div>
                <input id="locShelf" type="number" min="1" max="99" value="1" />
              </div>
            </div>
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Rivi (kirjain)</div>
                <input id="locRow" maxlength="1" value="A" />
              </div>
            </div>
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Paikka (numero)</div>
                <input id="locSpot" type="number" min="1" max="99" value="1" />
              </div>
            </div>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="locCancel">Peruuta</button>
            <button class="btn primary" id="locSave">Tallenna</button>
          </div>
        `;
        openModal("Lisää hyllypaikka", html);
        $("#locCancel", modalBody).addEventListener("click", closeModal);
        $("#locSave", modalBody).addEventListener("click", async () => {
          const shelf = parseInt($("#locShelf", modalBody).value, 10) || 1;
          const rowLetter = String($("#locRow", modalBody).value || "A").trim().toUpperCase().slice(0, 1) || "A";
          const spot = parseInt($("#locSpot", modalBody).value, 10) || 1;
          closeModal();
          try {
            await api.addLocation(state.session.hotelCode, shelf, rowLetter, spot);
            await loadLocations();
            toast("success", "Ilmoitus", "Lisätty.");
          } catch (e) {
            toast("error", "Virhe", e?.message || "Lisäys epäonnistui");
          }
        });
        setTimeout(() => $("#locShelf", modalBody).focus(), 0);
      }

      function openUpsertUserModal(existing = null) {
        const html = `
          <div class="msg">Luo / päivitä käyttäjä. (Jos backendissä ei ole upsert_hotel_user_pin_with_pin, käytetään master-PIN:ä.)</div>
          <div class="field" style="margin-top:10px">
            <div class="label">Käyttäjänimi <span class="req">*</span></div>
            <input id="uName" value="${escapeHtml(String(existing?.username || ""))}" ${existing?.is_master ? "disabled" : ""}/>
          </div>
          <div class="field">
            <div class="label">Uusi PIN <span class="req">*</span></div>
            <input id="uPin" type="password" />
          </div>
          <div class="field">
            <div class="label">Rooli</div>
            <select id="uRole">
              <option value="staff">staff</option>
              <option value="admin">admin</option>
            </select>
          </div>
          <div class="field">
            <div class="label">Aktiivinen</div>
            <select id="uActive">
              <option value="true">kyllä</option>
              <option value="false">ei</option>
            </select>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="uCancel">Peruuta</button>
            <button class="btn primary" id="uSave">Tallenna</button>
          </div>
        `;
        openModal("Luo / päivitä käyttäjä", html);
        $("#uRole", modalBody).value = existing?.role === "admin" ? "admin" : "staff";
        $("#uActive", modalBody).value = existing?.is_active === false ? "false" : "true";
        $("#uCancel", modalBody).addEventListener("click", closeModal);
        $("#uSave", modalBody).addEventListener("click", async () => {
          const username = String($("#uName", modalBody).value || "").trim();
          const newPin = String($("#uPin", modalBody).value || "").trim();
          const role = $("#uRole", modalBody).value === "admin" ? "admin" : "staff";
          const isActive = $("#uActive", modalBody).value === "true";
          if (!username || !newPin) return toast("error", "Virhe", "Täytä käyttäjänimi ja uusi PIN.");
          closeModal();

          const pinForAction = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN.", requireAdmin: true });
          if (!pinForAction) return;

          let out = await api.upsertHotelUserPinWithPin(state.session.hotelCode, pinForAction, username, newPin, role, isActive);
          if (out?.ok !== true && out?.reason === "missing_function") {
            const masterPin = await requirePin({ title: "Master PIN", message: "Syötä master-PIN käyttäjän luontiin/päivitykseen.", forcePrompt: true, prefill: state.session.pinSource === "master" ? (state.session.pin || "") : "", requireAdmin: true });
            if (!masterPin) return;
            out = await api.upsertHotelUserPinWithMasterPin(state.session.hotelCode, masterPin, username, newPin, role, isActive);
          }

          if (out?.ok !== true) {
            const reason = String(out?.reason || "");
            if (reason === "wrong_master_pin" || reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", out?.message || reason || "Tallennus epäonnistui.");
            return;
          }

          await loadUsers();
          toast("success", "Ilmoitus", "Tallennettu.");
        });
        setTimeout(() => $("#uName", modalBody).focus(), 0);
      }

      function openOwnPinModal() {
        const html = `
          <div class="msg">Vaihda oma PIN. Tämä ei tallenna PINiä laitteelle.</div>
          <div class="field" style="margin-top:10px">
            <div class="label">Käyttäjänimi</div>
            <input id="opUser" value="${escapeHtml(String(state.session.username || ""))}" />
          </div>
          <div class="field">
            <div class="label">Vanha PIN</div>
            <input id="opOld" type="password" />
          </div>
          <div class="field">
            <div class="label">Uusi PIN</div>
            <input id="opNew" type="password" />
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="opCancel">Peruuta</button>
            <button class="btn primary" id="opSave">Tallenna</button>
          </div>
        `;
        openModal("Vaihda oma PIN", html);
        $("#opCancel", modalBody).addEventListener("click", closeModal);
        $("#opSave", modalBody).addEventListener("click", async () => {
          const username = String($("#opUser", modalBody).value || "").trim();
          const oldPin = String($("#opOld", modalBody).value || "").trim();
          const newPin = String($("#opNew", modalBody).value || "").trim();
          closeModal();
          if (!username || !oldPin || !newPin) return toast("error", "Virhe", "Täytä kaikki kentät.");
          try {
            const out = await api.changeOwnPin(state.session.hotelCode, username, oldPin, newPin);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "PINin vaihto epäonnistui.");
              return;
            }
            state.session.pin = newPin;
            toast("success", "Ilmoitus", "PIN vaihdettu.");
          } catch (e) {
            toast("error", "Virhe", e?.message || "PINin vaihto epäonnistui.");
          }
        });
      }
      function renderSettings() {
        const isAdmin = isAdminRole(state.session.role);

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Asetukset</h1>
                <p class="p">Turva-asetuksista vain automaattinen kirjaus ulos. Ei laitetallennusta.</p>
              </div>
              <button class="btn danger" id="logoutBtn">Kirjaudu ulos</button>
            </div>
          </div>

          <div class="row" style="margin-top: 12px;">
            <div class="col">
              <div class="card pad">
                <div style="font-weight:900">Turva</div>
                <div class="field">
                  <div class="label">Automaattinen kirjaus ulos (min)</div>
                  <input id="autoLogout" type="number" min="0" max="240" value="${escapeHtml(String(state.security.autoLogoutMinutes))}" />
                  <div class="p" style="margin:0">0 = pois päältä</div>
                </div>
              </div>
            </div>
            <div class="col">
              <div class="card pad">
                <div style="font-weight:900">Oma PIN</div>
                <p class="p">Vaihda oma PIN, jos backendissä on <span style="font-family:var(--mono)">change_hotel_user_pin_with_old_pin</span>.</p>
                <div class="btn-row">
                  <button class="btn ghost" id="ownPinBtn">Vaihda oma PIN</button>
                </div>
              </div>
            </div>
          </div>

          ${isAdmin ? `
            <div class="row" style="margin-top: 12px;">
              <div class="col">
                <div class="card pad">
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <div style="font-weight:900">Käyttäjät</div>
                    <button class="btn primary" id="userAddBtn">Luo / päivitä</button>
                  </div>
                  <div class="divider"></div>
                  <div class="list" id="userList"></div>
                </div>
              </div>
              <div class="col">
                <div class="card pad">
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <div style="font-weight:900">Hyllypaikkojen hallinta</div>
                    <button class="btn primary" id="locAddBtn">Lisää</button>
                  </div>
                  <div class="divider"></div>
                  <div class="list" id="locList"></div>
                </div>
              </div>
            </div>
          ` : ``}
        `;

        $("#logoutBtn", root).addEventListener("click", () => logout("Kirjautuminen päättyi."));
        $("#autoLogout", root).addEventListener("input", (e) => {
          state.security.autoLogoutMinutes = clamp(parseInt(e.target.value, 10) || 0, 0, 240);
        });
        $("#ownPinBtn", root).addEventListener("click", () => openOwnPinModal());

        if (!isAdmin) return;

        // Users
        const users = state.data.users || [];
        const userList = $("#userList", root);
        userList.innerHTML = (users.map((u) => {
          const isMaster = u?.is_master === true || String(u?.id) === "master";
          const username = String(u?.username || "").trim() || (isMaster ? (state.session.masterName || "Master") : "—");
          const role = isMaster ? "master" : String(u?.role || "staff");
          const active = !!u?.is_active;
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(username)} · <span class="pill mono">${escapeHtml(role)}</span></div>
                <div class="meta">${isMaster ? "Hotellin oletus-PIN (master/admin)" : ""}</div>
              </div>
              <div class="actions">
                <button class="btn ghost" data-user-reset="${escapeHtml(username)}" ${isMaster ? "disabled" : ""}>Nollaa PIN</button>
                <button class="btn ${active ? "ghost" : "danger"}" data-user-toggle="${escapeHtml(username)}" ${isMaster ? "disabled" : ""}>${active ? "Aktiivinen" : "Pois käytöstä"}</button>
              </div>
            </div>
          `;
        }).join("")) || `<div class="muted">Ei käyttäjiä.</div>`;

        $("#userAddBtn", root).addEventListener("click", () => openUpsertUserModal());

        $$('[data-user-reset]', userList).forEach((btn) => {
          btn.addEventListener('click', () => {
            const username = btn.getAttribute('data-user-reset');
            if (!username) return;
            openUpsertUserModal({ username, role: "staff", is_active: true });
          });
        });
        $$('[data-user-toggle]', userList).forEach((btn) => {
          btn.addEventListener('click', async () => {
            const username = btn.getAttribute('data-user-toggle');
            const user = users.find((u) => String(u?.username || "") === String(username));
            if (!user) return;
            const next = !user.is_active;
            const pin = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN.", requireAdmin: true });
            if (!pin) return;
            const out = await api.setHotelUserActiveWithPin(state.session.hotelCode, pin, username, next);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Päivitys epäonnistui.");
              return;
            }
            await loadUsers();
            toast("success", "Ilmoitus", "Päivitetty.");
          });
        });

        // Locations
        const locs = state.data.locations || [];
        const locList = $("#locList", root);
        locList.innerHTML = (locs.map((l) => {
          const label = l.label || l.code || "—";
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(label)}</div>
                <div class="meta">${escapeHtml(String(l.code || ""))}</div>
              </div>
              <div class="actions">
                <button class="btn danger" data-loc-del="${escapeHtml(String(l.id))}">Poista</button>
              </div>
            </div>
          `;
        }).join("")) || `<div class="muted">Ei hyllypaikkoja.</div>`;

        $("#locAddBtn", root).addEventListener("click", () => openAddLocationModal());

        $$('[data-loc-del]', locList).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-loc-del');
            modalConfirm("Poista hyllypaikka", "Poistetaanko hyllypaikka?", [
              { text: "Peruuta", kind: "ghost" },
              {
                text: "Poista",
                kind: "danger",
                onPress: async () => {
                  try {
                    await api.deleteLocation(id);
                    await loadLocations();
                    toast("success", "Ilmoitus", "Poistettu.");
                  } catch (e) {
                    toast("error", "Virhe", e?.message || "Poisto epäonnistui");
                  }
                },
              },
            ]);
          });
        });
      }

      function render() {
        if (!state.session.ok) {
          renderLogin();
          return;
        }
        renderTopbar();

        if (state.tab === "dashboard") return renderDashboard();
        if (state.tab === "worklist") return renderWorklist();
        if (state.tab === "customers") return renderCustomers();
        if (state.tab === "rows") return renderRows();
        if (state.tab === "calendar") return renderCalendar();
        if (state.tab === "settings") return renderSettings();
        return renderDashboard();
      }

      render();
    </script>
  </body>
</html>
