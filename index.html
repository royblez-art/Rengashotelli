
<!doctype html>
<html lang="fi">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="color-scheme" content="light" />
    <title>Rengashotelli</title>
    <style>
      :root {
        --bg: #edf2f7;
        --card: #ffffff;
        --text: #1f2937;
        --subtext: #4b5563;
        --border: #e2e8f0;
        --primary: #0e7afe;
        --danger: #b42336;
        --muted-bg: #f8fafc;
        --muted-border: #dbe4ee;
        --shadow: 0 10px 28px rgba(15, 23, 42, 0.08);
        --radius: 16px;
        --frame: 1024px; /* tablet landscape frame */
        --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      }
      * { box-sizing: border-box; }
      html, body { height: 100%; }
      body {
        margin: 0;
        font-family: var(--sans);
        color: var(--text);
        background: radial-gradient(1200px 700px at 20% 0%, #ffffff 0%, var(--bg) 55%, #e6eef8 100%);
        overflow-x: hidden;
      }
      .app { min-height: 100%; display: flex; flex-direction: column; }
      .topbar {
        position: sticky; top: 0; z-index: 5;
        background: rgba(237, 242, 247, 0.82);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid rgba(226, 232, 240, 0.9);
      }
      .topbar-inner {
        max-width: var(--frame); margin: 0 auto; padding: 14px 16px;
        display: flex; align-items: center; gap: 12px;
      }
      .brand { display: flex; flex-direction: column; line-height: 1.05; gap: 2px; min-width: 180px; }
      .brand .title { font-weight: 900; letter-spacing: 0.2px; }
      .brand .subtitle { font-size: 12px; color: var(--subtext); }
      .nav { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
      .nav button {
        appearance: none; cursor: pointer;
        border: 1px solid var(--muted-border);
        background: var(--muted-bg);
        color: #334155;
        padding: 9px 12px;
        border-radius: 999px;
        font-weight: 800;
        font-size: 13px;
      }
      .nav button.active {
        border-color: rgba(14, 122, 254, 0.35);
        background: rgba(14, 122, 254, 0.09);
        color: #0b4fb8;
      }
      .nav-spacer { flex: 1; }
      .session-chip {
        border: 1px solid var(--muted-border);
        background: white;
        border-radius: 999px;
        padding: 8px 10px;
        display: flex; gap: 8px; align-items: center;
        max-width: 420px;
      }
      .session-chip .hotel { font-weight: 900; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .session-chip .who { font-size: 12px; color: var(--subtext); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .container { width: 100%; max-width: var(--frame); margin: 0 auto; padding: 16px; flex: 1; }
      .card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); box-shadow: var(--shadow); }
      .card.pad { padding: 14px; }
      .row { display: flex; gap: 12px; flex-wrap: wrap; }
      .col { flex: 1; min-width: 260px; }
      .h1 { margin: 0; font-size: 22px; font-weight: 900; }
      .p { margin: 6px 0 0 0; color: var(--subtext); font-size: 14px; line-height: 1.35; }
      .field { display: flex; flex-direction: column; gap: 6px; margin: 10px 0; }
      .label { font-weight: 900; font-size: 12px; color: #334155; letter-spacing: 0.2px; }
      .label .req { color: var(--danger); }
      input, select, textarea {
        width: 100%; border: 1px solid var(--border); border-radius: 12px;
        padding: 10px 12px; font-size: 14px; background: #fff; outline: none;
      }
      textarea { min-height: 90px; resize: vertical; }
      input:focus, select:focus, textarea:focus { border-color: rgba(14, 122, 254, 0.6); box-shadow: 0 0 0 3px rgba(14, 122, 254, 0.12); }
      .btn-row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin-top: 10px; }
      .btn {
        appearance: none; cursor: pointer;
        border: 1px solid rgba(14, 122, 254, 0.35);
        background: rgba(14, 122, 254, 0.10);
        color: #0b4fb8;
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 900;
      }
      .btn.primary { border-color: rgba(14, 122, 254, 0.65); background: var(--primary); color: white; }
      .btn.ghost { border-color: var(--muted-border); background: white; color: #334155; }
      .btn.danger { border-color: rgba(180, 35, 54, 0.35); background: rgba(180, 35, 54, 0.10); color: var(--danger); }
      .btn:disabled { opacity: 0.55; cursor: not-allowed; }
      .pill {
        display: inline-flex; gap: 8px; align-items: center;
        border-radius: 999px; padding: 6px 10px;
        border: 1px solid var(--muted-border);
        background: var(--muted-bg);
        color: #334155;
        font-weight: 900; font-size: 12px; white-space: nowrap;
      }
      .pill.mono { font-family: var(--mono); font-weight: 800; }
      .list { display: flex; flex-direction: column; gap: 10px; margin-top: 10px; }
      .item {
        background: white; border: 1px solid var(--border); border-radius: 14px;
        padding: 12px; display: flex; gap: 10px; align-items: flex-start;
      }
      .item .main { flex: 1; min-width: 240px; }
      .item .title { font-weight: 900; }
      .item .meta { margin-top: 4px; color: var(--subtext); font-size: 13px; line-height: 1.3; }
      .item .actions { display: flex; gap: 8px; flex-wrap: wrap; justify-content: flex-end; }
      .divider { height: 1px; background: var(--border); margin: 12px 0; }
      .muted { color: var(--subtext); }
      .danger-text { color: var(--danger); font-weight: 900; }

      .toast-wrap { position: fixed; right: 12px; bottom: 12px; z-index: 50; display: flex; flex-direction: column; gap: 10px; width: min(420px, calc(100vw - 24px)); }
      .toast { border-radius: 14px; border: 1px solid var(--border); background: white; box-shadow: var(--shadow); padding: 12px; }
      .toast .t { font-weight: 900; }
      .toast .m { margin-top: 4px; color: var(--subtext); font-size: 13px; line-height: 1.35; }
      .toast.success { border-color: rgba(6, 78, 59, 0.22); background: rgba(212, 241, 223, 0.65); }
      .toast.error { border-color: rgba(180, 35, 54, 0.25); background: rgba(255, 227, 230, 0.75); }
      .toast.warning { border-color: rgba(154, 52, 18, 0.20); background: rgba(255, 247, 237, 0.85); }
      .toast.info { border-color: rgba(14, 122, 254, 0.20); background: rgba(14, 122, 254, 0.06); }

      .modal-backdrop { position: fixed; inset: 0; background: rgba(15, 23, 42, 0.55); z-index: 60; display: none; align-items: flex-end; justify-content: center; padding: 14px; }
      .modal-backdrop.open { display: flex; }
      .modal { width: min(720px, 100%); border-radius: 18px; background: white; border: 1px solid var(--border); box-shadow: var(--shadow); padding: 14px; }
      .modal .head { display: flex; align-items: flex-start; justify-content: space-between; gap: 10px; }
      .modal .head .ttl { font-weight: 900; font-size: 18px; }
      .modal .head .x { appearance: none; border: 1px solid var(--muted-border); background: white; border-radius: 10px; padding: 6px 10px; font-weight: 900; cursor: pointer; }
      .modal .body { margin-top: 10px; }
      .modal .msg { color: var(--subtext); line-height: 1.35; }

      .menu { position: relative; }
      .menu-pop {
        position: absolute; right: 0; top: calc(100% + 8px);
        min-width: 220px; background: white; border: 1px solid var(--border);
        border-radius: 14px; box-shadow: var(--shadow); padding: 8px;
        display: none; z-index: 20;
      }
      .menu-pop.open { display: block; }
      .menu-pop button {
        width: 100%; text-align: left; border-radius: 12px;
        border: 1px solid transparent; background: transparent;
        padding: 10px 10px; font-weight: 900; cursor: pointer;
        color: #0f172a;
      }
      .menu-pop button:hover { background: var(--muted-bg); border-color: var(--muted-border); }
      .menu-pop button.danger { color: var(--danger); }

      .cal-days { display: grid; gap: 10px; grid-template-columns: repeat(var(--days, 1), minmax(0, 1fr)); }
      .cal-day-card { min-width: 0; }

      .slot-row { display: flex; gap: 8px; padding: 6px 8px; align-items: flex-start; }
      .slot-time { min-width: var(--slot-time-w, 92px); font-size: 11px; font-weight: 800; color: #4b5563; padding-top: 2px; }
      .slot-tiles { flex: 1; display: flex; gap: 6px; }
      .slot-tile {
        flex: 1;
        min-height: 42px;
        padding: 6px 6px;
        border-left: 3px solid #cbd5e1;
        border-radius: 8px;
        font-size: 11px;
        font-weight: 800;
        color: #0f172a;
        white-space: pre-line;
        overflow-wrap: anywhere;
        word-break: break-word;
        cursor: pointer;
        user-select: none;
      }
      .slot-tile.dim { cursor: default; }

      @media (max-width: 860px) {
        .brand { min-width: 0; }
        .session-chip { display: none; }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <div class="topbar">
        <div class="topbar-inner">
          <div class="brand">
            <div class="title">Rengashotelli</div>
            <div class="subtitle" id="brandSub">Web</div>
          </div>
          <div class="nav" id="nav" style="display:none">
            <button data-tab="dashboard">Etusivu</button>
            <button data-tab="worklist">Työlista</button>
            <button data-tab="customers">Asiakkaat</button>
            <button data-tab="rows">Rivit</button>
            <button data-tab="calendar">Kalenteri</button>
            <button data-tab="settings">Asetukset</button>
          </div>
          <div class="nav-spacer"></div>
          <div class="session-chip" id="sessionChip" style="display:none">
            <div class="hotel" id="chipHotel">—</div>
            <div class="who" id="chipWho">—</div>
          </div>
        </div>
      </div>
      <div class="container" id="root"></div>
    </div>

    <div class="toast-wrap" id="toasts"></div>

    <div class="modal-backdrop" id="modalBackdrop" aria-hidden="true">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
        <div class="head">
          <div class="ttl" id="modalTitle"></div>
          <button class="x" id="modalCloseBtn">Sulje</button>
        </div>
        <div class="body" id="modalBody"></div>
      </div>
    </div>

    <script>
      // ==========================================================
      // Config (copied from App.js)
      // ==========================================================
      const SUPABASE_URL = "https://xbxmysfxbkcrjsxjtzkz.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_8e1s0Fj93ydy900tLpAwHQ_BAfVDGUq";

      // ==========================================================
      // Helpers
      // ==========================================================
      const $ = (sel, root = document) => root.querySelector(sel);
      const $$ = (sel, root = document) => Array.from(root.querySelectorAll(sel));
      const clamp = (n, a, b) => Math.max(a, Math.min(b, n));

      function escapeHtml(s) {
        return String(s || "")
          .replaceAll("&", "&amp;")
          .replaceAll("<", "&lt;")
          .replaceAll(">", "&gt;")
          .replaceAll('"', "&quot;")
          .replaceAll("'", "&#039;");
      }

      function normalizeRole(role) {
        return String(role || "").trim().toLowerCase();
      }
      function isAdminRole(role) {
        return normalizeRole(role) === "admin";
      }

      function appNowMs() {
        return Date.now();
      }
      function todayStrLocal() {
        const d = new Date(appNowMs());
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      }
      function addDaysIso(isoDate, days) {
        const d = new Date(`${isoDate}T00:00:00Z`);
        d.setUTCDate(d.getUTCDate() + days);
        return d.toISOString().slice(0, 10);
      }
      function formatDateOnlyFinnish(isoDate, fallback = "—") {
        const raw = String(isoDate || "").trim();
        if (!raw) return fallback;
        const d10 = raw.slice(0, 10);
        if (/^\d{4}-\d{2}-\d{2}$/.test(d10)) {
          const [y, m, d] = d10.split("-");
          return `${d}.${m}.${y}`;
        }
        const d = new Date(raw);
        if (!Number.isFinite(d.getTime())) return fallback;
        const dd = String(d.getDate()).padStart(2, "0");
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const yy = String(d.getFullYear());
        return `${dd}.${mm}.${yy}`;
      }
      function getMondayIso(isoDate) {
        const d = new Date(`${isoDate}T00:00:00Z`);
        const day = d.getUTCDay(); // 0=su,1=ma
        const delta = day === 0 ? -6 : 1 - day;
        d.setUTCDate(d.getUTCDate() + delta);
        return d.toISOString().slice(0, 10);
      }
      function isoDateLocal(date) {
        const d = date instanceof Date ? date : new Date(date);
        if (!Number.isFinite(d.getTime())) return "";
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, "0");
        const day = String(d.getDate()).padStart(2, "0");
        return `${y}-${m}-${day}`;
      }
      function getIsoWeekNumber(isoMonday) {
        // isoMonday: YYYY-MM-DD (Monday of week)
        const d = new Date(`${String(isoMonday || "").slice(0, 10)}T00:00:00Z`);
        if (!Number.isFinite(d.getTime())) return 0;
        // Thursday in current week decides week year.
        d.setUTCDate(d.getUTCDate() + 3);
        const firstThursday = new Date(Date.UTC(d.getUTCFullYear(), 0, 4));
        const diffDays = Math.round((d.getTime() - firstThursday.getTime()) / 86400000);
        return 1 + Math.floor(diffDays / 7);
      }
      function formatDateShort(isoDate, fallback = "—") {
        const raw = String(isoDate || "").trim();
        if (!raw) return fallback;
        const d10 = raw.slice(0, 10);
        if (/^\d{4}-\d{2}-\d{2}$/.test(d10)) {
          const [y, m, d] = d10.split("-");
          return `${d}.${m}`;
        }
        return formatDateOnlyFinnish(raw, fallback);
      }
      function parseTimeToMinutes(hhmm) {
        const s = String(hhmm || "").trim();
        const m = s.match(/^(\d{1,2}):(\d{2})$/);
        if (!m) return null;
        const hh = parseInt(m[1], 10);
        const mm = parseInt(m[2], 10);
        if (!Number.isFinite(hh) || !Number.isFinite(mm)) return null;
        if (hh < 0 || hh > 23 || mm < 0 || mm > 59) return null;
        return hh * 60 + mm;
      }
      function normalizeTimeHHMM(value, fallback = "") {
        const s = String(value || "").trim();
        const mins = parseTimeToMinutes(s);
        if (mins === null) return fallback;
        const hh = String(Math.floor(mins / 60)).padStart(2, "0");
        const mm = String(mins % 60).padStart(2, "0");
        return `${hh}:${mm}`;
      }
      function minutesToHHMM(mins) {
        const m = Math.max(0, Math.min(23 * 60 + 59, parseInt(mins, 10) || 0));
        const hh = String(Math.floor(m / 60)).padStart(2, "0");
        const mm = String(m % 60).padStart(2, "0");
        return `${hh}:${mm}`;
      }
      function overlapsMs(aStart, aEnd, bStart, bEnd) {
        return aStart < bEnd && bStart < aEnd;
      }
      function prettyPlate(v) {
        return v ? String(v).toUpperCase() : "—";
      }
      function normalizePlate(v) {
        return String(v || "").toUpperCase().replace(/[\s-]/g, "");
      }
      function prettyLocation(v) {
        const s = String(v || "").trim();
        return s || "—";
      }
      function isSeasonPaid(v) {
        if (v === true) return true;
        if (v === false || v === null || v === undefined) return false;
        const s = String(v).trim().toLowerCase();
        return ["true", "t", "1", "yes", "kyllä", "paid", "maksettu"].includes(s);
      }
      function getStatusMeta(statusValue, opts = {}) {
        const raw = String(statusValue || "").trim();
        const lower = raw.toLowerCase();
        const isWaiting = opts?.isWaiting === true || lower === "odottaa noutoa";
        const isWorking = opts?.isWorking === true || lower === "työn alla";
        const isDelivered = lower === "luovutettu";
        const isStored = lower === "varastossa";
        const isDeleted = lower === "poistettu";
        const label = isWorking ? "Työn alla" : isWaiting ? "Odottaa noutoa" : (raw || "—");
        if (isWorking) return { label, bg: "#eaf7ef", border: "#c8e6d3", color: "#1f6f4a" };
        if (isWaiting) return { label, bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
        if (isDelivered) return { label, bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" };
        if (isStored) return { label, bg: "#d4f1df", border: "#7fc59b", color: "#064e3b" };
        if (isDeleted) return { label, bg: "#ffe3e6", border: "#f2a3ad", color: "#8a1023" };
        return { label, bg: "#f1f5f9", border: "#dbe4ee", color: "#334155" };
      }
      function formatActor(name, role) {
        const n = String(name || "").trim();
        const r = String(role || "").trim();
        if (n && r) return `${n} (${r})`;
        if (n) return n;
        if (r) return r;
        return "—";
      }

      const STAFF_APPROVAL_TAG = "[ODOTTAA ADMIN-HYVAKSYNTAA]";
      function ensureAdminApprovalTag(notes) {
        const txt = String(notes || "").trim();
        if (txt.toUpperCase().includes(STAFF_APPROVAL_TAG)) return txt;
        if (!txt) return STAFF_APPROVAL_TAG;
        return `${STAFF_APPROVAL_TAG}\n${txt}`;
      }
      function hasStaffApprovalTag(value) {
        return String(value || "").toUpperCase().includes(STAFF_APPROVAL_TAG);
      }
      function stripStaffApprovalTag(notes) {
        const lines = String(notes || "").split(/\r?\n/);
        const filtered = lines.filter((line) => String(line || "").trim().toUpperCase() !== STAFF_APPROVAL_TAG);
        const out = filtered.join("\n").trim();
        return out || null;
      }
      function normalizeNameKey(value) {
        return String(value || "").trim().toLowerCase();
      }
      function isPendingRowApproval(row) {
        if (!row || row.deleted) return false;
        if (hasStaffApprovalTag(row?.notes)) return true;
        const createdRole = normalizeRole(row?.created_by_role);
        const updatedRole = normalizeRole(row?.updated_by_role);
        return createdRole === "staff" && updatedRole !== "admin";
      }
      function isPendingCustomerApproval(customer) {
        if (!customer || customer.poistettu === true) return false;
        const createdRole = normalizeRole(customer?.created_by_role || customer?.luonut_rooli);
        const updatedRole = normalizeRole(customer?.updated_by_role || customer?.paivittanyt_rooli);
        return createdRole === "staff" && updatedRole !== "admin";
      }
      function formatPlateDuplicateMessage(plate, duplicateRow) {
        const plateTxt = prettyPlate(plate);
        const owner = String(duplicateRow?.customer || "").trim() || "tuntematon asiakas";
        const location = prettyLocation(duplicateRow?.location);
        const whereTxt = location ? ` (${location})` : "";
        return `Rekisteri ${plateTxt} on jo kirjattu asiakkaalle ${owner}${whereTxt}.`;
      }

      // ==========================================================
      // Toasts (in-app notifications)
      // ==========================================================
      const toastRoot = $("#toasts");
      let toastId = 1;
      function toast(variant, title, message, ms = 3500) {
        const id = toastId++;
        const el = document.createElement("div");
        el.className = `toast ${variant || "info"}`;
        el.innerHTML = `<div class="t"></div><div class="m"></div>`;
        el.querySelector(".t").textContent = String(title || "Ilmoitus");
        el.querySelector(".m").textContent = String(message || "");
        toastRoot.appendChild(el);
        const t = setTimeout(() => {
          el.remove();
          clearTimeout(t);
        }, ms);
        return id;
      }

      // ==========================================================
      // Modal
      // ==========================================================
      const modalBackdrop = $("#modalBackdrop");
      const modalTitle = $("#modalTitle");
      const modalBody = $("#modalBody");
      const modalCloseBtn = $("#modalCloseBtn");
      let modalOnClose = null;

      function closeModal() {
        modalBackdrop.classList.remove("open");
        modalBackdrop.setAttribute("aria-hidden", "true");
        modalTitle.textContent = "";
        modalBody.innerHTML = "";
        const cb = modalOnClose;
        modalOnClose = null;
        if (typeof cb === "function") cb();
      }
      modalCloseBtn.addEventListener("click", closeModal);
      modalBackdrop.addEventListener("click", (e) => {
        if (e.target === modalBackdrop) closeModal();
      });
      window.addEventListener("keydown", (e) => {
        if (e.key === "Escape" && modalBackdrop.classList.contains("open")) closeModal();
      });

      function openModal(title, html, { onClose } = {}) {
        modalOnClose = typeof onClose === "function" ? onClose : null;
        modalTitle.textContent = String(title || "");
        modalBody.innerHTML = html || "";
        modalBackdrop.classList.add("open");
        modalBackdrop.setAttribute("aria-hidden", "false");
      }

      function modalConfirm(title, message, buttons) {
        const btns = Array.isArray(buttons) && buttons.length ? buttons : [{ text: "OK" }];
        const html = `
          <div class="msg">${escapeHtml(String(message || ""))}</div>
          <div class="btn-row" style="justify-content:flex-end; margin-top: 12px;">
            ${btns.map((b, idx) => {
              const kind = String(b?.kind || "");
              const cls = kind === "danger" ? "btn danger" : (kind === "primary" ? "btn primary" : "btn ghost");
              return `<button class="${cls}" data-modal-btn="${idx}">${escapeHtml(String(b?.text || "OK"))}</button>`;
            }).join("")}
          </div>
        `;
        openModal(title || "Vahvista", html);
        $$('[data-modal-btn]', modalBody).forEach((btn) => {
          btn.addEventListener('click', () => {
            const idx = parseInt(btn.getAttribute('data-modal-btn'), 10);
            const b = btns[idx] || null;
            closeModal();
            if (b && typeof b.onPress === 'function') b.onPress();
          });
        });
      }

      function modalPromptPin({ title, message, prefill = "" }) {
        return new Promise((resolve) => {
          const html = `
            <div class="msg">${escapeHtml(String(message || "Syötä PIN."))}</div>
            <div class="field" style="margin-top: 10px;">
              <div class="label">PIN</div>
              <input id="pinPromptInput" type="password" autocomplete="one-time-code" />
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="pinPromptCancel">Peruuta</button>
              <button class="btn primary" id="pinPromptOk">OK</button>
            </div>
          `;
          openModal(title || "PIN", html, { onClose: () => resolve("") });
          const input = $("#pinPromptInput", modalBody);
          input.value = String(prefill || "");
          setTimeout(() => input.focus(), 0);
          $("#pinPromptCancel", modalBody).addEventListener("click", () => {
            closeModal();
            resolve("");
          });
          $("#pinPromptOk", modalBody).addEventListener("click", () => {
            const v = String(input.value || "").trim();
            closeModal();
            resolve(v);
          });
          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              const v = String(input.value || "").trim();
              closeModal();
              resolve(v);
            }
          });
        });
      }
      // ==========================================================
      // API
      // ==========================================================
      function makeApi(options = {}) {
        const base = `${SUPABASE_URL}/rest/v1`;
        const getSessionPin = typeof options?.getSessionPin === "function" ? options.getSessionPin : () => "";
        const getSessionIdentity = typeof options?.getSessionIdentity === "function" ? options.getSessionIdentity : () => ({ username: "", role: "", pinSource: "" });

        function resolvePin(pin) {
          const direct = String(pin || "").trim();
          return direct || String(getSessionPin() || "").trim();
        }

        async function request(path, { method = "GET", body, preferReturn = false } = {}) {
          const url = `${base}${path}`;
          const res = await fetch(url, {
            method,
            headers: {
              apikey: SUPABASE_ANON_KEY,
              "Content-Type": "application/json",
              Accept: "application/json",
              ...(preferReturn ? { Prefer: "return=representation" } : {}),
            },
            body: body ? JSON.stringify(body) : undefined,
          });
          const text = await res.text();
          let data = null;
          try { data = text ? JSON.parse(text) : null; } catch { data = text; }
          if (!res.ok) {
            const msg = data?.message || data?.error_description || text || "Supabase error";
            throw new Error(msg);
          }
          return data;
        }

        const normalizeRpcObject = (res) => (Array.isArray(res) ? (res[0] || {}) : (res || {}));
        const normalizeRoleValue = (value) => {
          const v = String(value || "").trim().toLowerCase();
          return v === "admin" ? "admin" : (v === "staff" ? "staff" : "");
        };
        const parseRpcBoolean = (res, key) => {
          if (typeof res === "boolean") return res;
          if (typeof res === "string") {
            const txt = res.trim().toLowerCase();
            if (txt === "true" || txt === "t" || txt === "1") return true;
            if (txt === "false" || txt === "f" || txt === "0") return false;
          }
          if (Array.isArray(res)) {
            if (typeof res[0] === "boolean") return res[0];
            if (res[0] && typeof res[0] === "object" && key in res[0]) return !!res[0][key];
          }
          if (res && typeof res === "object" && key in res) return !!res[key];
          return null;
        };

        async function callBoolRpc(fnName, keyName, code, pin) {
          const bodies = [{ p_hotel_code: code, p_pin: pin }, { hotel_code: code, pin }];
          let missing = false;
          for (const body of bodies) {
            try {
              const out = await request(`/rpc/${fnName}`, { method: "POST", body });
              const parsed = parseRpcBoolean(out, keyName);
              if (typeof parsed === "boolean") return { ok: true, value: parsed };
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes(`Could not find the function public.${fnName}`)) { missing = true; continue; }
              throw e;
            }
          }
          return missing ? { ok: false, reason: "missing_function" } : { ok: false, reason: "invalid_response" };
        }

        async function fetchPinIdentity(code, pin) {
          const variants = [{ p_hotel_code: code, p_pin: pin }, { hotel_code: code, pin }];
          for (const body of variants) {
            try { return normalizeRpcObject(await request(`/rpc/get_pin_identity`, { method: "POST", body })); }
            catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.get_pin_identity")) continue;
              throw e;
            }
          }
          return null;
        }

        async function safeHotelDisplayName(code) {
          try {
            const rows = await request(`/hotels?hotel_code=eq.${encodeURIComponent(code)}&select=display_name,hotel_name,nimi,name,title&limit=1`);
            const row = rows?.[0];
            if (!row || typeof row !== "object") return "";
            const candidates = [row.display_name, row.hotel_name, row.nimi, row.name, row.title];
            for (const value of candidates) if (typeof value === "string" && value.trim()) return value.trim();
            return "";
          } catch { return ""; }
        }

        async function enrichVerifiedIdentity(base, code, pin) {
          const out = (base && typeof base === "object") ? { ...base } : {};
          out.ok = true;
          out.hotel_code = String(out?.hotel_code || code || "").trim() || code;
          if (!String(out?.display_name || "").trim()) {
            const displayName = await safeHotelDisplayName(code);
            out.display_name = displayName || out.hotel_code;
          }

          const currentRole = normalizeRoleValue(out?.role);
          const currentSource = String(out?.source || "").trim().toLowerCase();
          const currentUsername = out?.username ?? null;

          if (!currentRole || !currentSource || currentUsername === null || currentUsername === "") {
            const ident = await fetchPinIdentity(code, pin);
            if (ident && ident.ok === true) {
              const identRole = normalizeRoleValue(ident?.role);
              if (!currentRole && identRole) out.role = identRole;
              if (!currentSource && String(ident?.source || "").trim()) out.source = String(ident.source).trim();
              if ((currentUsername === null || currentUsername === "") && ident?.username !== undefined) out.username = ident.username;
            } else if (ident && ident.ok === false) {
              return { ok: false, reason: String(ident?.reason || "wrong_pin") };
            }
          }

          let finalRole = normalizeRoleValue(out?.role);
          if (!finalRole) {
            const adminGate = await callBoolRpc("check_hotel_admin_pin", "check_hotel_admin_pin", code, pin);
            if (adminGate.ok && adminGate.value === true) {
              finalRole = "admin";
              if (!String(out?.source || "").trim()) out.source = "master";
            } else {
              finalRole = "staff";
            }
          }
          out.role = finalRole;
          if (!String(out?.source || "").trim()) out.source = finalRole === "admin" ? "master" : "user";
          if (out.username === undefined) out.username = null;
          return out;
        }

        async function verifyHotelWithPin(hotelCode, pin) {
          const code = String(hotelCode || "").trim();
          const p = String(pin || "").trim();
          if (!code) return { ok: false, reason: "missing_hotel_code" };
          if (!p) return { ok: false, reason: "missing_pin" };

          try {
            const verifyBodies = [{ p_hotel_code: code, p_pin: p }, { hotel_code: code, pin: p }];
            let verifyMissingFn = false;
            let lastVerifyOut = null;
            for (const body of verifyBodies) {
              try {
                const res = await request(`/rpc/verify_hotel_with_pin`, { method: "POST", body });
                const out = normalizeRpcObject(res);
                if (!out || typeof out !== "object") { lastVerifyOut = { ok: false, reason: "invalid_response" }; continue; }
                if (out?.ok !== true) { lastVerifyOut = out; continue; }
                return await enrichVerifiedIdentity(out, code, p);
              } catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.verify_hotel_with_pin")) { verifyMissingFn = true; continue; }
                throw e;
              }
            }
            if (lastVerifyOut && lastVerifyOut.ok !== true) {
              const ident = await fetchPinIdentity(code, p);
              if (ident && ident.ok === true) return await enrichVerifiedIdentity(ident, code, p);
              return lastVerifyOut;
            }
            if (!verifyMissingFn) return { ok: false, reason: "invalid_response" };
            throw new Error("Could not find the function public.verify_hotel_with_pin");
          } catch (e) {
            const msg = String(e?.message || "");
            if (!msg.includes("Could not find the function public.verify_hotel_with_pin")) throw e;

            const ident = await fetchPinIdentity(code, p);
            if (ident && ident.ok === true) return await enrichVerifiedIdentity(ident, code, p);
            if (ident && ident.ok === false) return { ok: false, reason: String(ident?.reason || "wrong_pin") };

            const adminGate = await callBoolRpc("check_hotel_admin_pin", "check_hotel_admin_pin", code, p);
            if (adminGate.ok && adminGate.value === true) {
              return await enrichVerifiedIdentity({ ok: true, hotel_code: code, role: "admin", username: null, source: "master" }, code, p);
            }
            if (adminGate.ok && adminGate.value === false) return { ok: false, reason: "wrong_pin" };

            const masterGate = await callBoolRpc("check_hotel_pin", "check_hotel_pin", code, p);
            if (masterGate.ok && masterGate.value === true) {
              return await enrichVerifiedIdentity({ ok: true, hotel_code: code, role: "admin", username: null, source: "master" }, code, p);
            }
            if (masterGate.ok && masterGate.value === false) return { ok: false, reason: "wrong_pin" };

            return { ok: false, reason: "missing_function", message: "Backendistä puuttuu verify_hotel_with_pin (ja fallbackit)." };
          }
        }

        function getActorIdentity() {
          const raw = getSessionIdentity() || {};
          const pinSource = String(raw?.pinSource || "").trim().toLowerCase();
          const username = String(raw?.username || "").trim();
          const role = normalizeRole(raw?.role) || null;
          const actorUsername = username || (pinSource === "master" ? "master" : "");
          return { username: actorUsername || null, role };
        }

        function actorFieldsForInsert() {
          const actor = getActorIdentity();
          const out = {};
          if (actor.username) { out.created_by_name = actor.username; out.updated_by_name = actor.username; }
          if (actor.role) { out.created_by_role = actor.role; out.updated_by_role = actor.role; }
          return out;
        }

        function actorFieldsForUpdate() {
          const actor = getActorIdentity();
          const out = {};
          if (actor.username) out.updated_by_name = actor.username;
          if (actor.role) out.updated_by_role = actor.role;
          return out;
        }

        function deliveredFieldsForPatch(patch = {}) {
          if (!patch || typeof patch !== "object") return {};
          const hasOwn = (key) => Object.prototype.hasOwnProperty.call(patch, key);
          const statusLower = String(patch?.status || "").trim().toLowerCase();
          const hasOutDate = hasOwn("out_date");
          const outDate = patch?.out_date;
          const marksDelivered = statusLower === "luovutettu" || (hasOutDate && outDate !== null && String(outDate || "").trim() !== "");
          const clearsDelivered = hasOutDate && (outDate === null || String(outDate || "").trim() === "");
          if (!marksDelivered && !clearsDelivered) return {};
          if (clearsDelivered) return { delivered_by_name: null, delivered_by_role: null };
          const actor = getActorIdentity();
          return { delivered_by_name: actor.username || null, delivered_by_role: actor.role || null };
        }

        function isActorColumnMissingError(message) {
          const msg = String(message || "");
          return (
            msg.includes("created_by_name") || msg.includes("created_by_role") ||
            msg.includes("updated_by_name") || msg.includes("updated_by_role") ||
            msg.includes("delivered_by_name") || msg.includes("delivered_by_role")
          );
        }

        const mapFromDb = (row) => ({
          id: row.id,
          hotel_code: row.hotel_code,
          customer: row.nimi ?? row.customer,
          phone: row.puhelin ?? row.phone,
          plate: row.rekisteri ?? row.plate,
          tire_size: row.sahkoposti ?? row.tire_size,
          location: row.hyllypaikka ?? row.location,
          last_location: row.last_hyllypaikka ?? row.last_location,
          pickup_date: row.nouto_paiva ?? row.pickup_date,
          status: row.tila ?? row.status,
          notes: row.huomiot ?? row.notes,
          season_fee_paid: row.season_fee_paid,
          deleted: row.poistettu ?? row.deleted,
          rev: row.versio ?? row.rev,
          updated_at: row.paivitetty ?? row.updated_at,
          created_at: row.luotu ?? row.created_at,
          created_by_name: row.luonut_nimi ?? row.created_by_name ?? row.created_by_username ?? row.created_by ?? row.creator_name ?? row.creator ?? null,
          created_by_role: row.luonut_rooli ?? row.created_by_role ?? row.creator_role ?? null,
          updated_by_name: row.paivittanyt_nimi ?? row.updated_by_name ?? row.updated_by_username ?? row.updated_by ?? row.last_modified_by ?? row.editor_name ?? row.editor ?? null,
          updated_by_role: row.paivittanyt_rooli ?? row.updated_by_role ?? row.editor_role ?? null,
          delivered_by_name: row.luovuttanut_nimi ?? row.delivered_by_name ?? row.out_by_name ?? null,
          delivered_by_role: row.luovuttanut_rooli ?? row.delivered_by_role ?? row.out_by_role ?? null,
          out_date: row.ulos_pvm ?? row.out_date,
          in_date: row.sisaan_pvm ?? row.in_date,
          waiting_pickup: row.odottaa_noutoa ?? row.waiting_pickup ?? ((row.tila || row.status || "").toLowerCase() === "odottaa noutoa"),
          working: row.tyon_alla ?? row.working ?? ((row.tila || row.status || "").toLowerCase() === "työn alla"),
        });

        const mapToDb = (payload) => ({
          nimi: payload.customer ?? null,
          puhelin: payload.phone ?? null,
          rekisteri: payload.plate ?? null,
          sahkoposti: payload.email ?? payload.tire_size ?? null,
          hyllypaikka: payload.location ?? null,
          last_hyllypaikka: payload.last_location ?? null,
          nouto_paiva: payload.pickup_date ?? null,
          tila: payload.status ?? null,
          huomiot: payload.notes ?? null,
          season_fee_paid: payload.season_fee_paid ?? false,
          poistettu: payload.deleted ?? false,
          versio: payload.rev,
          ulos_pvm: payload.out_date ?? null,
          sisaan_pvm: payload.in_date ?? null,
        });

        const mapPatchToDb = (payload = {}) => {
          const out = {};
          if (payload.customer !== undefined) out.nimi = payload.customer;
          if (payload.phone !== undefined) out.puhelin = payload.phone;
          if (payload.plate !== undefined) out.rekisteri = payload.plate;
          if (payload.tire_size !== undefined) out.sahkoposti = payload.tire_size;
          if (payload.email !== undefined) out.sahkoposti = payload.email;
          if (payload.location !== undefined) out.hyllypaikka = payload.location;
          if (payload.last_location !== undefined) out.last_hyllypaikka = payload.last_location;
          if (payload.pickup_date !== undefined) out.nouto_paiva = payload.pickup_date;
          if (payload.status !== undefined) out.tila = payload.status;
          if (payload.notes !== undefined) out.huomiot = payload.notes;
          if (payload.season_fee_paid !== undefined) out.season_fee_paid = !!payload.season_fee_paid;
          if (payload.deleted !== undefined) out.poistettu = payload.deleted === true;
          if (payload.out_date !== undefined) out.ulos_pvm = payload.out_date;
          if (payload.in_date !== undefined) out.sisaan_pvm = payload.in_date;
          if (payload.waiting_pickup !== undefined) out.odottaa_noutoa = payload.waiting_pickup;
          if (payload.working !== undefined) out.tyon_alla = payload.working;
          return out;
        };

        let tireActorColumnsSupported = null;
        let customerActorColumnsSupported = null;

        return {
          request,
          verifyHotelWithPin,
          getHotelMasterName: async (hotelCode) => {
            const code = String(hotelCode || "").trim();
            if (!code) return null;
            try {
              const rows = await request(`/hotels?hotel_code=eq.${encodeURIComponent(code)}&select=master_name&limit=1`);
              const value = rows?.[0]?.master_name;
              if (typeof value === "string" && value.trim()) return value.trim();
              return null;
            } catch { return null; }
          },

          listTires: (hotelCode) => request(`/tires?hotel_code=eq.${encodeURIComponent(hotelCode)}&poistettu=eq.false&order=paivitetty.desc&limit=200`).then((rows) => (rows || []).map(mapFromDb)),

          listCustomers: (hotelCode) => request(`/customers?hotel_code=eq.${encodeURIComponent(hotelCode)}&poistettu=eq.false&order=paivitetty.desc&limit=500`),

          getCustomerByName: (hotelCode, name) => request(`/customers?hotel_code=eq.${encodeURIComponent(hotelCode)}&nimi=eq.${encodeURIComponent(name)}&poistettu=eq.false&limit=1`).then((rows) => (rows && rows[0] ? rows[0] : null)),

          findActiveTireByPlate: async (hotelCode, plate, excludeId = null) => {
            const code = String(hotelCode || "").trim();
            const wanted = normalizePlate(plate);
            if (!code || !wanted) return null;
            const rows = await request(`/tires?hotel_code=eq.${encodeURIComponent(code)}&poistettu=eq.false&select=*&limit=5000`);
            const mapped = (rows || []).map(mapFromDb);
            return mapped.find((r) => {
              if (!r?.id) return false;
              if (excludeId != null && String(r.id) === String(excludeId)) return false;
              return normalizePlate(r.plate) === wanted;
            }) || null;
          },

          addCustomer: async (hotelCode, payload) => {
            const actorFields = customerActorColumnsSupported === false ? {} : actorFieldsForInsert();
            try {
              return await request(`/customers`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, ...payload, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                customerActorColumnsSupported = false;
                return request(`/customers`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, ...payload } });
              }
              throw e;
            }
          },

          updateCustomer: async (id, patch) => {
            const actorFields = customerActorColumnsSupported === false ? {} : actorFieldsForUpdate();
            try {
              return await request(`/customers?id=eq.${id}`, { method: "PATCH", preferReturn: true, body: { ...patch, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                customerActorColumnsSupported = false;
                return request(`/customers?id=eq.${id}`, { method: "PATCH", preferReturn: true, body: patch });
              }
              throw e;
            }
          },

          addTire: async (hotelCode, payload) => {
            const normalizedPayload = { ...payload, in_date: payload?.in_date || todayStrLocal() };
            const actorFields = tireActorColumnsSupported === false ? {} : actorFieldsForInsert();
            let rows;
            try {
              rows = await request(`/tires`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, versio: 1, ...mapToDb(normalizedPayload), season_fee_paid: !!normalizedPayload.season_fee_paid, ...actorFields } });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                tireActorColumnsSupported = false;
                rows = await request(`/tires`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, poistettu: false, versio: 1, ...mapToDb(normalizedPayload), season_fee_paid: !!normalizedPayload.season_fee_paid } });
              } else {
                throw e;
              }
            }
            return rows?.[0] ? mapFromDb(rows[0]) : null;
          },

          updateTire: async (id, expectedRev, patch) => {
            const useActorCols = tireActorColumnsSupported !== false;
            const actorFields = useActorCols ? actorFieldsForUpdate() : {};
            const deliveredFields = useActorCols ? deliveredFieldsForPatch(patch) : {};
            const bodyWithActor = { ...mapPatchToDb(patch), ...deliveredFields, ...actorFields, versio: expectedRev + 1 };
            let rows;
            try {
              rows = await request(`/tires?id=eq.${id}&versio=eq.${expectedRev}`, { method: "PATCH", preferReturn: true, body: bodyWithActor });
            } catch (e) {
              const actorAttempted = Object.keys(actorFields).length > 0 || Object.keys(deliveredFields).length > 0;
              if (actorAttempted && isActorColumnMissingError(e?.message)) {
                tireActorColumnsSupported = false;
                rows = await request(`/tires?id=eq.${id}&versio=eq.${expectedRev}`, { method: "PATCH", preferReturn: true, body: { ...mapPatchToDb(patch), versio: expectedRev + 1 } });
              } else {
                throw e;
              }
            }
            if (!rows || rows.length === 0) throw new Error("Konflikti: joku ehti muokata tätä riviä. Päivitä lista ja yritä uudelleen.");
            return mapFromDb(rows[0]);
          },

          deleteTireWithPin: async (tireId, hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { tire_id: String(tireId ?? ""), hotel_code: hotelCode, pin: resolvedPin },
              { p_tire_id: String(tireId ?? ""), p_hotel_code: hotelCode, p_pin: resolvedPin },
            ];
            let lastErr = null;
            let out = null;
            for (let i = 0; i < variants.length; i += 1) {
              try {
                const res = await request(`/rpc/soft_delete_tire_with_pin`, { method: "POST", body: variants[i] });
                out = normalizeRpcObject(res);
                break;
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                throw e;
              }
            }
            if (out == null && lastErr) throw lastErr;
            if (out === true || out?.ok === true || out === "true") return true;
            const reason = out?.reason;
            if (reason === "wrong_pin") throw new Error("Väärä PIN.");
            if (reason === "no_rows_matched" || reason === "not_found") throw new Error("Riviä ei löytynyt tai jo poistettu.");
            throw new Error(reason || "Poisto epäonnistui.");
          },

          hardDeleteTireWithPin: async (tireId, hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { tire_id: String(tireId ?? ""), hotel_code: hotelCode, pin: resolvedPin },
              { p_tire_id: String(tireId ?? ""), p_hotel_code: hotelCode, p_pin: resolvedPin },
            ];
            let lastErr = null;
            let out = null;
            for (let i = 0; i < variants.length; i += 1) {
              try {
                const res = await request(`/rpc/hard_delete_tire_with_pin`, { method: "POST", body: variants[i] });
                out = normalizeRpcObject(res);
                break;
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                throw e;
              }
            }
            if (out == null && lastErr) throw lastErr;
            if (out === true || out?.ok === true || out?.deleted === true) return true;
            const reason = out?.reason;
            if (reason === "wrong_pin") throw new Error("Väärä PIN.");
            if (reason === "not_found") throw new Error("Riviä ei löytynyt.");
            throw new Error(reason || "Pysyvä poisto epäonnistui.");
          },

          customerSoftDeleteCascadeWithPin: async (hotelCode, pin, customerId) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { hotel_code: hotelCode, pin: resolvedPin, customer_id: String(customerId ?? "") },
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_customer_id: String(customerId ?? "") },
            ];
            let lastErr = null;
            for (let i = 0; i < variants.length; i += 1) {
              try {
                const res = await request(`/rpc/customer_soft_delete_cascade_with_pin`, { method: "POST", body: variants[i] });
                return normalizeRpcObject(res);
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                throw e;
              }
            }
            throw lastErr || new Error("customer_soft_delete_cascade_with_pin epäonnistui.");
          },

          customerHardDeleteCascadeWithPin: async (hotelCode, pin, customerId) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { hotel_code: hotelCode, pin: resolvedPin, customer_id: String(customerId ?? "") },
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_customer_id: String(customerId ?? "") },
            ];
            let lastErr = null;
            for (let i = 0; i < variants.length; i += 1) {
              try {
                const res = await request(`/rpc/customer_hard_delete_cascade_with_pin`, { method: "POST", body: variants[i] });
                return normalizeRpcObject(res);
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                throw e;
              }
            }
            throw lastErr || new Error("customer_hard_delete_cascade_with_pin epäonnistui.");
          },

          listLocationsAdmin: (hotelCode) => request(`/locations?hotel_code=eq.${encodeURIComponent(hotelCode)}&select=id,code,label,shelf,row_letter,spot&order=shelf&order=row_letter&order=spot`),

          listFreeLocations: (hotelCode) => request(`/locations_free?hotel_code=eq.${encodeURIComponent(hotelCode)}&order=code.asc`),

          isLocationTaken: async (hotelCode, locationCode, excludeTireId = null) => {
            const code = String(hotelCode || "").trim();
            const loc = String(locationCode || "").trim();
            if (!code || !loc) return false;
            const rows = await request(`/tires?hotel_code=eq.${encodeURIComponent(code)}&poistettu=eq.false&hyllypaikka=eq.${encodeURIComponent(loc)}&select=id,rekisteri,nimi,tila&limit=20`).catch(() => []);
            const mapped = (rows || []).map(mapFromDb);
            const occupied = mapped.filter((r) => {
              if (!r?.id) return false;
              if (excludeTireId != null && String(r.id) === String(excludeTireId)) return false;
              return String(r.location || "").trim() === loc;
            });
            return occupied.length > 0;
          },

          addLocation: (hotelCode, shelf, row_letter, spot) => request(`/locations`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, shelf, row_letter, spot, code: `H${String(shelf).padStart(2, "0")}-${row_letter}-${String(spot).padStart(2, "0")}`, label: `Hylly ${String(shelf).padStart(2, "0")} / ${row_letter} / ${String(spot).padStart(2, "0")}` } }),

          deleteLocation: (id) => request(`/locations?id=eq.${id}`, { method: "DELETE" }),

          listHotelUsersWithPin: async (hotelCode, pin) => {
            const resolvedPin = resolvePin(pin);
            const variants = [{ p_hotel_code: hotelCode, p_pin: resolvedPin }, { hotel_code: hotelCode, pin: resolvedPin }];
            for (const body of variants) {
              try {
                const res = await request(`/rpc/list_hotel_users_with_pin`, { method: "POST", body });
                const out = normalizeRpcObject(res);
                return { ...out, users: Array.isArray(out?.users) ? out.users : [] };
              } catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.list_hotel_users_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              }
            }
            return { ok: false, reason: "invalid_response" };
          },

          setHotelUserActiveWithPin: async (hotelCode, pin, username, isActive) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_username: username, p_is_active: !!isActive },
              { hotel_code: hotelCode, pin: resolvedPin, username, is_active: !!isActive },
            ];
            for (const body of variants) {
              try { return normalizeRpcObject(await request(`/rpc/set_hotel_user_active_with_pin`, { method: "POST", body })); }
              catch (e) {
                const msg = String(e?.message || "");
                if (msg.includes("Could not find the function public.set_hotel_user_active_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              }
            }
            return { ok: false, reason: "invalid_response" };
          },

          upsertHotelUserPinWithPin: async (hotelCode, pin, username, newPin, role = "staff", isActive = true) => {
            const resolvedPin = resolvePin(pin);
            try {
              return normalizeRpcObject(await request(`/rpc/upsert_hotel_user_pin_with_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_pin: resolvedPin, p_username: username, p_new_pin: newPin, p_role: role === "admin" ? "admin" : "staff", p_is_active: !!isActive } }));
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.upsert_hotel_user_pin_with_pin")) return { ok: false, reason: "missing_function", message: msg };
              throw e;
            }
          },

          upsertHotelUserPinWithMasterPin: async (hotelCode, masterPin, username, newPin, role = "staff", isActive = true) => {
            try {
              return normalizeRpcObject(await request(`/rpc/upsert_hotel_user_pin_with_master_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_master_pin: String(masterPin || "").trim(), p_username: username, p_new_pin: newPin, p_role: role === "admin" ? "admin" : "staff", p_is_active: !!isActive } }));
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.includes("Could not find the function public.upsert_hotel_user_pin_with_master_pin")) return { ok: false, reason: "missing_function", message: msg };
              throw e;
            }
          },

          getCalendarWeek: async (hotelCode, weekStart) => {
            const variants = [
              { endpoint: `/rpc/get_calendar_week`, body: { p_hotel_code: hotelCode, p_week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week`, body: { hotel_code: hotelCode, week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week_v2`, body: { p_hotel_code: hotelCode, p_week_start: weekStart } },
              { endpoint: `/rpc/get_calendar_week_v2`, body: { hotel_code: hotelCode, week_start: weekStart } },
            ];
            let lastErr = null;
            for (const v of variants) {
              try {
                const res = await request(v.endpoint, { method: "POST", body: v.body });
                const out = normalizeRpcObject(res);
                if (out && typeof out === "object") return out;
              } catch (e) {
                const msg = String(e?.message || "");
                const missing = msg.includes("Could not find the function public.get_calendar_week") || msg.includes("Could not find the function public.get_calendar_week_v2");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            // Fallback: direct selects (works if tables exist + RLS allows anon+apikey)
            try {
              const startIso = `${String(weekStart || "").trim()}T00:00:00Z`;
              const endIso = `${addDaysIso(String(weekStart || "").trim(), 7)}T00:00:00Z`;
              const code = String(hotelCode || "").trim();
              const [appointments, blocks] = await Promise.all([
                request(`/appointments?hotel_code=eq.${encodeURIComponent(code)}&start_ts=gte.${encodeURIComponent(startIso)}&start_ts=lt.${encodeURIComponent(endIso)}&order=start_ts.asc&limit=5000`).catch(() => []),
                request(`/calendar_blocks?hotel_code=eq.${encodeURIComponent(code)}&start_ts=lt.${encodeURIComponent(endIso)}&end_ts=gt.${encodeURIComponent(startIso)}&order=start_ts.asc&limit=5000`).catch(() => []),
              ]);
              return {
                ok: true,
                appointments: Array.isArray(appointments) ? appointments : [],
                blocks: Array.isArray(blocks) ? blocks : [],
                source: "fallback",
              };
            } catch (e) {
              throw lastErr || e || new Error("Backendistä puuttuu get_calendar_week/get_calendar_week_v2.");
            }
          },

          getCalendarSettings: async (hotelCode) => {
            const code = String(hotelCode || "").trim();
            if (!code) return null;
            try {
              // select=* to avoid failing if optional columns are missing
              const rows = await request(`/calendar_settings?hotel_code=eq.${encodeURIComponent(code)}&select=*&limit=1`);
              return rows?.[0] && typeof rows[0] === "object" ? rows[0] : null;
            } catch (e) {
              const msg = String(e?.message || "");
              if (msg.toLowerCase().includes("calendar_settings")) return null;
              return null;
            }
          },

          updateCalendarSettingsWithPin: async (hotelCode, pin, settings) => {
            const resolvedPin = resolvePin(pin);
            const s = settings || {};
            const variants = [
              {
                endpoint: `/rpc/update_calendar_settings_with_pin_v2`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_open_time: s.open_time,
                  p_close_time: s.close_time,
                  p_slot_minutes: s.slot_minutes,
                  p_show_saturday: s.showSaturday,
                  p_show_sunday: s.showSunday,
                },
              },
              {
                endpoint: `/rpc/update_calendar_settings_with_pin_v2`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  open_time: s.open_time,
                  close_time: s.close_time,
                  slot_minutes: s.slot_minutes,
                  show_saturday: s.showSaturday,
                  show_sunday: s.showSunday,
                },
              },
              {
                endpoint: `/rpc/update_calendar_settings_with_pin`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_open_time: s.open_time,
                  p_close_time: s.close_time,
                  p_slot_minutes: s.slot_minutes,
                  p_show_saturday: s.showSaturday,
                  p_show_sunday: s.showSunday,
                },
              },
              {
                endpoint: `/rpc/update_calendar_settings_with_pin`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  open_time: s.open_time,
                  close_time: s.close_time,
                  slot_minutes: s.slot_minutes,
                  show_saturday: s.showSaturday,
                  show_sunday: s.showSunday,
                },
              },
            ];
            let lastErr = null;
            for (const v of variants) {
              try {
                return normalizeRpcObject(await request(v.endpoint, { method: "POST", body: v.body }));
              } catch (e) {
                const msg = String(e?.message || "");
                const missing =
                  msg.includes("Could not find the function public.update_calendar_settings_with_pin") ||
                  msg.includes("Could not find the function public.update_calendar_settings_with_pin_v2");
                if (!missing) throw e;
                lastErr = e;
              }
            }
            // Fallback: direct upsert into calendar_settings (may be blocked by RLS)
            try {
              const code = String(hotelCode || "").trim();
              const rows = await request(`/calendar_settings?hotel_code=eq.${encodeURIComponent(code)}&select=id&limit=1`).catch(() => []);
              const payload = {
                hotel_code: code,
                open_time: s.open_time,
                close_time: s.close_time,
                slot_minutes: s.slot_minutes,
                show_saturday: s.showSaturday,
                show_sunday: s.showSunday,
              };
              if (rows?.[0]?.id) {
                await request(`/calendar_settings?hotel_code=eq.${encodeURIComponent(code)}`, { method: "PATCH", preferReturn: true, body: payload });
              } else {
                await request(`/calendar_settings`, { method: "POST", preferReturn: true, body: payload });
              }
              return { ok: true, source: "direct" };
            } catch (e) {
              return { ok: false, reason: "missing_function", message: String(lastErr?.message || e?.message || "") };
            }
          },

          createBlockWithPin: async (hotelCode, pin, payload) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_start_ts: payload?.start_ts, p_end_ts: payload?.end_ts, p_kind: payload?.kind ?? "tauko", p_title: payload?.title ?? null, p_notes: payload?.notes ?? null },
              { hotel_code: hotelCode, pin: resolvedPin, start_ts: payload?.start_ts, end_ts: payload?.end_ts, kind: payload?.kind ?? "tauko", title: payload?.title ?? null, notes: payload?.notes ?? null },
            ];
            let lastErr = null;
            for (let i = 0; i < variants.length; i += 1) {
              const body = variants[i];
              try {
                const out = normalizeRpcObject(await request(`/rpc/create_block_with_pin`, { method: "POST", body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                return out;
              }
              catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const missing = msg.includes("Could not find the function public.create_block_with_pin") || msg.includes("function public.create_block_with_pin(");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                if (!missing) throw e;
                lastErr = e;
              }
            }
            throw lastErr || new Error("Blokin PIN-luontifunktiota ei löytynyt.");
          },

          createBlock: async (hotelCode, payload) => {
            return request(`/calendar_blocks`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, ...payload } });
          },

          updateBlock: async (hotelCode, blockId, patch) => {
            return request(`/calendar_blocks?id=eq.${blockId}&hotel_code=eq.${encodeURIComponent(hotelCode)}`, { method: "PATCH", preferReturn: true, body: patch });
          },

          deleteBlock: async (hotelCode, blockId) => {
            const rows = await request(`/calendar_blocks?id=eq.${blockId}&hotel_code=eq.${encodeURIComponent(hotelCode)}&select=id`, { method: "DELETE", preferReturn: true });
            if (Array.isArray(rows) && rows.length > 0) return rows;
            throw new Error("not_deleted");
          },

          updateBlockWithPin: async (hotelCode, pin, blockId, patch) => {
            const resolvedPin = resolvePin(pin);
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_block_id: blockId ?? null, p_start_ts: patch?.start_ts ?? null, p_end_ts: patch?.end_ts ?? null, p_kind: patch?.kind ?? null, p_title: patch?.title ?? null, p_notes: patch?.notes ?? null },
              { hotel_code: hotelCode, pin: resolvedPin, block_id: blockId ?? null, start_ts: patch?.start_ts ?? null, end_ts: patch?.end_ts ?? null, kind: patch?.kind ?? null, title: patch?.title ?? null, notes: patch?.notes ?? null },
            ];
            for (let i = 0; i < variants.length; i += 1) {
              const body = variants[i];
              try {
                const out = normalizeRpcObject(await request(`/rpc/update_block_with_pin`, { method: "POST", body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const missing = msg.includes("Could not find the function public.update_block_with_pin") || msg.includes("function public.update_block_with_pin(");
                if (paramMismatch && i < variants.length - 1) continue;
                if (!missing) throw e;
              }
            }
            return { ok: false, reason: "missing_function" };
          },

          deleteBlockWithPin: async (hotelCode, pin, blockId) => {
            const resolvedPin = resolvePin(pin);
            const variants = [{ p_hotel_code: hotelCode, p_pin: resolvedPin, p_block_id: blockId ?? null }, { hotel_code: hotelCode, pin: resolvedPin, block_id: blockId ?? null }];
            for (let i = 0; i < variants.length; i += 1) {
              const body = variants[i];
              try {
                const out = normalizeRpcObject(await request(`/rpc/delete_block_with_pin`, { method: "POST", body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const missing = msg.includes("Could not find the function public.delete_block_with_pin") || msg.includes("function public.delete_block_with_pin(");
                if (paramMismatch && i < variants.length - 1) continue;
                if (!missing) throw e;
              }
            }
            return { ok: false, reason: "missing_function" };
          },

          createAppointmentWithPin: async (hotelCode, pin, payload) => {
            const resolvedPin = resolvePin(pin);
            const normalizeBay = (v) => {
              const n = parseInt(v, 10);
              return n === 2 ? 2 : 1;
            };
            const variants = [
              {
                endpoint: `/rpc/create_appointment_with_pin`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  start_ts: payload?.start_ts,
                  end_ts: payload?.end_ts,
                  bay: normalizeBay(payload?.bay),
                  customer_name: payload?.customer_name ?? null,
                  phone: payload?.phone ?? null,
                  plate: payload?.plate ?? null,
                  notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_start_ts: payload?.start_ts,
                  p_end_ts: payload?.end_ts,
                  p_bay: normalizeBay(payload?.bay),
                  p_customer_name: payload?.customer_name ?? null,
                  p_phone: payload?.phone ?? null,
                  p_plate: payload?.plate ?? null,
                  p_notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin_v2`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  start_ts: payload?.start_ts,
                  end_ts: payload?.end_ts,
                  bay: normalizeBay(payload?.bay),
                  customer_name: payload?.customer_name ?? null,
                  phone: payload?.phone ?? null,
                  plate: payload?.plate ?? null,
                  notes: payload?.notes ?? null,
                },
              },
              {
                endpoint: `/rpc/create_appointment_with_pin_v2`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_start_ts: payload?.start_ts,
                  p_end_ts: payload?.end_ts,
                  p_bay: normalizeBay(payload?.bay),
                  p_customer_name: payload?.customer_name ?? null,
                  p_phone: payload?.phone ?? null,
                  p_plate: payload?.plate ?? null,
                  p_notes: payload?.notes ?? null,
                },
              },
            ];
            let lastErr = null;
            for (let i = 0; i < variants.length; i += 1) {
              const v = variants[i];
              try {
                const out = normalizeRpcObject(await request(v.endpoint, { method: "POST", body: v.body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                return out;
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const ambiguous = msg.includes("Could not choose the best candidate function between");
                if (ambiguous) throw e;
                const missing =
                  msg.includes("Could not find the function public.create_appointment_with_pin") ||
                  msg.includes("Could not find the function public.create_appointment_with_pin_v2");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                if (!missing) throw e;
                lastErr = e;
              }
            }
            return { ok: false, reason: "missing_function", message: String(lastErr?.message || "create_appointment_with_pin puuttuu backendistä.") };
          },

          createAppointment: async (hotelCode, payload) => {
            return request(`/appointments`, { method: "POST", preferReturn: true, body: { hotel_code: hotelCode, ...payload } });
          },

          updateAppointment: async (hotelCode, appointmentId, patch) => {
            return request(`/appointments?id=eq.${appointmentId}&hotel_code=eq.${encodeURIComponent(hotelCode)}`, { method: "PATCH", preferReturn: true, body: patch });
          },

          deleteAppointment: async (hotelCode, appointmentId) => {
            const rows = await request(`/appointments?id=eq.${appointmentId}&hotel_code=eq.${encodeURIComponent(hotelCode)}&select=id`, { method: "DELETE", preferReturn: true });
            if (Array.isArray(rows) && rows.length > 0) return rows;
            throw new Error("not_deleted");
          },

          updateAppointmentWithPin: async (hotelCode, pin, appointmentId, patch) => {
            const resolvedPin = resolvePin(pin);
            const key = String(appointmentId ?? "");
            const normalizeBay = (v) => {
              const n = parseInt(v, 10);
              return n === 2 ? 2 : 1;
            };
            const variants = [
              {
                endpoint: `/rpc/update_appointment_with_pin`,
                body: {
                  hotel_code: hotelCode,
                  pin: resolvedPin,
                  appointment_id: key,
                  start_ts: patch?.start_ts,
                  end_ts: patch?.end_ts,
                  bay: patch?.bay !== undefined ? normalizeBay(patch?.bay) : undefined,
                  customer_name: patch?.customer_name,
                  phone: patch?.phone,
                  plate: patch?.plate,
                  notes: patch?.notes,
                },
              },
              {
                endpoint: `/rpc/update_appointment_with_pin`,
                body: {
                  p_hotel_code: hotelCode,
                  p_pin: resolvedPin,
                  p_appointment_id: key,
                  p_start_ts: patch?.start_ts,
                  p_end_ts: patch?.end_ts,
                  p_bay: patch?.bay !== undefined ? normalizeBay(patch?.bay) : undefined,
                  p_customer_name: patch?.customer_name,
                  p_phone: patch?.phone,
                  p_plate: patch?.plate,
                  p_notes: patch?.notes,
                },
              },
            ];
            for (let i = 0; i < variants.length; i += 1) {
              const v = variants[i];
              try {
                const out = normalizeRpcObject(await request(v.endpoint, { method: "POST", body: v.body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const ambiguous = msg.includes("Could not choose the best candidate function between");
                if (ambiguous) throw e;
                const missing = msg.includes("Could not find the function public.update_appointment_with_pin");
                if (paramMismatch && i < variants.length - 1) continue;
                if (!missing) throw e;
              }
            }
            return { ok: false, reason: "missing_function" };
          },

          deleteAppointmentWithPin: async (hotelCode, pin, appointmentId) => {
            const resolvedPin = resolvePin(pin);
            const key = String(appointmentId ?? "");
            const variants = [
              { p_hotel_code: hotelCode, p_pin: resolvedPin, p_appointment_id: key },
              { hotel_code: hotelCode, pin: resolvedPin, appointment_id: key },
            ];
            let lastErr = null;
            for (let i = 0; i < variants.length; i += 1) {
              const body = variants[i];
              try {
                const out = normalizeRpcObject(await request(`/rpc/cancel_appointment_with_pin`, { method: "POST", body }));
                const reason = String(out?.reason || "");
                const paramMismatchLike = out?.ok === false && reason.startsWith("missing_");
                if (paramMismatchLike && i < variants.length - 1) continue;
                if (out?.reason === "wrong_pin") return { ok: false, reason: "wrong_pin" };
                if (out?.ok === false) return out;
                return { ok: true };
              } catch (e) {
                const msg = String(e?.message || "");
                const lower = msg.toLowerCase();
                const paramMismatch = lower.includes("missing") && lower.includes("parameter");
                const ambiguous = msg.includes("Could not choose the best candidate function between");
                if (ambiguous) throw e;
                const missing = msg.includes("Could not find the function public.cancel_appointment_with_pin");
                if (paramMismatch && i < variants.length - 1) { lastErr = e; continue; }
                if (!missing) throw e;
                lastErr = e;
              }
            }
            return { ok: false, reason: "missing_function", message: String(lastErr?.message || "cancel_appointment_with_pin puuttuu backendistä.") };
          },

          changeOwnPin: async (hotelCode, username, oldPin, newPin) => normalizeRpcObject(await request(`/rpc/change_hotel_user_pin_with_old_pin`, { method: "POST", body: { p_hotel_code: hotelCode, p_username: username, p_old_pin: oldPin, p_new_pin: newPin } })),
        };
      }
      // ==========================================================
      // State
      // ==========================================================
      const state = {
        tab: "dashboard",
        session: {
          ok: false,
          hotelCode: null,
          displayName: null,
          role: null,
          username: null,
          pinSource: null,
          pin: null, // RAM only
          masterName: null,
        },
        security: {
          autoLogoutMinutes: 30,
        },
        lastActivityMs: appNowMs(),
        data: {
          tires: [],
          customers: [],
          blocks: [],
          appointments: [],
          users: [],
          locations: [],
          calendarDate: todayStrLocal(),
          calendarSettings: {
            open_time: "08:00",
            close_time: "17:00",
            slot_minutes: 20,
            timezone: "Europe/Helsinki",
            showSaturday: true,
            showSunday: true,
          },
          calendarUi: {
            viewMode: "all", // all | single
            singleDayIndex: 0,
          },
        },
        ui: {
          loading: false,
          worklistCollapsed: {},
        },
      };

      const api = makeApi({
        getSessionPin: () => String(state.session.pin || "").trim(),
        getSessionIdentity: () => ({
          username: String(state.session.username || "").trim(),
          role: normalizeRole(state.session.role),
          pinSource: String(state.session.pinSource || "").trim().toLowerCase(),
        }),
      });

      function setLoading(v) {
        state.ui.loading = !!v;
        render();
      }

      function bumpActivity() {
        state.lastActivityMs = appNowMs();
      }
      ["click", "keydown", "mousemove", "touchstart"].forEach((ev) => {
        window.addEventListener(ev, () => bumpActivity(), { passive: true });
      });

      setInterval(() => {
        const mins = clamp(parseInt(state.security.autoLogoutMinutes, 10) || 0, 0, 240);
        if (!state.session.ok) return;
        if (!mins) return;
        const idleMs = appNowMs() - state.lastActivityMs;
        if (idleMs > mins * 60 * 1000) {
          logout("Automaattinen kirjaus ulos");
        }
      }, 5000);

      function setSessionFromVerify(verify, pin) {
        state.session.ok = true;
        state.session.hotelCode = String(verify?.hotel_code || "").trim();
        state.session.displayName = String(verify?.display_name || verify?.hotel_code || "").trim();
        state.session.role = normalizeRole(verify?.role || "");
        state.session.username = verify?.username ?? null;
        state.session.pinSource = String(verify?.source || "").trim().toLowerCase() || null;
        state.session.pin = String(pin || "").trim() || null;
      }

      function clearData() {
        state.data.tires = [];
        state.data.customers = [];
        state.data.blocks = [];
        state.data.appointments = [];
        state.data.users = [];
        state.data.locations = [];
        state.data.calendarDate = todayStrLocal();
      }

      function logout(reason) {
        state.session = { ok: false, hotelCode: null, displayName: null, role: null, username: null, pinSource: null, pin: null, masterName: null };
        state.tab = "dashboard";
        clearData();
        state.ui.loading = false;
        $("#nav").style.display = "none";
        $("#sessionChip").style.display = "none";
        if (reason) toast("info", "Ilmoitus", reason);
        render();
      }

      function setTab(tab) {
        state.tab = tab;
        render();
        if (tab === "dashboard" || tab === "rows" || tab === "worklist") ensureLoaded();
        if (tab === "customers") ensureLoaded();
        if (tab === "calendar") loadCalendarWeek();
        if (tab === "settings") {
          if (isAdminRole(state.session.role)) {
            loadUsers();
            loadLocations();
          }
        }
      }

      async function ensureLoaded() {
        await Promise.all([loadTires(), loadCustomers()]);
      }

      async function loadTires() {
        if (!state.session.ok) return;
        try {
          state.data.tires = await api.listTires(state.session.hotelCode);
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Rivien lataus epäonnistui");
        }
      }

      async function loadCustomers() {
        if (!state.session.ok) return;
        try {
          const rows = await api.listCustomers(state.session.hotelCode);
          state.data.customers = Array.isArray(rows) ? rows : [];
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Asiakkaiden lataus epäonnistui");
        }
      }

      async function loadCalendarWeek() {
        if (!state.session.ok) return;
        try {
          const weekStart = getMondayIso(state.data.calendarDate);
          const payload = await api.getCalendarWeek(state.session.hotelCode, weekStart);
          state.data.blocks = Array.isArray(payload?.blocks) ? payload.blocks : [];
          state.data.appointments = Array.isArray(payload?.appointments) ? payload.appointments : [];
          const s = payload?.settings && typeof payload.settings === "object" ? payload.settings : null;
          const settingsFromPayload = s
            ? {
                open_time: normalizeTimeHHMM(s.open_time, state.data.calendarSettings.open_time),
                close_time: normalizeTimeHHMM(s.close_time, state.data.calendarSettings.close_time),
                slot_minutes: Math.max(5, parseInt(s.slot_minutes, 10) || state.data.calendarSettings.slot_minutes || 20),
                timezone: String(s.timezone || state.data.calendarSettings.timezone || "Europe/Helsinki"),
                showSaturday: typeof s.show_saturday === "boolean" ? s.show_saturday : (typeof s.showSaturday === "boolean" ? s.showSaturday : state.data.calendarSettings.showSaturday),
                showSunday: typeof s.show_sunday === "boolean" ? s.show_sunday : (typeof s.showSunday === "boolean" ? s.showSunday : state.data.calendarSettings.showSunday),
              }
            : null;
          if (settingsFromPayload) {
            state.data.calendarSettings = settingsFromPayload;
          } else {
            const row = await api.getCalendarSettings(state.session.hotelCode);
            if (row) {
              const open = normalizeTimeHHMM(row.open_time, state.data.calendarSettings.open_time);
              const close = normalizeTimeHHMM(row.close_time, state.data.calendarSettings.close_time);
              const slot = Math.max(5, parseInt(row.slot_minutes, 10) || state.data.calendarSettings.slot_minutes || 20);
              state.data.calendarSettings = {
                open_time: open,
                close_time: close,
                slot_minutes: slot,
                timezone: String(row.timezone || state.data.calendarSettings.timezone || "Europe/Helsinki"),
                showSaturday: row.show_saturday !== false,
                showSunday: row.show_sunday !== false,
              };
            }
          }
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Kalenterin lataus epäonnistui");
        }
      }

      async function loadUsers() {
        if (!state.session.ok || !isAdminRole(state.session.role)) return;
        try {
          const res = await api.listHotelUsersWithPin(state.session.hotelCode, state.session.pin);
          if (res?.ok !== true) {
            if (String(res?.reason || "") === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", res?.message || "Käyttäjälistan lataus epäonnistui");
            return;
          }
          let users = Array.isArray(res?.users) ? res.users : [];
          const masterName = state.session.masterName || "Master";
          users = [{ id: "master", username: masterName, role: "admin", is_active: true, is_master: true }, ...users];
          state.data.users = users;
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Käyttäjälistan lataus epäonnistui");
        }
      }

      async function loadLocations() {
        if (!state.session.ok || !isAdminRole(state.session.role)) return;
        try {
          const rows = await api.listLocationsAdmin(state.session.hotelCode);
          state.data.locations = Array.isArray(rows) ? rows : [];
          render();
        } catch (e) {
          toast("error", "Virhe", e?.message || "Hyllypaikkojen lataus epäonnistui");
        }
      }

      async function doLogin(hotelCode, pin) {
        setLoading(true);
        try {
          const verify = await api.verifyHotelWithPin(hotelCode, pin);
          if (!verify?.ok) {
            const reason = String(verify?.reason || "");
            if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else if (reason === "hotel_not_found") toast("error", "Virhe", "Hotellia ei löytynyt.");
            else if (reason === "missing_pin" || reason === "missing_hotel_code") toast("error", "Virhe", "Täytä hotellikoodi ja PIN.");
            else if (reason === "missing_function") toast("error", "Virhe", "Backendistä puuttuu verify_hotel_with_pin-funktio.");
            else toast("error", "Virhe", verify?.message || reason || "Kirjautuminen epäonnistui.");
            return;
          }

          setSessionFromVerify(verify, pin);
          state.session.masterName = await api.getHotelMasterName(state.session.hotelCode);

          $("#nav").style.display = "";
          $("#sessionChip").style.display = "";
          state.tab = "dashboard";

          await ensureLoaded();
          if (isAdminRole(state.session.role)) {
            await Promise.all([loadUsers(), loadLocations()]);
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Kirjautuminen onnistui.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Kirjautuminen epäonnistui");
        } finally {
          setLoading(false);
        }
      }

      async function requirePin({ title, message, forcePrompt = false, prefill = "", requireAdmin = false } = {}) {
        const saved = String(state.session.pin || "").trim();
        if (!forcePrompt && saved) return saved;
        const typed = await modalPromptPin({ title: title || "PIN", message: message || "Syötä PIN.", prefill });
        if (!typed) return "";
        const verify = await api.verifyHotelWithPin(state.session.hotelCode, typed);
        if (!verify?.ok) {
          toast("error", "Virhe", "Väärä PIN.");
          return "";
        }
        if (requireAdmin && !isAdminRole(verify?.role)) {
          toast("error", "Virhe", "Vain admin/master PIN käy tähän toimintoon.");
          return "";
        }
        state.session.pin = typed;
        return typed;
      }
      // ==========================================================
      // Actions
      // ==========================================================
      async function approvePendingRow(row, nextSeasonPaid) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        try {
          const rev = row?.rev;
          if (typeof rev !== "number") throw new Error("Rivin versiotieto puuttuu.");
          const cleanNotes = stripStaffApprovalTag(row?.notes);
          const patch = {};
          if (String(row?.notes || "").trim() !== String(cleanNotes || "").trim()) patch.notes = cleanNotes;
          if (typeof nextSeasonPaid === "boolean") patch.season_fee_paid = nextSeasonPaid;
          await api.updateTire(row.id, rev, patch);
          await loadTires();
          toast("success", "Ilmoitus", "Vahvistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Vahvistus epäonnistui.");
        }
      }

      async function approvePendingCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        try {
          await api.updateCustomer(customer.id, {});
          await loadCustomers();
          toast("success", "Ilmoitus", "Asiakas vahvistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Vahvistus epäonnistui.");
        }
      }

      async function takeInDeliveredRow(row) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        try {
          const today = todayStrLocal();
          const lastLoc = String(row?.last_location || "").trim();
          if (!lastLoc) {
            toast("error", "Virhe", "Vanha hyllypaikka puuttuu. Valitse paikka Muokkaa-näkymässä.");
            return;
          }
          const taken = await api.isLocationTaken(state.session.hotelCode, lastLoc, row.id);
          if (taken) {
            toast("error", "Virhe", "Vanha hyllypaikka ei ole vapaa. Valitse paikka Muokkaa-näkymässä.");
            return;
          }
          const patch = {
            status: "Varastossa",
            in_date: today,
            out_date: null,
            pickup_date: null,
            location: lastLoc,
            waiting_pickup: false,
            working: false,
          };
          await api.updateTire(row.id, row.rev, patch);
          await loadTires();
          toast("success", "Ilmoitus", "Otettu sisään.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Sisäänotto epäonnistui.");
        }
      }

      async function softDeleteRow(row) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä admin/master PIN poistoa varten.", requireAdmin: true });
        if (!pin) return;
        try {
          await api.deleteTireWithPin(row.id, state.session.hotelCode, pin);
          await loadTires();
          toast("success", "Ilmoitus", "Poistettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
        }
      }

      async function hardDeleteRow(row) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Vahvista pysyvä poisto", message: "Syötä admin/master PIN pysyvää poistoa varten.", forcePrompt: true, requireAdmin: true });
        if (!pin) return;
        try {
          await api.hardDeleteTireWithPin(row.id, state.session.hotelCode, pin);
          await loadTires();
          const stillThere = (state.data.tires || []).some((r) => String(r?.id) === String(row?.id));
          if (stillThere) throw new Error("Poisto ei toteutunut (rivi jäi listaan).");
          toast("success", "Ilmoitus", "Poistettu pysyvästi.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Pysyvä poisto epäonnistui.");
        }
      }

      async function softDeleteCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Poista asiakas", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        try {
          const out = await api.customerSoftDeleteCascadeWithPin(state.session.hotelCode, pin, customer.id);
          if (out?.ok !== true) throw new Error(out?.reason || "Poisto epäonnistui.");
          await ensureLoaded();
          toast("success", "Ilmoitus", `Poistettu (soft). Renkaat: ${out?.tires_soft_deleted ?? 0}`);
        } catch (e) {
          toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
        }
      }

      async function hardDeleteCustomer(customer) {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Poista asiakas pysyvästi", message: "Syötä admin/master PIN.", forcePrompt: true, requireAdmin: true });
        if (!pin) return;
        try {
          const out = await api.customerHardDeleteCascadeWithPin(state.session.hotelCode, pin, customer.id);
          if (out?.ok !== true) throw new Error(out?.reason || "Pysyvä poisto epäonnistui.");
          await ensureLoaded();
          const stillThere = (state.data.customers || []).some((c) => String(c?.id) === String(customer?.id));
          if (stillThere) throw new Error("Poisto ei toteutunut (asiakas jäi listaan).");
          toast("success", "Ilmoitus", `Poistettu pysyvästi. Renkaat: ${out?.tires_deleted ?? 0}`);
        } catch (e) {
          toast("error", "Virhe", e?.message || "Pysyvä poisto epäonnistui.");
        }
      }

      async function addNewRow(form) {
        const hotelCode = state.session.hotelCode;
        const f = {
          customer: String(form.customer || "").trim(),
          phone: String(form.phone || "").trim(),
          plate: String(form.plate || "").trim(),
          tire_size: String(form.email || "").trim(),
          location: String(form.location || "").trim(),
          status: "Varastossa",
          notes: String(form.notes || "").trim() || null,
          season_fee_paid: !!form.season_fee_paid,
        };
        if (!f.customer || !f.phone || !f.plate || !f.location) {
          toast("error", "Virhe", "Täytä pakolliset kentät: Asiakkaan nimi, Puhelinnumero, Rekisterinumero, Paikka.");
          return;
        }
        try {
          const duplicate = await api.findActiveTireByPlate(hotelCode, f.plate);
          if (duplicate) {
            toast("error", "Virhe", formatPlateDuplicateMessage(f.plate, duplicate));
            return;
          }

          const existing = await api.getCustomerByName(hotelCode, f.customer);
          if (!existing) {
            await api.addCustomer(hotelCode, { nimi: f.customer, puhelin: f.phone, sahkoposti: f.tire_size });
          } else {
            const patch = {};
            if (f.customer && existing.nimi !== f.customer) patch.nimi = f.customer;
            if (f.phone && existing.puhelin !== f.phone) patch.puhelin = f.phone;
            if (f.tire_size && existing.sahkoposti !== f.tire_size) patch.sahkoposti = f.tire_size;
            if (Object.keys(patch).length) await api.updateCustomer(existing.id, patch);
          }

          const canManageSeasonFee = isAdminRole(state.session.role);
          const payload = { ...f };
          if (!canManageSeasonFee) {
            payload.season_fee_paid = false;
            payload.notes = ensureAdminApprovalTag(payload.notes);
          }

          await api.addTire(hotelCode, payload);
          await ensureLoaded();
          toast("success", "Ilmoitus", "Tallennettu.");
          setTab("rows");
        } catch (e) {
          const msg = String(e?.message || "");
          if (msg.toLowerCase().includes("duplicate") || msg.toLowerCase().includes("unique")) {
            toast("error", "Virhe", "Hyllypaikka on jo varattu. Valitse toinen.");
          } else {
            toast("error", "Virhe", msg || "Tallennus epäonnistui.");
          }
        }
      }

      async function updateRowLocation(row, nextLocation) {
        const loc = String(nextLocation || "").trim();
        if (!loc) return toast("error", "Virhe", "Syötä hyllypaikka.");
        try {
          const rev = row?.rev;
          if (typeof rev !== "number") throw new Error("Rivin versiotieto puuttuu.");
          await api.updateTire(row.id, rev, { location: loc });
          await loadTires();
          toast("success", "Ilmoitus", "Hyllypaikka päivitetty.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivitys epäonnistui.");
        }
      }

      function blocksForSelectedDay() {
        const dateIso = state.data.calendarDate;
        const startDay = new Date(`${dateIso}T00:00:00Z`).getTime();
        const endDay = new Date(`${addDaysIso(dateIso, 1)}T00:00:00Z`).getTime();
        return (state.data.blocks || []).filter((b) => {
          const s = new Date(b.start_ts).getTime();
          const e = new Date(b.end_ts).getTime();
          return Number.isFinite(s) && Number.isFinite(e) && e > startDay && s < endDay;
        });
      }

      async function calendarCloseDay() {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Päivän sulku", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        const dateIso = state.data.calendarDate;
        const start = new Date(`${dateIso}T00:00:00`);
        const end = new Date(`${addDaysIso(dateIso, 1)}T00:00:00`);
        try {
          const out = await api.createBlockWithPin(state.session.hotelCode, pin, {
            start_ts: start.toISOString(),
            end_ts: end.toISOString(),
            kind: "CLOSED",
            title: "Suljettu",
            notes: null,
          });
          if (out?.ok === false && out?.reason === "wrong_pin") throw new Error("Väärä PIN.");
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Päivä suljettu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivän sulku epäonnistui.");
        }
      }

      async function calendarOpenDay() {
        if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
        const pin = await requirePin({ title: "Päivän avaus", message: "Syötä admin/master PIN.", requireAdmin: true });
        if (!pin) return;
        const dayBlocks = blocksForSelectedDay();
        if (dayBlocks.length === 0) return toast("info", "Ilmoitus", "Ei sulkuja valitulle päivälle.");
        try {
          for (const b of dayBlocks) {
            const out = await api.deleteBlockWithPin(state.session.hotelCode, pin, b.id);
            if (out?.ok === false && out?.reason === "wrong_pin") throw new Error("Väärä PIN.");
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Päivä avattu.");
        } catch (e) {
          toast("error", "Virhe", e?.message || "Päivän avaus epäonnistui.");
        }
      }
      // ==========================================================
      // UI
      // ==========================================================
      const root = $("#root");
      const nav = $("#nav");

      nav.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-tab]");
        if (!btn) return;
        setTab(btn.getAttribute("data-tab"));
      });

      function renderTopbar() {
        if (!state.session.ok) return;
        $$("#nav button").forEach((b) => b.classList.toggle("active", b.getAttribute("data-tab") === state.tab));
        $("#chipHotel").textContent = state.session.displayName || state.session.hotelCode || "—";
        const whoName = state.session.username ? String(state.session.username) : (state.session.masterName || "Master");
        const role = isAdminRole(state.session.role) ? "admin" : "staff";
        $("#chipWho").textContent = `Kirjautunut: ${whoName} (${role})`;
      }

      function renderLogin() {
        root.innerHTML = `
          <div class="row">
            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
                  <div>
                    <h1 class="h1">Kirjautuminen</h1>
                    <p class="p">Syötä hotellikoodi ja henkilökohtainen PIN. PIN unohtuessa ota yhteyttä ylläpitäjään.</p>
                  </div>
                  <span class="pill mono">web</span>
                </div>
                <div class="field">
                  <div class="label">Hotellikoodi <span class="req">*</span></div>
                  <input id="loginHotel" placeholder="Syötä saamasi hotellikoodi" autocomplete="off" />
                </div>
                <div class="field">
                  <div class="label">PIN <span class="req">*</span></div>
                  <input id="loginPin" type="password" placeholder="Syötä saamasi henkilökohtainen PIN-koodi" autocomplete="one-time-code" />
                </div>
                <div class="btn-row">
                  <button class="btn primary" id="loginBtn" ${state.ui.loading ? "disabled" : ""}>Kirjaudu / Vahvista</button>
                </div>
                <div class="divider"></div>
                <div class="p" style="margin:0">Ei Supabase Authia. Ei laitetallennusta. Istunto on vain muistissa.</div>
              </div>
            </div>
            <div class="col">
              <div class="card pad">
                <h1 class="h1">Huom</h1>
                <p class="p">Jos avaat tämän suoraan tiedostona ja kirjautuminen ei toimi, aja se paikallisella web-palvelimella (CORS/origin "null").</p>
              </div>
            </div>
          </div>
        `;

        const hotel = $("#loginHotel", root);
        const pin = $("#loginPin", root);
        const btn = $("#loginBtn", root);
        const go = () => doLogin(hotel.value, pin.value);
        btn.addEventListener("click", go);
        pin.addEventListener("keydown", (e) => { if (e.key === "Enter") go(); });
        hotel.addEventListener("keydown", (e) => { if (e.key === "Enter") pin.focus(); });
        setTimeout(() => hotel.focus(), 0);
      }

      function renderDashboard() {
        const tires = state.data.tires || [];
        const customers = state.data.customers || [];
        const pendingRows = tires.filter((r) => isPendingRowApproval(r));
        const activeRowCustomerKeys = new Set(tires.filter((r) => !r?.deleted).map((r) => normalizeNameKey(r?.customer)).filter(Boolean));
        const pendingCustomers = (customers || []).filter((c) => {
          if (!isPendingCustomerApproval(c)) return false;
          const key = normalizeNameKey(c?.nimi || c?.customer);
          if (!key) return true;
          return !activeRowCustomerKeys.has(key);
        });
        const totalPending = pendingRows.length + pendingCustomers.length;
        const canApprove = isAdminRole(state.session.role);
        const today = todayStrLocal();
        const pickupsToday = tires.filter((r) => !r.deleted && String(r.status || "").trim().toLowerCase() !== "luovutettu" && String(r.pickup_date || "") === today);
        const unpaidRows = tires.filter((r) => !r.deleted && !isSeasonPaid(r.season_fee_paid) && String(r.status || "").trim().toLowerCase() !== "luovutettu");
        const missingLocationRows = tires.filter((r) => !r.deleted && String(r.status || "").trim().toLowerCase() !== "luovutettu" && !String(r.location || "").trim());

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Etusivu</h1>
                <p class="p">Hotelli: <span style="font-weight:900">${escapeHtml(state.session.displayName || state.session.hotelCode || "")}</span></p>
              </div>
              <div style="display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end;">
                <span class="pill">Rivit: ${tires.length}</span>
                <span class="pill">Asiakkaat: ${customers.length}</span>
                <span class="pill">Odottaa: ${totalPending}</span>
                <span class="pill">Noudot tänään: ${pickupsToday.length}</span>
                <span class="pill">Maksamattomat: ${unpaidRows.length}</span>
                <span class="pill">Puuttuu paikka: ${missingLocationRows.length}</span>
              </div>
            </div>
            <div class="btn-row" style="margin-top: 10px;">
              <button class="btn primary" id="dashNewRow">Uusi rivi</button>
              <button class="btn ghost" id="dashRefresh">Päivitä</button>
            </div>
          </div>

          <div class="row" style="margin-top: 12px;">
            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Odottaa vahvistusta (rivit)</div>
                  <span class="pill">${pendingRows.length}</span>
                </div>
                <div class="list">
                  ${pendingRows.slice(0, 10).map((r) => {
                    const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(r.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(r.plate))}</span></div>
                          <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))} · Luonut: ${escapeHtml(formatActor(r.created_by_name, r.created_by_role))}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                            <span class="pill">Odottaa admin-hyväksyntää</span>
                          </div>
                        </div>
                        <div class="actions">
                          ${canApprove ? `<button class="btn primary" data-approve-row="${escapeHtml(r.id)}">Hyväksy</button>` : ``}
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${pendingRows.length === 0 ? `<div class="muted">Ei odottavia rivejä.</div>` : ``}
                </div>
              </div>
            </div>

            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Odottaa vahvistusta (asiakkaat)</div>
                  <span class="pill">${pendingCustomers.length}</span>
                </div>
                <div class="list">
                  ${pendingCustomers.slice(0, 10).map((c) => {
                    const name = c.nimi || c.customer || "—";
                    const phone = c.puhelin || c.phone || "";
                    const email = c.sahkoposti || c.email || "";
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(name)}</div>
                          <div class="meta">${escapeHtml(phone)} ${email ? "· " + escapeHtml(email) : ""}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill">Odottaa admin-hyväksyntää</span>
                            <span class="pill">Luonut: ${escapeHtml(formatActor(c.created_by_name || c.luonut_nimi, c.created_by_role || c.luonut_rooli))}</span>
                          </div>
                        </div>
                        <div class="actions">
                          ${canApprove ? `<button class="btn primary" data-approve-customer="${escapeHtml(c.id)}">Hyväksy</button>` : ``}
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${pendingCustomers.length === 0 ? `<div class="muted">Ei odottavia asiakkaita.</div>` : ``}
                </div>
              </div>
            </div>
          </div>

          <div class="row" style="margin-top: 12px;">
            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Noudot tänään</div>
                  <span class="pill">${pickupsToday.length}</span>
                </div>
                <div class="divider"></div>
                <div class="list">
                  ${pickupsToday.slice(0, 10).map((r) => {
                    const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(prettyPlate(r.plate))} · ${escapeHtml(r.customer || "—")}</div>
                          <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                            <span class="pill">Nouto: ${escapeHtml(formatDateOnlyFinnish(r.pickup_date, "—"))}</span>
                          </div>
                        </div>
                        <div class="actions">
                          <button class="btn ghost" data-row-open="${escapeHtml(r.id)}">Avaa</button>
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${pickupsToday.length === 0 ? `<div class="muted">Ei noutoja tälle päivälle.</div>` : ``}
                </div>
              </div>
            </div>

            <div class="col">
              <div class="card pad">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                  <div style="font-weight:900">Maksamattomat</div>
                  <span class="pill">${unpaidRows.length}</span>
                </div>
                <div class="divider"></div>
                <div class="list">
                  ${unpaidRows.slice(0, 10).map((r) => {
                    const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
                    return `
                      <div class="item">
                        <div class="main">
                          <div class="title">${escapeHtml(prettyPlate(r.plate))} · ${escapeHtml(r.customer || "—")}</div>
                          <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))}</div>
                          <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                            <span class="pill" style="background:#fff3f4;border-color:#fbcfe8;color:#9f1239">Kausimaksu maksamatta</span>
                          </div>
                        </div>
                        <div class="actions">
                          <button class="btn ghost" data-row-open="${escapeHtml(r.id)}">Avaa</button>
                        </div>
                      </div>
                    `;
                  }).join("")}
                  ${unpaidRows.length === 0 ? `<div class="muted">Ei maksamattomia.</div>` : ``}
                </div>
              </div>
            </div>
          </div>
        `;

        $("#dashNewRow", root).addEventListener("click", () => openNewRowModal());
        $("#dashRefresh", root).addEventListener("click", () => ensureLoaded());

        $$('[data-approve-row]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-row');
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            modalConfirm("Hyväksy lisätty rivi", "Valitse kausimaksun tila:", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Maksamaton", kind: "primary", onPress: () => approvePendingRow(row, false) },
              { text: "Maksettu", kind: "primary", onPress: () => approvePendingRow(row, true) },
            ]);
          });
        });
        $$('[data-approve-customer]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-customer');
            const customer = (state.data.customers || []).find((c) => String(c.id) === String(id));
            if (!customer) return;
            approvePendingCustomer(customer);
          });
        });

        $$('[data-row-open]', root).forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-row-open");
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            openRowDetailsModal(row);
          });
        });
      }
      function renderWorklist() {
        const rows = state.data.tires || [];
        const customers = state.data.customers || [];
        const today = todayStrLocal();
        const pickupWindowDays = 7;
        const pickupWindowEnd = addDaysIso(today, pickupWindowDays);
        const pickupsToday = rows.filter((r) => !r.deleted && String(r.status || "").trim().toLowerCase() !== "luovutettu" && (r.pickup_date || "") === today);
        const pickupsNext = rows
          .filter((r) => {
            if (r.deleted || String(r.status || "").trim().toLowerCase() === "luovutettu") return false;
            const p = String(r.pickup_date || "");
            return p > today && p <= pickupWindowEnd;
          })
          .sort((a, b) => String(a.pickup_date || "").localeCompare(String(b.pickup_date || "")));
        const pendingApprovalRows = rows.filter((r) => isPendingRowApproval(r));
        const activeRowCustomerKeys = new Set(rows.filter((r) => !r?.deleted).map((r) => normalizeNameKey(r?.customer)).filter(Boolean));
        const pendingCustomerApprovals = (customers || []).filter((c) => {
          if (!isPendingCustomerApproval(c)) return false;
          const key = normalizeNameKey(c?.nimi || c?.customer);
          if (!key) return true;
          return !activeRowCustomerKeys.has(key);
        });
        const unpaidRows = rows.filter((r) => !r.deleted && !isSeasonPaid(r.season_fee_paid) && String(r.status || "").trim().toLowerCase() !== "luovutettu");
        const missingLocationRows = rows.filter((r) => !r.deleted && String(r.status || "").trim().toLowerCase() !== "luovutettu" && !String(r.location || "").trim());
        const missingRequiredRows = rows.filter((r) => {
          if (r.deleted) return false;
          const statusLower = String(r.status || "").trim().toLowerCase();
          const locationRequired = !(statusLower === "luovutettu" || statusLower === "poistettu");
          if (!String(r.customer || "").trim()) return true;
          if (!String(r.phone || "").trim()) return true;
          if (!String(r.plate || "").trim()) return true;
          if (locationRequired && !String(r.location || "").trim()) return true;
          return false;
        });
        const deliveredRows = rows
          .filter((r) => {
            if (r.deleted) return false;
            const statusLower = String(r.status || "").trim().toLowerCase();
            return statusLower === "luovutettu" || !!String(r.out_date || "").trim();
          })
          .sort((a, b) => String(b.out_date || "").localeCompare(String(a.out_date || "")));

        const totalPending = pendingApprovalRows.length + pendingCustomerApprovals.length;
        const groupDefaultsCollapsed = {
          pending_rows: false,
          pending_customers: false,
          pickups_today: false,
          pickups_next: true,
          unpaid: true,
          missing_location: true,
          missing_required: true,
          delivered: true,
        };
        const groups = [
          { key: "pending_rows", title: "Odottaa vahvistusta (rivit)", type: "rows", data: pendingApprovalRows },
          { key: "pending_customers", title: "Odottaa vahvistusta (asiakkaat)", type: "customers", data: pendingCustomerApprovals },
          { key: "pickups_today", title: "Noudot tänään", type: "rows", data: pickupsToday },
          { key: "pickups_next", title: `Noudot ${pickupWindowDays} vrk`, type: "rows", data: pickupsNext },
          { key: "unpaid", title: "Maksamattomat", type: "rows", data: unpaidRows },
          { key: "missing_location", title: "Puuttuu hyllypaikka", type: "rows", data: missingLocationRows },
          { key: "missing_required", title: "Puuttuu pakolliset tiedot", type: "rows", data: missingRequiredRows },
          { key: "delivered", title: "Luovutettu", type: "rows", data: deliveredRows },
        ];

        const renderRowCard = (r, opts = {}) => {
          const statusLower = String(r.status || "").trim().toLowerCase();
          const isWaiting = r.waiting_pickup || statusLower === "odottaa noutoa";
          const isWorking = r.working || statusLower === "työn alla";
          const meta = getStatusMeta(r.status, { isWaiting, isWorking });
          const paid = isSeasonPaid(r.season_fee_paid);
          const locationLabel = prettyLocation(r.location);
          const pickupLabel = r.pickup_date ? formatDateOnlyFinnish(r.pickup_date, "") : "";
          const deliveredLabel = r.out_date ? formatDateOnlyFinnish(r.out_date, "") : "";
          const showPickup = statusLower === "luovutettu" || !!pickupLabel;
          const pickupText = statusLower === "luovutettu" ? (deliveredLabel ? `Luovutettu: ${deliveredLabel}` : "Luovutettu") : `Nouto: ${pickupLabel}`;
          const inLabel = r.in_date ? formatDateOnlyFinnish(r.in_date, "—") : "—";
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(prettyPlate(r.plate))} · ${escapeHtml(r.customer || "—")}</div>
                <div class="meta">Paikka: ${escapeHtml(locationLabel)}</div>
                <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                  <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                  <span class="pill" style="background:${paid ? "#eaf7ef" : "#fff3f4"};border-color:${paid ? "#c8e6d3" : "#f3cdd2"};color:${paid ? "#1f6f4a" : "#9f1239"}">${paid ? "Kausimaksu maksettu" : "Kausimaksu maksamatta"}</span>
                  ${showPickup ? `<span class="pill">${escapeHtml(pickupText)}</span>` : ``}
                  <span class="pill">Sisään: ${escapeHtml(inLabel)}</span>
                  ${opts?.pending ? `<span class="pill">Odottaa admin-hyväksyntää</span>` : ``}
                  ${opts?.missingRequired ? `<span class="pill" style="background:#fff7ed;border-color:#fed7aa;color:#9a3412">Täydennä tiedot</span>` : ``}
                </div>
              </div>
              <div class="actions">
                ${opts?.approveBtn || ""}
                <button class="btn ghost" data-row-open="${escapeHtml(r.id)}">Avaa</button>
              </div>
            </div>
          `;
        };

        const renderCustomerCard = (c) => {
          const name = c.nimi || c.customer || "—";
          const phone = c.puhelin || c.phone || "";
          const email = c.sahkoposti || c.email || "";
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(name)}</div>
                <div class="meta">${escapeHtml(phone)} ${email ? "· " + escapeHtml(email) : ""}</div>
                <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                  <span class="pill">Odotottaa admin-hyväksyntää</span>
                </div>
              </div>
              <div class="actions">
                ${isAdminRole(state.session.role) ? `<button class="btn primary" data-approve-customer="${escapeHtml(c.id)}">Hyväksy</button>` : ``}
              </div>
            </div>
          `;
        };

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Työlista</h1>
                <p class="p">Tärkeimmät: noudot, maksut, puuttuvat tiedot ja vahvistukset.</p>
              </div>
              <span class="pill">Rivit: ${rows.length}</span>
            </div>
            <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap;">
              <span class="pill">Noudot tänään: ${pickupsToday.length}</span>
              <span class="pill">Noudot ${pickupWindowDays} vrk: ${pickupsNext.length}</span>
              <span class="pill" style="background:#fff3f4;border-color:#fbcfe8;color:#9f1239">Maksamattomat: ${unpaidRows.length}</span>
              <span class="pill">Puuttuu paikka: ${missingLocationRows.length}</span>
              <span class="pill" style="background:#fff7ed;border-color:#fed7aa;color:#9a3412">Vahvistukset: ${totalPending}</span>
            </div>
            <div class="btn-row" style="margin-top: 10px;">
              <button class="btn ghost" id="wlRefresh">Päivitä</button>
            </div>
          </div>

          ${groups.map((g) => {
            const collapsed = state.ui.worklistCollapsed[g.key] === undefined ? !!groupDefaultsCollapsed[g.key] : !!state.ui.worklistCollapsed[g.key];
            const arrow = collapsed ? "▾" : "▴";
            return `
              <div class="card pad" style="margin-top: 12px;">
                <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px; cursor:pointer;" data-wl-toggle="${escapeHtml(g.key)}">
                  <div style="font-weight:900">${arrow} ${escapeHtml(g.title)}</div>
                  <span class="pill">${g.data.length}</span>
                </div>
                ${collapsed ? `` : `
                  <div class="divider"></div>
                  <div class="list">
                    ${g.data.length === 0 ? `<div class="muted">Ei rivejä.</div>` : ``}
                    ${g.type === "customers" ? g.data.map((c) => renderCustomerCard(c)).join("") : g.data.map((r) => {
                      if (g.key === "pending_rows") {
                        const approveBtn = isAdminRole(state.session.role) ? `<button class="btn primary" data-approve-row="${escapeHtml(r.id)}">Hyväksy</button>` : ``;
                        return renderRowCard(r, { pending: true, approveBtn });
                      }
                      if (g.key === "missing_required") return renderRowCard(r, { missingRequired: true });
                      return renderRowCard(r, {});
                    }).join("")}
                  </div>
                `}
              </div>
            `;
          }).join("")}
        `;

        $("#wlRefresh", root).addEventListener("click", () => ensureLoaded());

        $$("[data-wl-toggle]", root).forEach((el) => {
          el.addEventListener("click", () => {
            const key = el.getAttribute("data-wl-toggle");
            if (!key) return;
            const curr = state.ui.worklistCollapsed[key] === undefined ? !!groupDefaultsCollapsed[key] : !!state.ui.worklistCollapsed[key];
            state.ui.worklistCollapsed[key] = !curr;
            render();
          });
        });

        $$('[data-approve-row]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-row');
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            modalConfirm("Hyväksy lisätty rivi", "Valitse kausimaksun tila:", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Maksamaton", kind: "primary", onPress: () => approvePendingRow(row, false) },
              { text: "Maksettu", kind: "primary", onPress: () => approvePendingRow(row, true) },
            ]);
          });
        });
        $$('[data-approve-customer]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-approve-customer');
            const customer = (state.data.customers || []).find((c) => String(c.id) === String(id));
            if (!customer) return;
            approvePendingCustomer(customer);
          });
        });
        $$('[data-row-open]', root).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-row-open');
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            openRowDetailsModal(row);
          });
        });
      }

      function renderCustomers() {
        const customers = state.data.customers || [];
        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Asiakkaat</h1>
                <p class="p">Lista ei sisällä poistettuja (soft).</p>
              </div>
              <span class="pill">Yhteensä: ${customers.length}</span>
            </div>
            <div class="btn-row">
              <button class="btn ghost" id="custRefresh">Päivitä</button>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div class="field" style="margin:0">
              <div class="label">Hae</div>
              <input id="custSearch" placeholder="Nimi / puhelin / sähköposti" />
            </div>
            <div class="divider"></div>
            <div class="list" id="custList"></div>
          </div>
        `;

        $("#custRefresh", root).addEventListener("click", () => loadCustomers());
        const list = $("#custList", root);
        const search = $("#custSearch", root);

        const renderList = () => {
          const q = String(search.value || "").trim().toLowerCase();
          const filtered = !q ? customers : customers.filter((c) => {
            const name = String(c.nimi || c.customer || "").toLowerCase();
            const phone = String(c.puhelin || c.phone || "").toLowerCase();
            const email = String(c.sahkoposti || c.email || "").toLowerCase();
            return name.includes(q) || phone.includes(q) || email.includes(q);
          });

           list.innerHTML = (filtered.map((c) => {
             const name = c.nimi || c.customer || "—";
             const phone = c.puhelin || c.phone || "";
             const email = c.sahkoposti || c.email || "";
             const pending = isPendingCustomerApproval(c);
             return `
               <div class="item">
                 <div class="main">
                   <div class="title">${escapeHtml(name)}</div>
                   <div class="meta">${escapeHtml(phone)} ${email ? "· " + escapeHtml(email) : ""}</div>
                   <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                     ${pending ? `<span class="pill">Odottaa admin-hyväksyntää</span>` : ``}
                     <span class="pill">Luonut: ${escapeHtml(formatActor(c.created_by_name || c.luonut_nimi, c.created_by_role || c.luonut_rooli))}</span>
                     <span class="pill">Päivitetty: ${escapeHtml(formatActor(c.updated_by_name || c.paivittanyt_nimi, c.updated_by_role || c.paivittanyt_rooli))}</span>
                   </div>
                 </div>
                 <div class="actions">
                   <button class="btn ghost" data-cust-open="${escapeHtml(c.id)}">Avaa</button>
                   ${isAdminRole(state.session.role) ? `
                     <div class="menu" data-cust-menu="${escapeHtml(c.id)}">
                       <button class="btn danger" data-cust-menu-btn="${escapeHtml(c.id)}">Poista</button>
                       <div class="menu-pop" data-cust-menu-pop="${escapeHtml(c.id)}">
                         <button class="danger" data-cust-soft="${escapeHtml(c.id)}">Poista</button>
                         <button class="danger" data-cust-hard="${escapeHtml(c.id)}">Poista pysyvästi</button>
                       </div>
                     </div>
                   ` : ``}
                 </div>
               </div>
             `;
           }).join("")) || `<div class="muted">Ei asiakkaita.</div>`;

           $$('[data-cust-open]', list).forEach((btn) => {
             btn.addEventListener('click', () => {
               const id = btn.getAttribute('data-cust-open');
               const c = customers.find((x) => String(x.id) === String(id));
               if (!c) return;
               openCustomerDetailsModal(c);
             });
           });

           $$('[data-cust-menu-btn]', list).forEach((btn) => {
             btn.addEventListener('click', () => {
               const id = btn.getAttribute('data-cust-menu-btn');
               const pop = $(`[data-cust-menu-pop="${CSS.escape(id)}"]`, list);
               if (!pop) return;
               pop.classList.toggle("open");
             });
           });

           $$('[data-cust-soft]', list).forEach((btn) => {
             btn.addEventListener('click', () => {
               const id = btn.getAttribute('data-cust-soft');
               const c = customers.find((x) => String(x.id) === String(id));
               if (!c) return;
               modalConfirm("Poista asiakas", "Poistetaan asiakas ja renkaat (soft).", [
                 { text: "Peruuta", kind: "ghost" },
                 { text: "Poista", kind: "danger", onPress: () => softDeleteCustomer(c) },
               ]);
             });
           });
           $$('[data-cust-hard]', list).forEach((btn) => {
             btn.addEventListener('click', () => {
               const id = btn.getAttribute('data-cust-hard');
               const c = customers.find((x) => String(x.id) === String(id));
               if (!c) return;
               modalConfirm("Poista asiakas pysyvästi", "Poistetaan asiakas ja renkaat tietokannasta (HARD).", [
                 { text: "Peruuta", kind: "ghost" },
                 { text: "Poista pysyvästi", kind: "danger", onPress: () => hardDeleteCustomer(c) },
               ]);
             });
           });
         };

        search.addEventListener("input", renderList);
        renderList();
      }

      function openCustomerDetailsModal(customer) {
        const isAdmin = isAdminRole(state.session.role);
        const name = String(customer?.nimi || customer?.customer || "").trim();
        const phone = String(customer?.puhelin || customer?.phone || "").trim();
        const email = String(customer?.sahkoposti || customer?.email || "").trim();
        const creator = formatActor(customer?.created_by_name || customer?.luonut_nimi, customer?.created_by_role || customer?.luonut_rooli);
        const editor = formatActor(customer?.updated_by_name || customer?.paivittanyt_nimi, customer?.updated_by_role || customer?.paivittanyt_rooli);
        const key = normalizeNameKey(name);
        const relatedRows = (state.data.tires || []).filter((r) => !r?.deleted && normalizeNameKey(r?.customer) === key);

        const html = `
          <div class="msg">${isAdmin ? "Admin voi muokata asiakkaan tietoja. Muutos päivittää myös asiakkaan rivit." : "Staff: vain katselu."}</div>
          <div class="field">
            <div class="label">Nimi <span class="req">*</span></div>
            <input id="cdName" value="${escapeHtml(name)}" ${isAdmin ? "" : "readonly"} />
          </div>
          <div class="field">
            <div class="label">Puhelin <span class="req">*</span></div>
            <input id="cdPhone" value="${escapeHtml(phone)}" ${isAdmin ? "" : "readonly"} />
          </div>
          <div class="field">
            <div class="label">Sähköposti</div>
            <input id="cdEmail" value="${escapeHtml(email)}" ${isAdmin ? "" : "readonly"} />
          </div>
          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <span class="pill">Luonut: ${escapeHtml(creator)}</span>
            <span class="pill">Päivitetty: ${escapeHtml(editor)}</span>
          </div>

          <div class="divider"></div>
          <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
            <div style="font-weight:900">Rivit</div>
            <span class="pill">${relatedRows.length}</span>
          </div>
          <div class="list" style="margin-top:10px;">
            ${relatedRows.slice(0, 40).map((r) => {
              const statusLower = String(r.status || "").trim().toLowerCase();
              const isWaiting = r.waiting_pickup || statusLower === "odottaa noutoa";
              const isWorking = r.working || statusLower === "työn alla";
              const meta = getStatusMeta(r.status, { isWaiting, isWorking });
              return `
                <div class="item">
                  <div class="main">
                    <div class="title">${escapeHtml(prettyPlate(r.plate))}</div>
                    <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))}</div>
                    <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                      <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                      <span class="pill" style="background:${isSeasonPaid(r.season_fee_paid) ? "#eaf7ef" : "#fff3f4"};border-color:${isSeasonPaid(r.season_fee_paid) ? "#c8e6d3" : "#f3cdd2"};color:${isSeasonPaid(r.season_fee_paid) ? "#1f6f4a" : "#9f1239"}">
                        ${isSeasonPaid(r.season_fee_paid) ? "Kausimaksu maksettu" : "Kausimaksu maksamatta"}
                      </span>
                    </div>
                  </div>
                  <div class="actions">
                    <button class="btn ghost" data-cd-row-open="${escapeHtml(r.id)}" type="button">Avaa</button>
                  </div>
                </div>
              `;
            }).join("")}
            ${relatedRows.length === 0 ? `<div class="muted">Ei rivejä tälle asiakkaalle.</div>` : ``}
          </div>

          <div class="btn-row" style="justify-content:flex-end; margin-top: 12px;">
            <button class="btn ghost" id="cdClose" type="button">Sulje</button>
            ${isAdmin ? `<button class="btn primary" id="cdSave" type="button">Tallenna</button>` : ``}
          </div>
        `;
        openModal("Asiakas", html);

        $$('[data-cd-row-open]', modalBody).forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-cd-row-open");
            const row = (state.data.tires || []).find((r) => String(r.id) === String(id));
            if (!row) return;
            closeModal();
            openRowDetailsModal(row);
          });
        });

        $("#cdClose", modalBody).addEventListener("click", closeModal);
        const save = $("#cdSave", modalBody);
        if (!save) return;
        save.addEventListener("click", async () => {
          const nextName = String($("#cdName", modalBody).value || "").trim();
          const nextPhone = String($("#cdPhone", modalBody).value || "").trim();
          const nextEmail = String($("#cdEmail", modalBody).value || "").trim();
          if (!nextName || !nextPhone) {
            toast("error", "Virhe", "Täytä pakolliset kentät: Nimi ja puhelin.");
            return;
          }
          const patch = {};
          if (nextName !== name) patch.nimi = nextName;
          if (nextPhone !== phone) patch.puhelin = nextPhone;
          if (nextEmail !== email) patch.sahkoposti = nextEmail || null;
          closeModal();
          try {
            if (Object.keys(patch).length) {
              await api.updateCustomer(customer.id, patch);
              // Cascade: update all active tire rows for this customer name
              const targets = (state.data.tires || []).filter((r) => !r?.deleted && normalizeNameKey(r?.customer) === key);
              const failures = [];
              for (const r of targets) {
                const tirePatch = {};
                if (nextName !== name) tirePatch.customer = nextName;
                if (nextPhone !== phone) tirePatch.phone = nextPhone;
                if (nextEmail !== email) tirePatch.tire_size = nextEmail || null;
                if (Object.keys(tirePatch).length === 0) continue;
                try {
                  await api.updateTire(r.id, r.rev, tirePatch);
                } catch (e) {
                  failures.push({ id: r.id, message: String(e?.message || "") });
                }
              }
              await ensureLoaded();
              await loadCustomers();
              if (failures.length) {
                toast("warning", "Ilmoitus", `Tallennettu, mutta ${failures.length} rivin päivitys epäonnistui (konflikti). Päivitä ja yritä tarvittaessa uudelleen.`);
              } else {
                toast("success", "Ilmoitus", "Tallennettu.");
              }
            }
          } catch (e) {
            toast("error", "Virhe", e?.message || "Tallennus epäonnistui.");
          }
        });
      }

      function openNewRowModal() {
        const canManageSeasonFee = isAdminRole(state.session.role);
        const html = `
          <div class="msg">Lisää uusi rivi. Staff: kausimaksu ei valittavissa ja merkintä menee odottamaan admin-hyväksyntää.</div>
          <div class="field">
            <div class="label">Asiakkaan nimi <span class="req">*</span></div>
            <input id="nrName" />
            <div id="nrCustHint" style="margin-top:6px;"></div>
          </div>
          <div class="field">
            <div class="label">Puhelinnumero <span class="req">*</span></div>
            <input id="nrPhone" />
          </div>
          <div class="field">
            <div class="label">Sähköposti</div>
            <input id="nrEmail" />
          </div>
          <div class="field">
            <div class="label">Rekisterinumero <span class="req">*</span></div>
            <input id="nrPlate" />
            <div class="p danger-text" id="nrDup" style="display:none;margin:0"></div>
          </div>
           <div class="field">
             <div class="label">Hyllypaikka <span class="req">*</span></div>
             <input id="nrLoc" placeholder="esim. H01-A-01" />
           </div>
           <div class="field">
             <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
               <div class="label">Vapaat hyllypaikat</div>
               <button class="btn ghost" id="nrFreeRefresh" type="button">Päivitä</button>
             </div>
             <input id="nrFreeSearch" placeholder="Hae vapaa paikka (esim. 1A1)" />
             <div class="list" id="nrFreeList" style="margin-top:8px; max-height: 220px; overflow:auto;"></div>
             <div class="p" id="nrFreeMeta" style="margin:0"></div>
           </div>
           <div class="field">
             <div class="label">Huomiot</div>
             <textarea id="nrNotes"></textarea>
          </div>
          <div class="field" ${canManageSeasonFee ? "" : "style='opacity:0.6'"}>
            <div class="label">Kausimaksu</div>
            <select id="nrSeason" ${canManageSeasonFee ? "" : "disabled"}>
              <option value="false">Maksamaton</option>
              <option value="true">Maksettu</option>
            </select>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="nrCancel">Peruuta</button>
            <button class="btn primary" id="nrSave">Tallenna</button>
          </div>
        `;

        openModal("Uusi rivi", html);

        const nameEl = $("#nrName", modalBody);
         const phoneEl = $("#nrPhone", modalBody);
         const emailEl = $("#nrEmail", modalBody);
         const locEl = $("#nrLoc", modalBody);
         const custHint = $("#nrCustHint", modalBody);
         const freeSearch = $("#nrFreeSearch", modalBody);
         const freeList = $("#nrFreeList", modalBody);
         const freeMeta = $("#nrFreeMeta", modalBody);
         const freeRefreshBtn = $("#nrFreeRefresh", modalBody);

        const plate = $("#nrPlate", modalBody);
        const dup = $("#nrDup", modalBody);
        let dupTimer = null;
        let custTimer = null;
        let lastCustomerKey = "";

         let freeItems = [];
         function renderFreeLocationsList() {
           const q = String(freeSearch.value || "").trim().toLowerCase();
           const filtered = !q ? freeItems : freeItems.filter((r) => {
             const code = String(r?.code || r?.hyllypaikka || r?.location || "").trim();
             const label = String(r?.label || r?.nimi || r?.name || code).trim();
             const hay = `${code} ${label}`.toLowerCase();
             return hay.includes(q);
           });
           const max = 18;
           const visible = filtered.slice(0, max);
           freeList.innerHTML = visible.length
             ? visible.map((r) => {
               const code = String(r?.code || r?.hyllypaikka || r?.location || "").trim();
               const label = String(r?.label || r?.nimi || r?.name || code).trim() || code || "—";
               if (!code) return "";
               return `
                 <div class="item" style="cursor:pointer" data-free-loc="${escapeHtml(code)}">
                   <div class="main">
                     <div class="title">${escapeHtml(label)}</div>
                     <div class="meta">${escapeHtml(code)}</div>
                   </div>
                   <div class="actions"><span class="pill">Valitse</span></div>
                 </div>
               `;
             }).join("")
             : `<div class="muted">Ei osumia.</div>`;
           $$("[data-free-loc]", freeList).forEach((el) => {
             el.addEventListener("click", () => {
               const code = el.getAttribute("data-free-loc");
               if (code) locEl.value = code;
             });
           });
         }

         async function refreshFreeLocations() {
           freeRefreshBtn.disabled = true;
           freeList.innerHTML = `<div class="muted">Haetaan...</div>`;
           freeMeta.textContent = "";
           try {
             const rows = await api.listFreeLocations(state.session.hotelCode);
             const items = Array.isArray(rows) ? rows : [];
             freeItems = items;
             freeMeta.textContent = items.length ? `${items.length} vapaata` : "Ei vapaita paikkoja";
             renderFreeLocationsList();

             const firstCode = items
               .map((r) => String(r?.code || r?.hyllypaikka || r?.location || "").trim())
               .find((v) => !!v);
             if (!String(locEl.value || "").trim() && firstCode) {
               // täytä ensimmäinen ehdotus automaattisesti, jos kenttä tyhjä
               locEl.value = firstCode;
             }
           } catch (e) {
             freeList.innerHTML = `<div class="muted">(Haku epäonnistui)</div>`;
             freeMeta.textContent = e?.message ? String(e.message) : "Haku epäonnistui";
           } finally {
             freeRefreshBtn.disabled = false;
           }
         }

         freeRefreshBtn.addEventListener("click", () => refreshFreeLocations());
         freeSearch.addEventListener("input", () => renderFreeLocationsList());
         refreshFreeLocations();

        function renderCustomerHint(customerRow) {
          if (!customerRow) {
            custHint.innerHTML = "";
            return;
          }
          const p = String(customerRow?.puhelin || customerRow?.phone || "").trim();
          const e = String(customerRow?.sahkoposti || customerRow?.email || "").trim();
          const hasData = !!(p || e);
          const detailParts = [];
          if (p) detailParts.push(escapeHtml(p));
          if (e) detailParts.push(escapeHtml(e));
          const detailText = hasData ? `: ${detailParts.join(" · ")}` : ".";
          const fillable = (p && !String(phoneEl.value || "").trim()) || (e && !String(emailEl.value || "").trim());
          custHint.innerHTML = `
            <div class=\"p\" style=\"margin:0\">Asiakas löytyy rekisteristä${detailText}</div>
            <div class="btn-row" style="margin-top:8px; justify-content:flex-end;">
              <button class="btn ghost" id="nrCustNo" type="button">Ei nyt</button>
              <button class="btn primary" id="nrCustFill" type="button" ${fillable ? "" : "disabled"}>Täytä</button>
            </div>
          `;
          $("#nrCustNo", modalBody).addEventListener("click", () => {
            custHint.innerHTML = "";
          });
          $("#nrCustFill", modalBody).addEventListener("click", () => {
            if (p && !String(phoneEl.value || "").trim()) phoneEl.value = p;
            if (e && !String(emailEl.value || "").trim()) emailEl.value = e;
            custHint.innerHTML = "";
          });
        }

        nameEl.addEventListener("input", () => {
          const key = String(nameEl.value || "").trim();
          if (!key) {
            lastCustomerKey = "";
            custHint.innerHTML = "";
            clearTimeout(custTimer);
            return;
          }
          if (key === lastCustomerKey) return;
          clearTimeout(custTimer);
          custTimer = setTimeout(async () => {
            const curr = String(nameEl.value || "").trim();
            if (!curr || curr === lastCustomerKey) return;
            lastCustomerKey = curr;
            try {
              const found = await api.getCustomerByName(state.session.hotelCode, curr);
              if (found) renderCustomerHint(found);
              else custHint.innerHTML = "";
            } catch {
              // ignore
            }
          }, 300);
        });

        plate.addEventListener("input", () => {
          const v = String(plate.value || "").trim();
          clearTimeout(dupTimer);
          if (!v) {
            dup.style.display = "none";
            dup.textContent = "";
            return;
          }
          dupTimer = setTimeout(async () => {
            try {
              const found = await api.findActiveTireByPlate(state.session.hotelCode, v);
              if (found) {
                dup.textContent = formatPlateDuplicateMessage(v, found);
                dup.style.display = "";
              } else {
                dup.style.display = "none";
                dup.textContent = "";
              }
            } catch {
              // ignore
            }
          }, 350);
        });

        $("#nrCancel", modalBody).addEventListener("click", closeModal);
        $("#nrSave", modalBody).addEventListener("click", async () => {
          const form = {
            customer: nameEl.value,
            phone: phoneEl.value,
            email: emailEl.value,
            plate: $("#nrPlate", modalBody).value,
            location: locEl.value,
            notes: $("#nrNotes", modalBody).value,
            season_fee_paid: $("#nrSeason", modalBody).value === "true",
          };

          try {
            const found = await api.findActiveTireByPlate(state.session.hotelCode, form.plate);
            if (found) {
              toast("error", "Virhe", formatPlateDuplicateMessage(form.plate, found));
              return;
            }
          } catch {
            // ignore
          }

          closeModal();
          await addNewRow(form);
        });

        setTimeout(() => nameEl.focus(), 0);
      }

      function openRowEditModal(row) {
        if (!row) return;
        const isAdmin = isAdminRole(state.session.role);
        if (!isAdmin) return toast("error", "Virhe", "Ei oikeuksia.");

        const statusRaw = String(row.status || "Varastossa").trim() || "Varastossa";
        const statusLower = statusRaw.toLowerCase();
        const locationRequired = !(statusLower === "luovutettu" || statusLower === "poistettu");

        const html = `
          <div class="msg">Muokkaa rivin tietoja. Pakolliset: nimi, puhelin, rekisteri${locationRequired ? ", hyllypaikka" : ""}.</div>
          <div class="row">
            <div class="col" style="min-width:240px">
              <div class="field" style="margin-top:10px">
                <div class="label">Asiakas <span class="req">*</span></div>
                <input id="reName" value="${escapeHtml(String(row.customer || ""))}" />
              </div>
            </div>
            <div class="col" style="min-width:240px">
              <div class="field" style="margin-top:10px">
                <div class="label">Puhelin <span class="req">*</span></div>
                <input id="rePhone" value="${escapeHtml(String(row.phone || ""))}" />
              </div>
            </div>
          </div>
          <div class="row">
            <div class="col" style="min-width:240px">
              <div class="field" style="margin-top:10px">
                <div class="label">Rekisteri <span class="req">*</span></div>
                <input id="rePlate" value="${escapeHtml(String(row.plate || ""))}" />
                <div class="p danger-text" id="reDup" style="display:none;margin:0"></div>
              </div>
            </div>
            <div class="col" style="min-width:240px">
              <div class="field" style="margin-top:10px">
                <div class="label">Hyllypaikka ${locationRequired ? `<span class="req">*</span>` : ""}</div>
                <input id="reLoc" value="${escapeHtml(String(row.location || ""))}" placeholder="esim. H01-A-01" />
              </div>
            </div>
          </div>

          <div class="field">
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
              <div class="label">Vapaat hyllypaikat</div>
              <button class="btn ghost" id="reFreeRefresh" type="button">Päivitä</button>
            </div>
            <input id="reFreeSearch" placeholder="Hae vapaa paikka (esim. 1A1)" />
            <div class="list" id="reFreeList" style="margin-top:8px; max-height: 220px; overflow:auto;"></div>
            <div class="p" id="reFreeMeta" style="margin:0"></div>
          </div>

          <div class="row">
            <div class="col" style="min-width:220px">
              <div class="field" style="margin-top:10px">
                <div class="label">Tila</div>
                <select id="reStatus">
                  ${["Varastossa", "Työn alla", "Odottaa noutoa", "Luovutettu"].map((s) => `<option value="${escapeHtml(s)}" ${String(s).toLowerCase() === statusLower ? "selected" : ""}>${escapeHtml(s)}</option>`).join("")}
                </select>
              </div>
            </div>
            <div class="col" style="min-width:220px">
              <div class="field" style="margin-top:10px">
                <div class="label">Noutopäivä</div>
                <input id="rePickup" type="date" value="${escapeHtml(String(row.pickup_date || ""))}" />
              </div>
            </div>
            <div class="col" style="min-width:220px">
              <div class="field" style="margin-top:10px">
                <div class="label">Kausimaksu</div>
                <select id="reSeason">
                  <option value="false" ${isSeasonPaid(row.season_fee_paid) ? "" : "selected"}>Maksamaton</option>
                  <option value="true" ${isSeasonPaid(row.season_fee_paid) ? "selected" : ""}>Maksettu</option>
                </select>
              </div>
            </div>
          </div>

          <div class="field">
            <div class="label">Huomiot</div>
            <textarea id="reNotes">${escapeHtml(String(row.notes || ""))}</textarea>
          </div>

          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="reCancel" type="button">Peruuta</button>
            <button class="btn primary" id="reSave" type="button">Tallenna</button>
          </div>
        `;
        openModal("Muokkaa riviä", html);

        const nameEl = $("#reName", modalBody);
        const phoneEl = $("#rePhone", modalBody);
        const plateEl = $("#rePlate", modalBody);
        const locEl = $("#reLoc", modalBody);
        const dup = $("#reDup", modalBody);
        const freeRefreshBtn = $("#reFreeRefresh", modalBody);
        const freeSearch = $("#reFreeSearch", modalBody);
        const freeList = $("#reFreeList", modalBody);
        const freeMeta = $("#reFreeMeta", modalBody);
        let freeItems = [];
        let dupTimer = null;

        function renderFreeLocationsList() {
          const q = String(freeSearch.value || "").trim().toLowerCase();
          const filtered = !q ? freeItems : freeItems.filter((r) => {
            const code = String(r?.code || r?.hyllypaikka || r?.location || "").trim();
            const label = String(r?.label || r?.nimi || r?.name || code).trim();
            const hay = `${code} ${label}`.toLowerCase();
            return hay.includes(q);
          });
          const max = 18;
          const visible = filtered.slice(0, max);
          freeList.innerHTML = visible.length
            ? visible.map((r) => {
              const code = String(r?.code || r?.hyllypaikka || r?.location || "").trim();
              const label = String(r?.label || r?.nimi || r?.name || code).trim() || code || "—";
              if (!code) return "";
              return `
                <div class="item" style="cursor:pointer" data-free-loc="${escapeHtml(code)}">
                  <div class="main">
                    <div class="title">${escapeHtml(label)}</div>
                    <div class="meta">${escapeHtml(code)}</div>
                  </div>
                  <div class="actions"><span class="pill">Valitse</span></div>
                </div>
              `;
            }).join("")
            : `<div class="muted">Ei osumia.</div>`;
          $$("[data-free-loc]", freeList).forEach((el) => {
            el.addEventListener("click", () => {
              const code = el.getAttribute("data-free-loc");
              if (code) locEl.value = code;
            });
          });
        }

        async function refreshFreeLocations() {
          freeRefreshBtn.disabled = true;
          freeList.innerHTML = `<div class="muted">Haetaan...</div>`;
          freeMeta.textContent = "";
          try {
            const rows = await api.listFreeLocations(state.session.hotelCode);
            const items = Array.isArray(rows) ? rows : [];
            freeItems = items;
            freeMeta.textContent = items.length ? `${items.length} vapaata` : "Ei vapaita paikkoja";
            renderFreeLocationsList();
          } catch (e) {
            freeList.innerHTML = `<div class="muted">(Haku epäonnistui)</div>`;
            freeMeta.textContent = e?.message ? String(e.message) : "Haku epäonnistui";
          } finally {
            freeRefreshBtn.disabled = false;
          }
        }

        freeRefreshBtn.addEventListener("click", () => refreshFreeLocations());
        freeSearch.addEventListener("input", () => renderFreeLocationsList());
        refreshFreeLocations();

        plateEl.addEventListener("input", () => {
          const v = String(plateEl.value || "").trim();
          clearTimeout(dupTimer);
          if (!v) {
            dup.style.display = "none";
            dup.textContent = "";
            return;
          }
          dupTimer = setTimeout(async () => {
            try {
              const found = await api.findActiveTireByPlate(state.session.hotelCode, v, row.id);
              if (found) {
                dup.textContent = formatPlateDuplicateMessage(v, found);
                dup.style.display = "";
              } else {
                dup.style.display = "none";
                dup.textContent = "";
              }
            } catch {
              // ignore
            }
          }, 350);
        });

        $("#reCancel", modalBody).addEventListener("click", closeModal);
        $("#reSave", modalBody).addEventListener("click", async () => {
          const next = {
            customer: String(nameEl.value || "").trim(),
            phone: String(phoneEl.value || "").trim(),
            plate: String(plateEl.value || "").trim(),
            location: String(locEl.value || "").trim() || null,
            status: String($("#reStatus", modalBody).value || "").trim() || "Varastossa",
            pickup_date: String($("#rePickup", modalBody).value || "").trim() || null,
            season_fee_paid: $("#reSeason", modalBody).value === "true",
            notes: String($("#reNotes", modalBody).value || "").trim() || null,
          };
          const nextStatusLower = next.status.toLowerCase();
          const nextLocationRequired = !(nextStatusLower === "luovutettu" || nextStatusLower === "poistettu");
          if (!next.customer || !next.phone || !next.plate || (nextLocationRequired && !String(next.location || "").trim())) {
            toast("error", "Virhe", "Täytä pakolliset kentät.");
            return;
          }

          try {
            if (normalizePlate(next.plate) !== normalizePlate(row.plate)) {
              const found = await api.findActiveTireByPlate(state.session.hotelCode, next.plate, row.id);
              if (found) {
                toast("error", "Virhe", formatPlateDuplicateMessage(next.plate, found));
                return;
              }
            }
          } catch {
            // ignore
          }

          const patch = {};
          if (next.customer !== String(row.customer || "").trim()) patch.customer = next.customer;
          if (next.phone !== String(row.phone || "").trim()) patch.phone = next.phone;
          if (normalizePlate(next.plate) !== normalizePlate(row.plate)) patch.plate = next.plate;
          if (String(next.location || "") !== String(row.location || "")) patch.location = next.location;
          if (String(next.pickup_date || "") !== String(row.pickup_date || "")) patch.pickup_date = next.pickup_date;
          if (!!next.season_fee_paid !== isSeasonPaid(row.season_fee_paid)) patch.season_fee_paid = next.season_fee_paid;
          if (String(next.notes || "") !== String(row.notes || "")) patch.notes = next.notes;
          if (String(next.status || "") !== String(row.status || "")) {
            patch.status = next.status;
            patch.waiting_pickup = nextStatusLower === "odottaa noutoa";
            patch.working = nextStatusLower === "työn alla";
          }

          // Mark delivered: set out_date + free shelf
          if (nextStatusLower === "luovutettu" && !String(row.out_date || "").trim()) {
            patch.out_date = todayStrLocal();
            patch.last_location = row.location || row.last_location || null;
            patch.location = null;
            patch.waiting_pickup = false;
            patch.working = false;
          }

          if (Object.keys(patch).length === 0) {
            closeModal();
            return;
          }
          closeModal();
          try {
            await api.updateTire(row.id, row.rev, patch);
            await loadTires();
            toast("success", "Ilmoitus", "Tallennettu.");
          } catch (e) {
            toast("error", "Virhe", e?.message || "Tallennus epäonnistui.");
          }
        });
      }

      function openRowDetailsModal(row) {
        const isAdmin = isAdminRole(state.session.role);
        const meta = getStatusMeta(row.status, { isWaiting: row.waiting_pickup, isWorking: row.working });
        const statusLower = String(row?.status || "").trim().toLowerCase();
        const isDelivered = statusLower === "luovutettu";
        const season = isSeasonPaid(row.season_fee_paid)
          ? { t: "Maksettu", bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" }
          : { t: "Maksamaton", bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
        const pending = isPendingRowApproval(row);
        const deliveredAt = row?.out_date ? formatDateOnlyFinnish(row.out_date, "") : "";
        const deliveredBy = formatActor(row?.delivered_by_name ?? row?.updated_by_name, row?.delivered_by_role ?? row?.updated_by_role);
        const deliveredInfo = deliveredAt ? (deliveredBy && deliveredBy !== "—" ? `${deliveredAt} · ${deliveredBy}` : deliveredAt) : deliveredBy;

        const html = `
          <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
            <div>
              <div style="font-weight:900; font-size:16px;">${escapeHtml(row.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(row.plate))}</span></div>
              <div class="p" style="margin-top:4px;">${escapeHtml(row.phone || "")} ${row.tire_size ? "· " + escapeHtml(row.tire_size) : ""}</div>
            </div>
            <div style="display:flex; gap: 8px; align-items:flex-start;">
              ${isAdmin ? `<button class="btn ghost" id="rdEdit" type="button">Muokkaa</button>` : ``}
              <div class="menu" data-row-menu>
                ${isAdmin ? `<button class="btn danger" data-row-menu-btn type="button">Poista...</button>` : ``}
                <div class="menu-pop" id="rowMenuPop">
                  <button class="danger" id="rowSoftDel" type="button">Poista</button>
                  <button class="danger" id="rowHardDel" type="button">Poista pysyvästi</button>
                </div>
              </div>
            </div>
          </div>

          <div style="margin-top:10px; display:flex; gap:6px; flex-wrap:wrap;">
            <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
            <span class="pill" style="background:${season.bg};border-color:${season.border};color:${season.color}">${escapeHtml(season.t)}</span>
            ${pending ? `<span class="pill">Odottaa vahvistusta</span>` : ``}
          </div>

          ${isAdmin ? `
            <div class="btn-row" style="margin-top:10px; flex-wrap:wrap;">
              ${isDelivered ? `
                <button class="btn primary" id="rdTakeIn" type="button">Ota sisään</button>
              ` : `
                <button class="btn ghost" id="rdTogglePaid" type="button" ${pending ? "disabled" : ""}>${isSeasonPaid(row.season_fee_paid) ? "Merkitse maksamattomaksi" : "Peri kausimaksu"}</button>
                <button class="btn ghost" id="rdPickupToday" type="button" ${pending ? "disabled" : ""}>${String(row.pickup_date || "") === todayStrLocal() ? "Nouto tänään (asetettu)" : "Nouto tänään"}</button>
                <button class="btn ghost" id="rdClearPickup" type="button" ${pending ? "disabled" : ""}>Peru nouto</button>
                <button class="btn primary" id="rdDeliver" type="button" ${pending ? "disabled" : ""}>Luovuta</button>
              `}
            </div>
            ${pending ? `<div class="p danger-text" style="margin-top:6px;">Rivi odottaa admin-vahvistusta. Pikatoiminnot eivät ole käytössä.</div>` : ``}
          ` : ``}

          <div class="divider"></div>

          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
            <div class="field" style="flex:1; margin:0">
              <div class="label">Hyllypaikka</div>
              <input id="rdLoc" value="${escapeHtml(String(row.location || ""))}" />
            </div>
            <div style="margin-top: 18px;">
              <button class="btn ghost" id="rdLocSave" style="white-space:nowrap;">Muokkaa</button>
            </div>
          </div>
          <div class="p" style="margin-top: 6px;">${isAdmin ? "Admin voi muokata muitakin tietoja mobiilissa." : "Staff voi muokata vain hyllypaikkaa."}</div>

          <div class="divider"></div>

          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <span class="pill">Luonut: ${escapeHtml(formatActor(row.created_by_name, row.created_by_role))}</span>
            <span class="pill">Päivitetty: ${escapeHtml(formatActor(row.updated_by_name, row.updated_by_role))}</span>
            ${row?.out_date ? `<span class="pill">Luovutettu: ${escapeHtml(deliveredInfo)}</span>` : ``}
          </div>

          <div class="field">
            <div class="label">Huomiot</div>
            <textarea readonly>${escapeHtml(String(row.notes || ""))}</textarea>
          </div>

          ${isAdmin && pending ? `
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn primary" id="rdApprovePaid">Hyväksy (Maksettu)</button>
              <button class="btn primary" id="rdApproveUnpaid">Hyväksy (Maksamaton)</button>
            </div>
          ` : ``}
        `;

        openModal("Rivin tiedot", html);

        const menuBtn = $("[data-row-menu-btn]", modalBody);
        if (menuBtn) {
          const pop = $("#rowMenuPop", modalBody);
          menuBtn.addEventListener("click", () => pop.classList.toggle("open"));
          $("#rowSoftDel", modalBody).addEventListener("click", () => {
            pop.classList.remove("open");
            modalConfirm("Poista rivi", "Poistetaan rivi (soft).", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Poista", kind: "danger", onPress: () => { closeModal(); softDeleteRow(row); } },
            ]);
          });
          $("#rowHardDel", modalBody).addEventListener("click", () => {
            pop.classList.remove("open");
            modalConfirm("Poista rivi pysyvästi", "Poistetaan rivi tietokannasta (HARD).", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Poista pysyvästi", kind: "danger", onPress: () => { closeModal(); hardDeleteRow(row); } },
            ]);
          });
        }

        const editBtn = $("#rdEdit", modalBody);
        if (editBtn) {
          editBtn.addEventListener("click", () => {
            closeModal();
            openRowEditModal(row);
          });
        }

        $("#rdLocSave", modalBody).addEventListener("click", async () => {
          const next = $("#rdLoc", modalBody).value;
          closeModal();
          await updateRowLocation(row, next);
        });

        const btnTogglePaid = $("#rdTogglePaid", modalBody);
        if (btnTogglePaid) {
          btnTogglePaid.addEventListener("click", async () => {
            closeModal();
            try {
              await api.updateTire(row.id, row.rev, { season_fee_paid: !isSeasonPaid(row.season_fee_paid) });
              await loadTires();
              toast("success", "Ilmoitus", "Tallennettu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Tallennus epäonnistui.");
            }
          });
        }
        const btnTakeIn = $("#rdTakeIn", modalBody);
        if (btnTakeIn) {
          btnTakeIn.addEventListener("click", async () => {
            closeModal();
            await takeInDeliveredRow(row);
          });
        }
        const btnPickupToday = $("#rdPickupToday", modalBody);
        if (btnPickupToday) {
          btnPickupToday.addEventListener("click", async () => {
            closeModal();
            try {
              const today = todayStrLocal();
              const patch = {
                pickup_date: today,
                waiting_pickup: true,
                working: false,
                status: "Odottaa noutoa",
              };
              await api.updateTire(row.id, row.rev, patch);
              await loadTires();
              toast("success", "Ilmoitus", "Nouto asetettu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Päivitys epäonnistui.");
            }
          });
        }
        const btnClearPickup = $("#rdClearPickup", modalBody);
        if (btnClearPickup) {
          btnClearPickup.addEventListener("click", async () => {
            closeModal();
            try {
              const statusLower = String(row.status || "").trim().toLowerCase();
              const patch = { pickup_date: null, waiting_pickup: false, working: false };
              if (statusLower === "odottaa noutoa" || statusLower === "työn alla") patch.status = "Varastossa";
              await api.updateTire(row.id, row.rev, patch);
              await loadTires();
              toast("success", "Ilmoitus", "Nouto peruttu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Päivitys epäonnistui.");
            }
          });
        }
        const btnDeliver = $("#rdDeliver", modalBody);
        if (btnDeliver) {
          btnDeliver.addEventListener("click", async () => {
            closeModal();
            try {
              if (!isSeasonPaid(row.season_fee_paid)) {
                toast("error", "Virhe", "Kausimaksu maksamatta. Peri maksu ennen luovutusta.");
                return;
              }
              const patch = {
                status: "Luovutettu",
                out_date: todayStrLocal(),
                last_location: row.location || row.last_location || null,
                location: null,
                waiting_pickup: false,
                working: false,
              };
              await api.updateTire(row.id, row.rev, patch);
              await loadTires();
              toast("success", "Ilmoitus", "Luovutettu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Luovutus epäonnistui.");
            }
          });
        }

        if (isAdmin && pending) {
          const paid = $("#rdApprovePaid", modalBody);
          const unpaid = $("#rdApproveUnpaid", modalBody);
          if (paid) paid.addEventListener("click", () => { closeModal(); approvePendingRow(row, true); });
          if (unpaid) unpaid.addEventListener("click", () => { closeModal(); approvePendingRow(row, false); });
        }
      }

      function renderRows() {
        const tires = state.data.tires || [];
        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Rivit</h1>
                <p class="p">Staff voi muokata vain hyllypaikkaa. Admin voi hyväksyä ja poistaa.</p>
              </div>
              <span class="pill">Näytetään: ${tires.length}</span>
            </div>
            <div class="btn-row">
              <button class="btn primary" id="rowsNew">Uusi rivi</button>
              <button class="btn ghost" id="rowsRefresh">Päivitä</button>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div class="field" style="margin:0">
              <div class="label">Hae</div>
              <input id="rowsSearch" placeholder="Nimi / rek / paikka" />
            </div>
            <div class="divider"></div>
            <div class="list" id="rowsList"></div>
          </div>
        `;

        $("#rowsNew", root).addEventListener("click", () => openNewRowModal());
        $("#rowsRefresh", root).addEventListener("click", () => loadTires());

        const list = $("#rowsList", root);
        const search = $("#rowsSearch", root);

        const renderList = () => {
          const q = String(search.value || "").trim().toLowerCase();
          const filtered = !q ? tires : tires.filter((r) => {
            const name = String(r.customer || "").toLowerCase();
            const plate = String(r.plate || "").toLowerCase();
            const loc = String(r.location || "").toLowerCase();
            return name.includes(q) || plate.includes(q) || loc.includes(q);
          });

          list.innerHTML = (filtered.map((r) => {
            const meta = getStatusMeta(r.status, { isWaiting: r.waiting_pickup, isWorking: r.working });
            const pending = isPendingRowApproval(r);
            const season = isSeasonPaid(r.season_fee_paid)
              ? { t: "Maksettu", bg: "#eef4ff", border: "#c7d2fe", color: "#1e429f" }
              : { t: "Maksamaton", bg: "#fff7ed", border: "#fed7aa", color: "#9a3412" };
            return `
              <div class="item">
                <div class="main">
                  <div class="title">${escapeHtml(r.customer || "—")} · <span style="font-family:var(--mono)">${escapeHtml(prettyPlate(r.plate))}</span></div>
                  <div class="meta">Paikka: ${escapeHtml(prettyLocation(r.location))}</div>
                  <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                    <span class="pill" style="background:${meta.bg};border-color:${meta.border};color:${meta.color}">${escapeHtml(meta.label)}</span>
                    <span class="pill" style="background:${season.bg};border-color:${season.border};color:${season.color}">${escapeHtml(season.t)}</span>
                    ${pending ? `<span class="pill">Odottaa vahvistusta</span>` : ``}
                  </div>
                </div>
                <div class="actions">
                  <button class="btn ghost" data-row-open="${escapeHtml(r.id)}">Avaa</button>
                </div>
              </div>
            `;
          }).join("")) || `<div class="muted">Ei rivejä.</div>`;

          $$('[data-row-open]', list).forEach((btn) => {
            btn.addEventListener('click', () => {
              const id = btn.getAttribute('data-row-open');
              const row = tires.find((x) => String(x.id) === String(id));
              if (!row) return;
              openRowDetailsModal(row);
            });
          });
        };

        search.addEventListener("input", renderList);
        renderList();
      }
      function renderCalendarGrid() {
        const CALENDAR_DURATION_OPTIONS = [1, 2, 3, 4, 6];
        const CALENDAR_BAYS = [1, 2];

        const isPortrait = false; // force tablet landscape layout
        const ui = state.data.calendarUi || { viewMode: "all", singleDayIndex: 0 };
        if (!ui.viewMode) ui.viewMode = isPortrait ? "single" : "all";

        const settings = state.data.calendarSettings || {};
        const openMinutes = parseTimeToMinutes(settings.open_time) ?? 8 * 60;
        const closeMinutesRaw = parseTimeToMinutes(settings.close_time) ?? 17 * 60;
        const slotMinutes = Math.max(5, parseInt(settings.slot_minutes, 10) || 20);
        const closeMinutes = closeMinutesRaw > openMinutes ? closeMinutesRaw : openMinutes + slotMinutes;
        const slotStarts = [];
        for (let m = openMinutes; m + slotMinutes <= closeMinutes; m += slotMinutes) slotStarts.push(m);

        const selectedDayIso = String(state.data.calendarDate || todayStrLocal());
        const weekStart = getMondayIso(selectedDayIso);
        const weekEnd = addDaysIso(weekStart, 6);
        const weekNumber = getIsoWeekNumber(weekStart);

        const todayIso = todayStrLocal();
        const nowIso = isoDateLocal(new Date(appNowMs()));

        const weekDays = Array.from({ length: 7 }, (_, i) => addDaysIso(weekStart, i));
        const showSaturday = settings.showSaturday !== false;
        const showSunday = settings.showSunday !== false;
        const weekDaysForView = weekDays.filter((_, idx) => {
          if (idx === 5) return showSaturday;
          if (idx === 6) return showSunday;
          return true;
        });

        const selectedIndexInView = Math.max(0, weekDaysForView.indexOf(selectedDayIso));
        const safeSingle = clamp(parseInt(ui.singleDayIndex, 10) || selectedIndexInView, 0, Math.max(0, weekDaysForView.length - 1));
        const visibleDays = ui.viewMode === "single" ? [weekDaysForView[safeSingle]].filter(Boolean) : weekDaysForView;

        const fiDayLabel = (dayIso) => {
          const d = new Date(`${dayIso}T00:00:00`);
          const map = ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"];
          const w = map[d.getDay()] || "";
          return `${w} ${formatDateOnlyFinnish(dayIso, dayIso)}`;
        };

        const apptsRaw = Array.isArray(state.data.appointments) ? state.data.appointments : [];
        const apptsParsed = apptsRaw
          .map((a) => {
            const startMs = new Date(a.start_ts).getTime();
            const endMs = new Date(a.end_ts).getTime();
            return { ...a, startMs, endMs };
          })
          .filter((a) => Number.isFinite(a.startMs) && Number.isFinite(a.endMs) && a.endMs > a.startMs)
          .sort((a, b) => a.startMs - b.startMs);
        const laneEnds = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
        const appts = apptsParsed.map((a) => {
          const explicitBay = parseInt(a?.bay ?? a?.nosturi ?? a?.lane, 10);
          const hasExplicit = explicitBay === 1 || explicitBay === 2;
          let bay = hasExplicit ? explicitBay : 1;
          if (!hasExplicit) {
            if (a.startMs >= laneEnds[0]) bay = 1;
            else if (a.startMs >= laneEnds[1]) bay = 2;
            else bay = laneEnds[0] <= laneEnds[1] ? 1 : 2;
          }
          laneEnds[bay - 1] = Math.max(laneEnds[bay - 1], a.endMs);
          return { ...a, bay };
        });

        const blocksRaw = Array.isArray(state.data.blocks) ? state.data.blocks : [];
        const blocks = blocksRaw
          .map((b) => {
            const startMs = new Date(b.start_ts).getTime();
            const endMs = new Date(b.end_ts).getTime();
            return { ...b, startMs, endMs };
          })
          .filter((b) => Number.isFinite(b.startMs) && Number.isFinite(b.endMs) && b.endMs > b.startMs);

        const plateLocationMap = new Map();
        for (const r of state.data.tires || []) {
          const plate = normalizePlate(r?.plate);
          if (!plate || plateLocationMap.has(plate)) continue;
          const loc = String(r?.location || r?.last_location || "").trim();
          if (loc) plateLocationMap.set(plate, loc);
        }
        const appointmentLocationLabel = (a) => {
          const direct = String(a?.source_location || a?.location || a?.hyllypaikka || "").trim();
          const fallback = plateLocationMap.get(normalizePlate(a?.plate)) || "";
          return prettyLocation(direct || fallback);
        };
        const appointmentSlotLabel = (a) => {
          const plate = prettyPlate(a?.plate);
          const base = plate && plate !== "—" ? plate : "Varattu";
          const loc = appointmentLocationLabel(a);
          const notesRaw = String(a?.notes || "").replace(/[\r\n]+/g, " ").trim();
          const notes = notesRaw.length > 28 ? `${notesRaw.slice(0, 28)}...` : notesRaw;
          const top = [base, loc].filter(Boolean).join(" • ");
          return notes ? `${top}\n${notes}` : top;
        };

        const isClosedBlock = (b) => {
          const kind = String(b?.kind || b?.laji || "").trim().toLowerCase();
          const title = String(b?.title || "").trim().toLowerCase();
          return kind === "suljettu" || kind === "closed" || title.includes("suljettu");
        };
        const dayStartMsLocal = (dayIso) => new Date(`${dayIso}T00:00:00`).getTime();
        const msAtMinutes = (dayIso, mins) => dayStartMsLocal(dayIso) + mins * 60 * 1000;
        const fullDayClosedBlock = (dayIso) => {
          const start = dayStartMsLocal(dayIso);
          const end = dayStartMsLocal(addDaysIso(dayIso, 1));
          const slack = 5 * 60 * 1000;
          return blocks.find((b) => isClosedBlock(b) && b.startMs <= start + slack && b.endMs >= end - slack) || null;
        };
        const isDayClosed = (dayIso) => !!fullDayClosedBlock(dayIso);

        const metaByKey = new Map();
        function slotMeta(dayIso, startMin, bay) {
          const startMs = msAtMinutes(dayIso, startMin);
          const endMs = startMs + slotMinutes * 60 * 1000;
          const appointment = appts.find((a) => a.bay === bay && overlapsMs(startMs, endMs, a.startMs, a.endMs)) || null;
          const block = blocks.find((b) => overlapsMs(startMs, endMs, b.startMs, b.endMs)) || null;
          const closed = isDayClosed(dayIso);
          const isPastDay = dayIso < todayIso;
          const slotLocked = isPastDay || closed;
          const slotInPast = endMs <= appNowMs();
          const appointmentEnded = appointment && appointment.endMs <= appNowMs();
          const dim = slotLocked || slotInPast || appointmentEnded;
          return { dayIso, startMin, bay, startMs, endMs, appointment, block, closed, slotLocked, isFree: !appointment && !block && !closed, dim };
        }

        async function saveAppointment(draft) {
          const hotelCode = state.session.hotelCode;
          const durationSlots = Math.max(1, parseInt(draft.durationSlots, 10) || 1);
          const endMs = draft.startMs + durationSlots * slotMinutes * 60 * 1000;
          const payload = {
            start_ts: new Date(draft.startMs).toISOString(),
            end_ts: new Date(endMs).toISOString(),
            bay: draft.bay,
            customer_name: draft.customer_name || null,
            phone: draft.phone || null,
            plate: draft.plate || null,
            notes: draft.notes || null,
          };

          try {
            if (draft.id) await api.updateAppointment(hotelCode, draft.id, payload);
            else await api.createAppointment(hotelCode, payload);
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Varaus tallennettu.");
            return;
          } catch {
            // continue to PIN fallback
          }

          const pin = await requirePin({ title: "Vahvista", message: "Syötä PIN (oma/admin/master).", requireAdmin: false });
          if (!pin) return;
          if (draft.id) {
            let out;
            try {
              out = await api.updateAppointmentWithPin(hotelCode, pin, draft.id, payload);
            } catch (e) {
              toast("error", "Virhe", e?.message || "Päivitys epäonnistui.");
              return;
            }
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Päivitys epäonnistui.");
              return;
            }
          } else {
            let out;
            try {
              out = await api.createAppointmentWithPin(hotelCode, pin, payload);
            } catch (e) {
              toast("error", "Virhe", e?.message || "Tallennus epäonnistui.");
              return;
            }
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Tallennus epäonnistui.");
              return;
            }
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Varaus tallennettu.");
        }

        function openAppointmentEditor(meta) {
          const initial = meta.appointment
            ? {
                id: meta.appointment.id,
                startMs: meta.appointment.startMs,
                durationSlots: Math.max(1, Math.round((meta.appointment.endMs - meta.appointment.startMs) / (slotMinutes * 60 * 1000))),
                bay: meta.appointment.bay || 1,
                plate: String(meta.appointment.plate || ""),
                customer_name: String(meta.appointment.customer_name || ""),
                phone: String(meta.appointment.phone || ""),
                notes: String(meta.appointment.notes || ""),
              }
            : {
                id: null,
                startMs: meta.startMs,
                durationSlots: 1,
                bay: meta.bay || 1,
                plate: "",
                customer_name: "",
                phone: "",
                notes: "",
              };

          const startLocal = new Date(initial.startMs);
          const startVal = `${isoDateLocal(startLocal)}T${minutesToHHMM(startLocal.getHours() * 60 + startLocal.getMinutes())}`;

          const customerNames = (state.data.customers || []).map((c) => String(c?.nimi || c?.customer || "").trim()).filter(Boolean);
          const uniquePlates = Array.from(new Set((state.data.tires || []).map((r) => normalizePlate(r?.plate)).filter(Boolean))).slice(0, 200);

          const html = `
            <div class="msg">${initial.id ? "Muokkaa varausta" : "Uusi varaus"}</div>
            <div class="row">
              <div class="col" style="min-width:260px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Aika</div>
                  <input id="apStart" type="datetime-local" step="${slotMinutes * 60}" value="${escapeHtml(startVal)}" />
                </div>
              </div>
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Kesto</div>
                  <div style="display:flex; gap:6px; flex-wrap:wrap;">
                    ${CALENDAR_DURATION_OPTIONS.map((c) => `<button class="btn ghost" type="button" data-ap-dur="${c}" style="padding:8px 10px">${c} sl</button>`).join("")}
                  </div>
                  <div class="p" id="apTimeLabel" style="margin:6px 0 0 0"></div>
                </div>
              </div>
              <div class="col" style="min-width:200px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Nosturi</div>
                  <div style="display:flex; gap:6px;">
                    ${CALENDAR_BAYS.map((b) => `<button class="btn ghost" type="button" data-ap-bay="${b}" style="flex:1">${b}</button>`).join("")}
                  </div>
                </div>
              </div>
            </div>

            <datalist id="apCustomerList">
              ${customerNames.slice(0, 250).map((n) => `<option value="${escapeHtml(n)}"></option>`).join("")}
            </datalist>
            <datalist id="apPlateList">
              ${uniquePlates.map((p) => `<option value="${escapeHtml(p)}"></option>`).join("")}
            </datalist>

             <div class="field">
               <div class="label">Rekisteri</div>
               <input id="apPlate" list="apPlateList" value="${escapeHtml(initial.plate)}" placeholder="ABC-123" />
               <div class="p" id="apLocHint" style="margin:0"></div>
               <div id="apAutofillHint" style="margin-top:8px;"></div>
             </div>
            <div class="field">
              <div class="label">Asiakas</div>
              <input id="apCustomer" list="apCustomerList" value="${escapeHtml(initial.customer_name)}" placeholder="Asiakkaan nimi" />
            </div>
            <div class="field">
              <div class="label">Puhelin</div>
              <input id="apPhone" value="${escapeHtml(initial.phone)}" placeholder="Puhelinnumero" />
            </div>
            <div class="field">
              <div class="label">Huomiot</div>
              <textarea id="apNotes">${escapeHtml(initial.notes)}</textarea>
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="apCancel" type="button">Peruuta</button>
              <button class="btn primary" id="apSave" type="button">Tallenna</button>
            </div>
          `;
          openModal(initial.id ? "Muokkaa varausta" : "Uusi varaus", html);

          let draft = { ...initial };

          const updateTimeLabel = () => {
            const d = new Date(draft.startMs);
            const startMin = d.getHours() * 60 + d.getMinutes();
            const endMin = startMin + Math.max(1, draft.durationSlots) * slotMinutes;
            $("#apTimeLabel", modalBody).textContent = `${minutesToHHMM(startMin)}-${minutesToHHMM(endMin)}`;
          };
           const updateLocHint = () => {
             const norm = normalizePlate($("#apPlate", modalBody).value);
             if (!norm) { $("#apLocHint", modalBody).textContent = ""; return; }
             const loc = plateLocationMap.get(norm) || "";
             $("#apLocHint", modalBody).textContent = loc ? `Hyllypaikka: ${prettyLocation(loc)}` : "";
           };
           const autofill = $("#apAutofillHint", modalBody);
           let lastAutofillKey = "";
           function renderApAutofill(matchRow) {
             if (!autofill) return;
             if (!matchRow) { autofill.innerHTML = ""; return; }
             if (initial.id) { autofill.innerHTML = ""; return; } // don't prompt on edit
             const p = String(matchRow?.phone || "").trim();
             const name = String(matchRow?.customer || "").trim();
             const loc = prettyLocation(matchRow?.location) || "—";
             const fillable = (!!name && !String($("#apCustomer", modalBody).value || "").trim()) || (!!p && !String($("#apPhone", modalBody).value || "").trim());
             autofill.innerHTML = `
               <div class="card pad" style="box-shadow:none; background: var(--muted-bg); border-color: var(--muted-border); padding:10px;">
                 <div class="p" style="margin:0">Rekisteri löytyy riveistä: ${escapeHtml(name || "—")} · ${escapeHtml(p || "—")} · ${escapeHtml(loc)}</div>
                 <div class="btn-row" style="margin-top:8px; justify-content:flex-end;">
                   <button class="btn ghost" id="apAutoNo" type="button">Ei nyt</button>
                   <button class="btn primary" id="apAutoFill" type="button" ${fillable ? "" : "disabled"}>Täytä</button>
                 </div>
               </div>
             `;
             $("#apAutoNo", modalBody).addEventListener("click", () => { autofill.innerHTML = ""; });
             $("#apAutoFill", modalBody).addEventListener("click", () => {
               if (name && !String($("#apCustomer", modalBody).value || "").trim()) $("#apCustomer", modalBody).value = name;
               if (p && !String($("#apPhone", modalBody).value || "").trim()) $("#apPhone", modalBody).value = p;
               autofill.innerHTML = "";
             });
           }
           const setActiveButtons = () => {
            $$("[data-ap-dur]", modalBody).forEach((b) => {
              const v = parseInt(b.getAttribute("data-ap-dur"), 10);
              b.classList.toggle("primary", v === draft.durationSlots);
              b.classList.toggle("ghost", v !== draft.durationSlots);
            });
            $$("[data-ap-bay]", modalBody).forEach((b) => {
              const v = parseInt(b.getAttribute("data-ap-bay"), 10);
              b.classList.toggle("primary", v === draft.bay);
              b.classList.toggle("ghost", v !== draft.bay);
            });
          };
          setActiveButtons();
          updateTimeLabel();
          updateLocHint();

           $("#apStart", modalBody).addEventListener("change", (e) => {
             const dt = new Date(String(e.target.value || ""));
             if (!Number.isFinite(dt.getTime())) return;
             draft.startMs = dt.getTime();
             updateTimeLabel();
           });
           $("#apPlate", modalBody).addEventListener("input", () => {
             updateLocHint();
             const norm = normalizePlate($("#apPlate", modalBody).value);
             if (!norm) { lastAutofillKey = ""; renderApAutofill(null); return; }
             const match = (state.data.tires || []).find((r) => normalizePlate(r?.plate) === norm);
             if (!match) { lastAutofillKey = ""; renderApAutofill(null); return; }
             const key = `${String(match?.id || "")}|${norm}`;
             if (key === lastAutofillKey) return;
             lastAutofillKey = key;
             renderApAutofill(match);
           });
          $("#apCustomer", modalBody).addEventListener("change", () => {
            const key = String($("#apCustomer", modalBody).value || "").trim();
            if (!key) return;
            const match = (state.data.customers || []).find((c) => String(c?.nimi || c?.customer || "").trim() === key);
            const v = String(match?.puhelin || match?.phone || "").trim();
            if (match && v && !String($("#apPhone", modalBody).value || "").trim()) $("#apPhone", modalBody).value = v;
          });
          $$("[data-ap-dur]", modalBody).forEach((b) => {
            b.addEventListener("click", () => {
              draft.durationSlots = Math.max(1, parseInt(b.getAttribute("data-ap-dur"), 10) || 1);
              setActiveButtons();
              updateTimeLabel();
            });
          });
          $$("[data-ap-bay]", modalBody).forEach((b) => {
            b.addEventListener("click", () => {
              draft.bay = parseInt(b.getAttribute("data-ap-bay"), 10) || 1;
              setActiveButtons();
            });
          });

          $("#apCancel", modalBody).addEventListener("click", closeModal);
          $("#apSave", modalBody).addEventListener("click", async () => {
            draft = {
              ...draft,
              plate: String($("#apPlate", modalBody).value || "").trim(),
              customer_name: String($("#apCustomer", modalBody).value || "").trim(),
              phone: String($("#apPhone", modalBody).value || "").trim(),
              notes: String($("#apNotes", modalBody).value || "").trim(),
            };
            closeModal();
            await saveAppointment(draft);
          });
        }

        async function deleteAppointment(appointment) {
          if (!appointment?.id) return;
          try {
            await api.deleteAppointment(state.session.hotelCode, appointment.id);
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Varaus poistettu.");
            return;
          } catch {
            // continue
          }
          const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä PIN (oma/admin/master).", requireAdmin: false });
          if (!pin) return;
          let out;
          try {
            out = await api.deleteAppointmentWithPin(state.session.hotelCode, pin, appointment.id);
          } catch (e) {
            toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
            return;
          }
          if (out?.ok !== true) {
            const reason = String(out?.reason || "");
            if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", out?.message || reason || "Poisto epäonnistui.");
            return;
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Varaus poistettu.");
        }

        function openAppointmentQuickActions(appointment) {
          if (!appointment) return;
          modalConfirm("Varaus", appointmentSlotLabel(appointment), [
            { text: "Peruuta", kind: "ghost" },
            { text: "Muokkaa", kind: "primary", onPress: () => openAppointmentEditor({ appointment }) },
            { text: "Poista", kind: "danger", onPress: () => deleteAppointment(appointment) },
          ]);
        }

        async function saveBlock(draft) {
          const hotelCode = state.session.hotelCode;
          const payload = {
            start_ts: new Date(draft.startMs).toISOString(),
            end_ts: new Date(draft.endMs).toISOString(),
            kind: draft.kind || null,
            title: draft.title || null,
            notes: draft.notes || null,
          };

          try {
            if (draft.id) await api.updateBlock(hotelCode, draft.id, payload);
            else await api.createBlock(hotelCode, payload);
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Blokki tallennettu.");
            return;
          } catch {
            // continue to PIN fallback
          }

          const pin = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN.", requireAdmin: true });
          if (!pin) return;
          if (draft.id) {
            const out = await api.updateBlockWithPin(hotelCode, pin, draft.id, payload);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Päivitys epäonnistui.");
              return;
            }
          } else {
            const out = await api.createBlockWithPin(hotelCode, pin, payload);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Tallennus epäonnistui.");
              return;
            }
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Blokki tallennettu.");
        }

        async function deleteBlock(block) {
          if (!block?.id) return;
          try {
            await api.deleteBlock(state.session.hotelCode, block.id);
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Blokki poistettu.");
            return;
          } catch {
            // continue
          }
          const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä admin/master PIN.", requireAdmin: true });
          if (!pin) return;
          let out;
          try {
            out = await api.deleteBlockWithPin(state.session.hotelCode, pin, block.id);
          } catch (e) {
            toast("error", "Virhe", e?.message || "Poisto epäonnistui.");
            return;
          }
          if (out?.ok !== true) {
            const reason = String(out?.reason || "");
            if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", out?.message || reason || "Poisto epäonnistui.");
            return;
          }
          await loadCalendarWeek();
          toast("success", "Ilmoitus", "Blokki poistettu.");
        }

        function openBlockEditor(meta) {
          if (!isAdminRole(state.session.role)) return toast("error", "Virhe", "Ei oikeuksia.");
          const existing = meta?.block && meta.block.id ? meta.block : null;
          const initial = existing
            ? {
                id: existing.id,
                startMs: existing.startMs,
                endMs: existing.endMs,
                kind: String(existing.kind || existing.laji || ""),
                title: String(existing.title || ""),
                notes: String(existing.notes || ""),
              }
            : {
                id: null,
                startMs: meta.startMs,
                endMs: meta.endMs,
                kind: "",
                title: "",
                notes: "",
              };

          const toLocalVal = (ms) => {
            const d = new Date(ms);
            const mins = d.getHours() * 60 + d.getMinutes();
            return `${isoDateLocal(d)}T${minutesToHHMM(mins)}`;
          };

          const html = `
            <div class="msg">${initial.id ? "Muokkaa blokkia" : "Uusi blokki"}</div>
            <div class="row">
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Alkaa</div>
                  <input id="blStart" type="datetime-local" step="${slotMinutes * 60}" value="${escapeHtml(toLocalVal(initial.startMs))}" />
                </div>
              </div>
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Päättyy</div>
                  <input id="blEnd" type="datetime-local" step="${slotMinutes * 60}" value="${escapeHtml(toLocalVal(initial.endMs))}" />
                </div>
              </div>
              <div class="col" style="min-width:200px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Tyyppi</div>
                  <input id="blKind" value="${escapeHtml(initial.kind)}" placeholder="tauko / suljettu / ..." />
                </div>
              </div>
            </div>
            <div class="field">
              <div class="label">Otsikko</div>
              <input id="blTitle" value="${escapeHtml(initial.title)}" placeholder="Esim. Lounas" />
            </div>
            <div class="field">
              <div class="label">Muistiinpanot</div>
              <textarea id="blNotes">${escapeHtml(initial.notes)}</textarea>
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="blCancel" type="button">Peruuta</button>
              ${initial.id ? `<button class="btn danger" id="blDelete" type="button">Poista</button>` : ``}
              <button class="btn primary" id="blSave" type="button">Tallenna</button>
            </div>
          `;
          openModal(initial.id ? "Blokki" : "Uusi blokki", html);

          $("#blCancel", modalBody).addEventListener("click", closeModal);
          const del = $("#blDelete", modalBody);
          if (del) del.addEventListener("click", () => {
            modalConfirm("Poista blokki?", "Tämä poistaa blokin kalenterista.", [
              { text: "Peruuta", kind: "ghost" },
              { text: "Poista", kind: "danger", onPress: async () => deleteBlock(existing) },
            ]);
          });
          $("#blSave", modalBody).addEventListener("click", async () => {
            const s = new Date(String($("#blStart", modalBody).value || "")).getTime();
            const e = new Date(String($("#blEnd", modalBody).value || "")).getTime();
            if (!Number.isFinite(s) || !Number.isFinite(e) || e <= s) return toast("error", "Virhe", "Aika ei kelpaa.");
            const draft = {
              id: initial.id,
              startMs: s,
              endMs: e,
              kind: String($("#blKind", modalBody).value || "").trim(),
              title: String($("#blTitle", modalBody).value || "").trim(),
              notes: String($("#blNotes", modalBody).value || "").trim(),
            };
            closeModal();
            await saveBlock(draft);
          });
        }

        async function toggleDayClosed(dayIso) {
          if (!isAdminRole(state.session.role)) return;
          const day = String(dayIso || "").trim();
          if (!day) return;

          const existing = fullDayClosedBlock(day);
          if (existing) {
            await deleteBlock(existing);
            return;
          }

          const startMs = dayStartMsLocal(day);
          const endMs = dayStartMsLocal(addDaysIso(day, 1));
          await saveBlock({ id: null, startMs, endMs, kind: "suljettu", title: "Suljettu", notes: "" });
        }

        const headerHtml = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Kalenteri</h1>
                <p class="p">Viikko ${weekNumber} (${formatDateShort(weekStart)}-${formatDateShort(weekEnd)})</p>
              </div>
              <div style="display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end;">
                <span class="pill">Auki: ${escapeHtml(String(settings.open_time || "08:00"))}-${escapeHtml(String(settings.close_time || "17:00"))}</span>
                <span class="pill">Slotti: ${slotMinutes} min</span>
              </div>
            </div>
            <div class="row" style="margin-top: 10px;">
              <div class="col" style="min-width:260px">
                <div class="field" style="margin:0">
                  <div class="label">Päivä</div>
                  <input id="calPick" type="date" value="${escapeHtml(selectedDayIso)}" />
                </div>
              </div>
              <div class="col" style="min-width:260px">
                <div class="btn-row" style="margin-top:20px; justify-content:flex-end; flex-wrap:wrap;">
                  <button class="btn ghost" id="calPrevWeek" type="button">&lt; Edellinen</button>
                  <button class="btn ghost" id="calThisWeek" type="button">Tämä viikko</button>
                  <button class="btn ghost" id="calNextWeek" type="button">Seuraava &gt;</button>
                  <button class="btn ghost" id="calRefresh" type="button">Päivitä</button>
                </div>
              </div>
            </div>
            <div class="btn-row" style="margin-top:10px; flex-wrap:wrap;">
              <button class="btn ghost" id="calModeAll" type="button">${weekDaysForView.length} päivää</button>
              <button class="btn ghost" id="calModeSingle" type="button">1 päivä</button>
              ${ui.viewMode === "single" ? `
                <button class="btn ghost" id="calPrevDay" type="button">&lt; Päivä</button>
                <span class="pill">${escapeHtml(fiDayLabel(weekDaysForView[safeSingle] || selectedDayIso))}</span>
                <button class="btn ghost" id="calNextDay" type="button">Päivä &gt;</button>
              ` : ``}
              <span style="flex:1"></span>
              ${isAdminRole(state.session.role) ? `<button class="btn primary" id="calToggleDay" type="button">${isDayClosed(selectedDayIso) ? "Avaa päivä" : "Sulje päivä"}</button>` : ``}
            </div>
          </div>
        `;

        const timeWidth = visibleDays.length >= 6 ? "66px" : (visibleDays.length === 5 ? "74px" : "86px");
        const gridHtml = `
          <div class="card pad" style="margin-top: 12px;">
            <div class="muted" style="font-size:13px;">
              ${isAdminRole(state.session.role) ? "Klikkaa vapaata slotia varataksesi. Oikea klikkaus lisää/muokkaa blokkia." : "Klikkaa vapaata slotia varataksesi."}
            </div>
            <div class="divider"></div>
            <div class="cal-days" style="--days:${visibleDays.length}; --slot-time-w:${timeWidth};">
              ${visibleDays.map((dayIso) => {
                  const closed = isDayClosed(dayIso);
                  const isToday = dayIso === nowIso;
                  const isPast = dayIso < todayIso;
                  const dayBg = isPast ? "#eceff3" : (closed ? "#fff1f2" : (isToday ? "#eaf2ff" : "white"));
                  return `
                    <div class="card pad cal-day-card" style="box-shadow:none; border-color:#e2e8f0; background:${dayBg};">
                      <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;" data-cal-day="${escapeHtml(dayIso)}">
                        <div style="font-weight:900">${escapeHtml(fiDayLabel(dayIso))}</div>
                        <div style="display:flex; gap:6px; align-items:center;">
                          ${closed ? `<span class="pill" style="background:#fee2e2;border-color:#ef4444;color:#991b1b">Suljettu</span>` : ``}
                          ${isToday ? `<span class="pill" style="background:var(--primary);border-color:var(--primary);color:white">Tänään</span>` : ``}
                        </div>
                      </div>
                      <div style="margin-top:8px; border:1px solid #e2e8f0; border-radius:12px; overflow:hidden; background:white;">
                        ${slotStarts.map((startMin) => {
                          const timeLabel = `${minutesToHHMM(startMin)}-${minutesToHHMM(startMin + slotMinutes)}`;
                          const tiles = CALENDAR_BAYS.map((bay) => {
                            const m = slotMeta(dayIso, startMin, bay);
                            const key = `${dayIso}|${startMin}|${bay}`;
                            metaByKey.set(key, m);
                            const bg = m.appointment ? "#ffe6e6" : (m.block ? "#fff4d6" : "#ebfaf0");
                            const border = m.appointment ? "#ef9a9a" : (m.block ? "#f5c46f" : "#9dd8b1");
                            const label = m.closed
                              ? "Suljettu"
                              : (m.appointment ? appointmentSlotLabel(m.appointment) : (m.block ? (m.block.title || m.block.kind || "Blokki") : "Vapaa"));
                            return `
                              <div class="slot-tile ${m.dim ? "dim" : ""}" style="background:${m.dim ? "#e5e7eb" : bg}; border-left-color:${m.dim ? "#9ca3af" : border};" data-slot="${escapeHtml(key)}">${escapeHtml(label)}</div>
                            `;
                          }).join("");
                          return `
                            <div class="slot-row" style="border-bottom:1px solid ${isPast ? "#d6d9df" : "#f3f4f6"};">
                              <div class="slot-time">${escapeHtml(timeLabel)}</div>
                              <div class="slot-tiles">${tiles}</div>
                            </div>
                          `;
                        }).join("")}
                      </div>
                    </div>
                  `;
                }).join("")}
            </div>
          </div>
        `;

        root.innerHTML = headerHtml + gridHtml;

        $("#calPick", root).addEventListener("change", (e) => {
          state.data.calendarDate = String(e.target.value || todayStrLocal());
          loadCalendarWeek();
        });
        $("#calPrevWeek", root).addEventListener("click", () => { state.data.calendarDate = addDaysIso(weekStart, -7); loadCalendarWeek(); });
        $("#calNextWeek", root).addEventListener("click", () => { state.data.calendarDate = addDaysIso(weekStart, 7); loadCalendarWeek(); });
        $("#calThisWeek", root).addEventListener("click", () => { state.data.calendarDate = getMondayIso(todayStrLocal()); loadCalendarWeek(); });
        $("#calRefresh", root).addEventListener("click", () => loadCalendarWeek());

        $("#calModeAll", root).addEventListener("click", () => { state.data.calendarUi.viewMode = "all"; render(); });
        $("#calModeSingle", root).addEventListener("click", () => { state.data.calendarUi.viewMode = "single"; state.data.calendarUi.singleDayIndex = selectedIndexInView; render(); });
        const prevDay = $("#calPrevDay", root);
        if (prevDay) prevDay.addEventListener("click", () => { state.data.calendarUi.singleDayIndex = Math.max(0, safeSingle - 1); render(); });
        const nextDay = $("#calNextDay", root);
        if (nextDay) nextDay.addEventListener("click", () => { state.data.calendarUi.singleDayIndex = Math.min(Math.max(0, weekDaysForView.length - 1), safeSingle + 1); render(); });

        const toggleDay = $("#calToggleDay", root);
        if (toggleDay) toggleDay.addEventListener("click", async () => {
          await toggleDayClosed(selectedDayIso);
        });

        $$("[data-cal-day]", root).forEach((el) => {
          el.addEventListener("click", () => {
            const dayIso = el.getAttribute("data-cal-day");
            if (!dayIso) return;
            state.data.calendarDate = dayIso;
            if (ui.viewMode === "single") {
              const idx = weekDaysForView.indexOf(dayIso);
              if (idx >= 0) state.data.calendarUi.singleDayIndex = idx;
            } else if (isPortrait) {
              const idx = weekDaysForView.indexOf(dayIso);
              if (idx >= 0) {
                state.data.calendarUi.viewMode = "single";
                state.data.calendarUi.singleDayIndex = idx;
              }
            }
            render();
          });
        });

        $$("[data-slot]", root).forEach((el) => {
          el.addEventListener("click", () => {
            const key = el.getAttribute("data-slot");
            const meta = metaByKey.get(key);
            if (!meta) return;
            if (meta.appointment) return openAppointmentQuickActions(meta.appointment);
            if (meta.block) {
              if (!isAdminRole(state.session.role)) return toast("info", "Blokki", String(meta.block.title || meta.block.kind || "Blokki"));
              return openBlockEditor(meta);
            }
            if (meta.slotLocked) return;
            return openAppointmentEditor(meta);
          });
          el.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            const key = el.getAttribute("data-slot");
            const meta = metaByKey.get(key);
            if (!meta) return;
            if (meta.appointment) return openAppointmentQuickActions(meta.appointment);
            if (meta.block) {
              if (!isAdminRole(state.session.role)) return toast("info", "Blokki", String(meta.block.title || meta.block.kind || "Blokki"));
              return openBlockEditor(meta);
            }
            if (meta.slotLocked) return;
            if (!isAdminRole(state.session.role)) return;
            return openBlockEditor(meta);
          });
        });
      }

      function renderCalendar() {
        return renderCalendarGrid();
        const pad2 = (n) => String(n).padStart(2, "0");
        const isoDateFromLocalTs = (ts) => {
          const d = new Date(ts);
          const y = d.getFullYear();
          const m = pad2(d.getMonth() + 1);
          const day = pad2(d.getDate());
          return `${y}-${m}-${day}`;
        };
        const clockFromTs = (ts) => {
          const d = new Date(ts);
          return `${pad2(d.getHours())}:${pad2(d.getMinutes())}`;
        };
        const fiWeekdayShort = (iso) => {
          const d = new Date(`${iso}T00:00:00`);
          const map = ["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"];
          return map[d.getDay()] || "";
        };
        const weekStart = getMondayIso(state.data.calendarDate);
        const weekEnd = addDaysIso(weekStart, 6);
        const weekDays = Array.from({ length: 7 }, (_, i) => addDaysIso(weekStart, i));

        const blocks = Array.isArray(state.data.blocks) ? state.data.blocks : [];
        const apptsRaw = Array.isArray(state.data.appointments) ? state.data.appointments : [];
        const appts = apptsRaw
          .map((a) => {
            const startMs = new Date(a.start_ts).getTime();
            const endMs = new Date(a.end_ts).getTime();
            const dayIso = isoDateFromLocalTs(a.start_ts);
            const bay = parseInt(a?.bay ?? a?.nosturi ?? a?.lane, 10);
            return { ...a, startMs, endMs, dayIso, bay: bay === 2 ? 2 : 1 };
          })
          .filter((a) => Number.isFinite(a.startMs) && Number.isFinite(a.endMs) && a.endMs > a.startMs);

        const apptsByDay = new Map();
        for (const day of weekDays) apptsByDay.set(day, []);
        for (const a of appts) {
          if (!apptsByDay.has(a.dayIso)) continue;
          apptsByDay.get(a.dayIso).push(a);
        }
        for (const day of weekDays) {
          apptsByDay.get(day).sort((x, y) => x.startMs - y.startMs);
        }

        const dayBlocks = (dayIso) => {
          const startDay = new Date(`${dayIso}T00:00:00Z`).getTime();
          const endDay = new Date(`${addDaysIso(dayIso, 1)}T00:00:00Z`).getTime();
          return blocks.filter((b) => {
            const s = new Date(b.start_ts).getTime();
            const e = new Date(b.end_ts).getTime();
            return Number.isFinite(s) && Number.isFinite(e) && e > startDay && s < endDay;
          });
        };
        const isClosedBlock = (b) => {
          const kind = String(b?.kind || b?.laji || "").trim().toLowerCase();
          const title = String(b?.title || "").trim().toLowerCase();
          return kind === "suljettu" || kind === "closed" || kind === "c" || title.includes("suljettu");
        };

        const selectedDay = String(state.data.calendarDate || todayStrLocal());
        const selectedBlocks = dayBlocks(selectedDay);
        const selectedClosed = selectedBlocks.some((b) => isClosedBlock(b));
        const selectedAppts = apptsByDay.get(selectedDay) || [];

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Kalenteri</h1>
                <p class="p">Viikko: <span style="font-weight:900">${escapeHtml(weekStart)}</span> – <span style="font-weight:900">${escapeHtml(weekEnd)}</span></p>
              </div>
              <div style="display:flex; gap: 8px; flex-wrap: wrap; justify-content:flex-end;">
                <span class="pill">${selectedClosed ? "Suljettu" : "Auki"}</span>
                <span class="pill">Varaukset (päivä): ${selectedAppts.length}</span>
              </div>
            </div>

            <div class="row" style="margin-top: 10px;">
              <div class="col" style="min-width: 260px;">
                <div class="field" style="margin:0">
                  <div class="label">Viikon valinta</div>
                  <input id="calPick" type="date" value="${escapeHtml(selectedDay)}" />
                </div>
              </div>
              <div class="col" style="min-width: 260px;">
                <div class="btn-row" style="margin-top: 20px; justify-content:flex-end;">
                  <button class="btn ghost" id="calPrevWeek">← Viikko</button>
                  <button class="btn ghost" id="calToday">Tänään</button>
                  <button class="btn ghost" id="calNextWeek">Viikko →</button>
                  <button class="btn ghost" id="calRefresh">Päivitä</button>
                </div>
              </div>
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div style="display:flex; align-items:center; justify-content:space-between; gap: 10px;">
              <div style="font-weight:900">Viikkonäkymä</div>
              <span class="pill">${appts.length} varausta</span>
            </div>
            <div class="divider"></div>
            <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px;">
              ${weekDays.map((dayIso) => {
                const dayAppts = apptsByDay.get(dayIso) || [];
                const closed = dayBlocks(dayIso).some((b) => isClosedBlock(b));
                const isSelected = dayIso === selectedDay;
                return `
                  <div class="card pad" style="box-shadow:none; border-color:${isSelected ? "rgba(14, 122, 254, 0.55)" : "#e2e8f0"}; background:${isSelected ? "rgba(14, 122, 254, 0.04)" : "white"}; cursor:pointer;" data-cal-day="${escapeHtml(dayIso)}">
                    <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
                      <div style="font-weight:900">${escapeHtml(fiWeekdayShort(dayIso))} ${escapeHtml(dayIso)}</div>
                      <span class="pill">${dayAppts.length}</span>
                    </div>
                    <div style="margin-top:8px; display:flex; gap:6px; flex-wrap:wrap;">
                      ${closed ? `<span class="pill">Suljettu</span>` : ``}
                    </div>
                    <div style="margin-top:10px;" class="muted">
                      ${dayAppts.slice(0, 3).map((a) => {
                        const label = `${clockFromTs(a.start_ts)}-${clockFromTs(a.end_ts)} · ${String(a.customer_name || "").trim() || "—"}`;
                        return `<div style="font-size:13px; line-height:1.35; margin-top:4px;">${escapeHtml(label)}</div>`;
                      }).join("")}
                      ${dayAppts.length > 3 ? `<div style="font-size:13px; margin-top:6px;">+${dayAppts.length - 3} lisää</div>` : ``}
                      ${dayAppts.length === 0 ? `<div style="font-size:13px;">Ei varauksia</div>` : ``}
                    </div>
                  </div>
                `;
              }).join("")}
            </div>
          </div>

          <div class="card pad" style="margin-top: 12px;">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <div style="font-weight:900; font-size:16px;">${escapeHtml(selectedDay)} · ${escapeHtml(fiWeekdayShort(selectedDay))}</div>
                <div class="p" style="margin-top:4px">Varaukset ja päivän sulku/avaus.</div>
              </div>
              <div class="btn-row" style="margin-top: 0; justify-content:flex-end;">
                <button class="btn primary" id="calNewAppt" ${isAdminRole(state.session.role) ? "" : "disabled"}>Uusi varaus</button>
                <button class="btn primary" id="calClose" ${isAdminRole(state.session.role) ? "" : "disabled"}>Sulje päivä</button>
                <button class="btn danger" id="calOpen" ${isAdminRole(state.session.role) ? "" : "disabled"}>Avaa päivä</button>
              </div>
            </div>

            <div class="divider"></div>

            <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
              <div style="font-weight:900">Varaukset</div>
              <span class="pill">${selectedAppts.length}</span>
            </div>
            <div class="list" style="margin-top:10px;">
              ${selectedAppts.map((a) => {
                const who = String(a.customer_name || "").trim() || "—";
                const plate = String(a.plate || "").trim();
                const phone = String(a.phone || "").trim();
                const notes = String(a.notes || "").trim();
                const time = `${clockFromTs(a.start_ts)}-${clockFromTs(a.end_ts)}`;
                const bay = a.bay === 2 ? "Nosturi 2" : "Nosturi 1";
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(time)} · ${escapeHtml(bay)} · ${escapeHtml(who)}</div>
                      <div class="meta">${plate ? "Rek: " + escapeHtml(plate) : ""}${plate && phone ? " · " : ""}${phone ? "Puh: " + escapeHtml(phone) : ""}${notes ? "<br/>" + escapeHtml(notes) : ""}</div>
                    </div>
                    <div class="actions">
                      ${isAdminRole(state.session.role) ? `<button class="btn danger" data-appt-del="${escapeHtml(String(a.id || ""))}">Poista</button>` : ``}
                    </div>
                  </div>
                `;
              }).join("")}
              ${selectedAppts.length === 0 ? `<div class="muted">Ei varauksia tälle päivälle.</div>` : ``}
            </div>

            <div class="divider"></div>

            <div style="display:flex; align-items:center; justify-content:space-between; gap: 8px;">
              <div style="font-weight:900">Sulut (valittu päivä)</div>
              <span class="pill">${selectedBlocks.length}</span>
            </div>
            <div class="list">
              ${selectedBlocks.map((b) => {
                const s = new Date(b.start_ts);
                const e = new Date(b.end_ts);
                const label = `${s.toLocaleString()} → ${e.toLocaleString()}`;
                return `
                  <div class="item">
                    <div class="main">
                      <div class="title">${escapeHtml(String(b.title || b.kind || "Sulku"))}</div>
                      <div class="meta">${escapeHtml(label)}</div>
                    </div>
                    <div class="actions">
                      <button class="btn danger" data-del-block="${escapeHtml(b.id)}" ${isAdminRole(state.session.role) ? "" : "disabled"}>Poista sulku</button>
                    </div>
                  </div>
                `;
              }).join("")}
              ${selectedBlocks.length === 0 ? `<div class="muted">Ei sulkuja.</div>` : ``}
            </div>
          </div>
        `;

        $("#calPick", root).addEventListener("change", (e) => {
          state.data.calendarDate = String(e.target.value || todayStrLocal());
          loadCalendarWeek();
        });
        $("#calPrevWeek", root).addEventListener("click", () => {
          state.data.calendarDate = addDaysIso(weekStart, -7);
          loadCalendarWeek();
        });
        $("#calNextWeek", root).addEventListener("click", () => {
          state.data.calendarDate = addDaysIso(weekStart, 7);
          loadCalendarWeek();
        });
        $("#calToday", root).addEventListener("click", () => {
          state.data.calendarDate = todayStrLocal();
          loadCalendarWeek();
        });
        $("#calRefresh", root).addEventListener("click", () => loadCalendarWeek());

        $$("[data-cal-day]", root).forEach((el) => {
          el.addEventListener("click", () => {
            const dayIso = el.getAttribute("data-cal-day");
            if (!dayIso) return;
            state.data.calendarDate = dayIso;
            render(); // same week already loaded
          });
        });

        $("#calClose", root).addEventListener("click", () => calendarCloseDay());
        $("#calOpen", root).addEventListener("click", () => calendarOpenDay());

        $("#calNewAppt", root).addEventListener("click", () => {
          if (!isAdminRole(state.session.role)) return;
          const defaultStart = `${selectedDay}T08:00`;
          const defaultEnd = `${selectedDay}T08:20`;
          const customerNames = (state.data.customers || []).map((c) => String(c?.nimi || c?.customer || "").trim()).filter(Boolean);
          const uniquePlates = Array.from(new Set((state.data.tires || []).map((r) => normalizePlate(r?.plate)).filter(Boolean))).slice(0, 200);

          const html = `
            <div class="msg">Uusi varaus (admin/master PIN).</div>
            <div class="row">
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Alkaa</div>
                  <input id="apStart" type="datetime-local" step="1200" value="${escapeHtml(defaultStart)}" />
                </div>
              </div>
              <div class="col" style="min-width:240px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Päättyy</div>
                  <input id="apEnd" type="datetime-local" step="1200" value="${escapeHtml(defaultEnd)}" />
                </div>
              </div>
              <div class="col" style="min-width:180px">
                <div class="field" style="margin-top:10px">
                  <div class="label">Nosturi</div>
                  <select id="apBay">
                    <option value="1">1</option>
                    <option value="2">2</option>
                  </select>
                </div>
              </div>
            </div>

            <datalist id="apCustomerList">
              ${customerNames.slice(0, 250).map((n) => `<option value="${escapeHtml(n)}"></option>`).join("")}
            </datalist>
            <datalist id="apPlateList">
              ${uniquePlates.map((p) => `<option value="${escapeHtml(p)}"></option>`).join("")}
            </datalist>

            <div class="field">
              <div class="label">Asiakas</div>
              <input id="apCustomer" list="apCustomerList" placeholder="Asiakkaan nimi" />
            </div>
            <div class="field">
              <div class="label">Puhelin</div>
              <input id="apPhone" placeholder="Puhelinnumero" />
            </div>
            <div class="field">
              <div class="label">Rekisteri</div>
              <input id="apPlate" list="apPlateList" placeholder="ABC-123" />
              <div class="p" id="apPlateHint" style="margin:0"></div>
            </div>
            <div class="field">
              <div class="label">Huomiot</div>
              <textarea id="apNotes"></textarea>
            </div>
            <div class="btn-row" style="justify-content:flex-end;">
              <button class="btn ghost" id="apCancel" type="button">Peruuta</button>
              <button class="btn primary" id="apSave" type="button">Tallenna</button>
            </div>
          `;
          openModal("Uusi varaus", html);

          const cEl = $("#apCustomer", modalBody);
          const pEl = $("#apPhone", modalBody);
          const plateEl = $("#apPlate", modalBody);
          const hint = $("#apPlateHint", modalBody);

          cEl.addEventListener("change", () => {
            const key = String(cEl.value || "").trim();
            if (!key) return;
            const match = (state.data.customers || []).find((c) => String(c?.nimi || c?.customer || "").trim() === key);
            if (match && !String(pEl.value || "").trim()) {
              const v = String(match?.puhelin || match?.phone || "").trim();
              if (v) pEl.value = v;
            }
          });
          plateEl.addEventListener("input", () => {
            const norm = normalizePlate(plateEl.value);
            if (!norm) { hint.textContent = ""; return; }
            const row = (state.data.tires || []).find((r) => normalizePlate(r?.plate) === norm);
            if (row) {
              hint.textContent = `Hyllypaikka: ${String(row.location || row.last_location || "—")}`;
              if (!String(cEl.value || "").trim() && String(row.customer || "").trim()) {
                cEl.value = String(row.customer || "").trim();
              }
              if (!String(pEl.value || "").trim() && String(row.phone || "").trim()) {
                pEl.value = String(row.phone || "").trim();
              }
            } else {
              hint.textContent = "";
            }
          });

          $("#apCancel", modalBody).addEventListener("click", closeModal);
          $("#apSave", modalBody).addEventListener("click", async () => {
            const startVal = String($("#apStart", modalBody).value || "").trim();
            const endVal = String($("#apEnd", modalBody).value || "").trim();
            const bay = parseInt($("#apBay", modalBody).value, 10) || 1;
            const customer_name = String($("#apCustomer", modalBody).value || "").trim() || null;
            const phone = String($("#apPhone", modalBody).value || "").trim() || null;
            const plate = String($("#apPlate", modalBody).value || "").trim() || null;
            const notes = String($("#apNotes", modalBody).value || "").trim() || null;
            if (!startVal || !endVal) return toast("error", "Virhe", "Täytä alku ja loppu.");
            const startIso = new Date(startVal).toISOString();
            const endIso = new Date(endVal).toISOString();
            if (new Date(endIso).getTime() <= new Date(startIso).getTime()) return toast("error", "Virhe", "Aika ei kelpaa.");

            closeModal();
            const pin = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN varaukseen.", requireAdmin: true });
            if (!pin) return;
            try {
              const out = await api.createAppointmentWithPin(state.session.hotelCode, pin, { start_ts: startIso, end_ts: endIso, bay, customer_name, phone, plate, notes });
              if (out?.ok !== true) {
                const reason = String(out?.reason || "");
                if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
                else toast("error", "Virhe", out?.message || reason || "Varauksen luonti epäonnistui.");
                return;
              }
              await loadCalendarWeek();
              toast("success", "Ilmoitus", "Varaus tallennettu.");
            } catch (e) {
              toast("error", "Virhe", e?.message || "Varauksen luonti epäonnistui.");
            }
          });
        });

        $$("[data-appt-del]", root).forEach((btn) => {
          btn.addEventListener("click", () => {
            const id = btn.getAttribute("data-appt-del");
            if (!id) return;
            modalConfirm("Poista varaus?", "Poistetaanko varaus?", [
              { text: "Peruuta", kind: "ghost" },
              {
                text: "Poista",
                kind: "danger",
                onPress: async () => {
                  const pin = await requirePin({ title: "Vahvista poisto", message: "Syötä admin/master PIN.", requireAdmin: true });
                  if (!pin) return;
                  const out = await api.deleteAppointmentWithPin(state.session.hotelCode, pin, id);
                  if (out?.ok !== true) {
                    const reason = String(out?.reason || "");
                    if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
                    else toast("error", "Virhe", out?.message || reason || "Poisto epäonnistui.");
                    return;
                  }
                  await loadCalendarWeek();
                  toast("success", "Ilmoitus", "Varaus poistettu.");
                },
              },
            ]);
          });
        });

        $$('[data-del-block]', root).forEach((btn) => {
          btn.addEventListener('click', async () => {
            const id = btn.getAttribute('data-del-block');
            const pin = await requirePin({ title: "Poista sulku", message: "Syötä admin/master PIN.", requireAdmin: true });
            if (!pin) return;
            const out = await api.deleteBlockWithPin(state.session.hotelCode, pin, id);
            if (out?.ok === false && out?.reason === "wrong_pin") return toast("error", "Virhe", "Väärä PIN.");
            await loadCalendarWeek();
            toast("success", "Ilmoitus", "Sulku poistettu.");
          });
        });
      }

      function openAddLocationModal() {
        const html = `
          <div class="msg">Lisää hyllypaikka.</div>
          <div class="row">
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Hylly (numero)</div>
                <input id="locShelf" type="number" min="1" max="99" value="1" />
              </div>
            </div>
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Rivi (kirjain)</div>
                <input id="locRow" maxlength="1" value="A" />
              </div>
            </div>
            <div class="col">
              <div class="field" style="margin-top:10px">
                <div class="label">Paikka (numero)</div>
                <input id="locSpot" type="number" min="1" max="99" value="1" />
              </div>
            </div>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="locCancel">Peruuta</button>
            <button class="btn primary" id="locSave">Tallenna</button>
          </div>
        `;
        openModal("Lisää hyllypaikka", html);
        $("#locCancel", modalBody).addEventListener("click", closeModal);
        $("#locSave", modalBody).addEventListener("click", async () => {
          const shelf = parseInt($("#locShelf", modalBody).value, 10) || 1;
          const rowLetter = String($("#locRow", modalBody).value || "A").trim().toUpperCase().slice(0, 1) || "A";
          const spot = parseInt($("#locSpot", modalBody).value, 10) || 1;
          closeModal();
          try {
            await api.addLocation(state.session.hotelCode, shelf, rowLetter, spot);
            await loadLocations();
            toast("success", "Ilmoitus", "Lisätty.");
          } catch (e) {
            toast("error", "Virhe", e?.message || "Lisäys epäonnistui");
          }
        });
        setTimeout(() => $("#locShelf", modalBody).focus(), 0);
      }

      function openUpsertUserModal(existing = null) {
        const html = `
          <div class="msg">Luo / päivitä käyttäjä. (Jos backendissä ei ole upsert_hotel_user_pin_with_pin, käytetään master-PIN:ä.)</div>
          <div class="field" style="margin-top:10px">
            <div class="label">Käyttäjänimi <span class="req">*</span></div>
            <input id="uName" value="${escapeHtml(String(existing?.username || ""))}" ${existing?.is_master ? "disabled" : ""}/>
          </div>
          <div class="field">
            <div class="label">Uusi PIN <span class="req">*</span></div>
            <input id="uPin" type="password" />
          </div>
          <div class="field">
            <div class="label">Rooli</div>
            <select id="uRole">
              <option value="staff">staff</option>
              <option value="admin">admin</option>
            </select>
          </div>
          <div class="field">
            <div class="label">Aktiivinen</div>
            <select id="uActive">
              <option value="true">kyllä</option>
              <option value="false">ei</option>
            </select>
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="uCancel">Peruuta</button>
            <button class="btn primary" id="uSave">Tallenna</button>
          </div>
        `;
        openModal("Luo / päivitä käyttäjä", html);
        $("#uRole", modalBody).value = existing?.role === "admin" ? "admin" : "staff";
        $("#uActive", modalBody).value = existing?.is_active === false ? "false" : "true";
        $("#uCancel", modalBody).addEventListener("click", closeModal);
        $("#uSave", modalBody).addEventListener("click", async () => {
          const username = String($("#uName", modalBody).value || "").trim();
          const newPin = String($("#uPin", modalBody).value || "").trim();
          const role = $("#uRole", modalBody).value === "admin" ? "admin" : "staff";
          const isActive = $("#uActive", modalBody).value === "true";
          if (!username || !newPin) return toast("error", "Virhe", "Täytä käyttäjänimi ja uusi PIN.");
          closeModal();

          const pinForAction = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN.", requireAdmin: true });
          if (!pinForAction) return;

          let out = await api.upsertHotelUserPinWithPin(state.session.hotelCode, pinForAction, username, newPin, role, isActive);
          if (out?.ok !== true && out?.reason === "missing_function") {
            const masterPin = await requirePin({ title: "Master PIN", message: "Syötä master-PIN käyttäjän luontiin/päivitykseen.", forcePrompt: true, prefill: state.session.pinSource === "master" ? (state.session.pin || "") : "", requireAdmin: true });
            if (!masterPin) return;
            out = await api.upsertHotelUserPinWithMasterPin(state.session.hotelCode, masterPin, username, newPin, role, isActive);
          }

          if (out?.ok !== true) {
            const reason = String(out?.reason || "");
            if (reason === "wrong_master_pin" || reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
            else toast("error", "Virhe", out?.message || reason || "Tallennus epäonnistui.");
            return;
          }

          await loadUsers();
          toast("success", "Ilmoitus", "Tallennettu.");
        });
        setTimeout(() => $("#uName", modalBody).focus(), 0);
      }

      function openOwnPinModal() {
        const html = `
          <div class="msg">Vaihda oma PIN. Tämä ei tallenna PINiä laitteelle.</div>
          <div class="field" style="margin-top:10px">
            <div class="label">Käyttäjänimi</div>
            <input id="opUser" value="${escapeHtml(String(state.session.username || ""))}" />
          </div>
          <div class="field">
            <div class="label">Vanha PIN</div>
            <input id="opOld" type="password" />
          </div>
          <div class="field">
            <div class="label">Uusi PIN</div>
            <input id="opNew" type="password" />
          </div>
          <div class="btn-row" style="justify-content:flex-end;">
            <button class="btn ghost" id="opCancel">Peruuta</button>
            <button class="btn primary" id="opSave">Tallenna</button>
          </div>
        `;
        openModal("Vaihda oma PIN", html);
        $("#opCancel", modalBody).addEventListener("click", closeModal);
        $("#opSave", modalBody).addEventListener("click", async () => {
          const username = String($("#opUser", modalBody).value || "").trim();
          const oldPin = String($("#opOld", modalBody).value || "").trim();
          const newPin = String($("#opNew", modalBody).value || "").trim();
          closeModal();
          if (!username || !oldPin || !newPin) return toast("error", "Virhe", "Täytä kaikki kentät.");
          try {
            const out = await api.changeOwnPin(state.session.hotelCode, username, oldPin, newPin);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "PINin vaihto epäonnistui.");
              return;
            }
            state.session.pin = newPin;
            toast("success", "Ilmoitus", "PIN vaihdettu.");
          } catch (e) {
            toast("error", "Virhe", e?.message || "PINin vaihto epäonnistui.");
          }
        });
      }
      function renderSettings() {
        const isAdmin = isAdminRole(state.session.role);

        root.innerHTML = `
          <div class="card pad">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px;">
              <div>
                <h1 class="h1">Asetukset</h1>
                <p class="p">Turva-asetuksista vain automaattinen kirjaus ulos. Ei laitetallennusta.</p>
              </div>
              <button class="btn danger" id="logoutBtn">Kirjaudu ulos</button>
            </div>
          </div>

          <div class="row" style="margin-top: 12px;">
            <div class="col">
              <div class="card pad">
                <div style="font-weight:900">Turva</div>
                <div class="field">
                  <div class="label">Automaattinen kirjaus ulos (min)</div>
                  <input id="autoLogout" type="number" min="0" max="240" value="${escapeHtml(String(state.security.autoLogoutMinutes))}" />
                  <div class="p" style="margin:0">0 = pois päältä</div>
                </div>
              </div>
            </div>
            <div class="col">
              <div class="card pad">
                <div style="font-weight:900">Oma PIN</div>
                <p class="p">Vaihda oma PIN, jos backendissä on <span style="font-family:var(--mono)">change_hotel_user_pin_with_old_pin</span>.</p>
                <div class="btn-row">
                  <button class="btn ghost" id="ownPinBtn">Vaihda oma PIN</button>
                </div>
              </div>
            </div>
          </div>

          ${isAdmin ? `
            <div class="row" style="margin-top: 12px;">
              <div class="col">
                <div class="card pad">
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <div style="font-weight:900">Käyttäjät</div>
                    <button class="btn primary" id="userAddBtn">Luo / päivitä</button>
                  </div>
                  <div class="divider"></div>
                  <div class="list" id="userList"></div>
                </div>
              </div>
              <div class="col">
                <div class="card pad">
                  <div style="display:flex; align-items:center; justify-content:space-between;">
                    <div style="font-weight:900">Hyllypaikkojen hallinta</div>
                    <button class="btn primary" id="locAddBtn">Lisää</button>
                  </div>
                  <div class="divider"></div>
                  <div class="list" id="locList"></div>
                </div>
              </div>
            </div>
          ` : ``}
        `;

        $("#logoutBtn", root).addEventListener("click", () => logout("Kirjautuminen päättyi."));
        $("#autoLogout", root).addEventListener("input", (e) => {
          state.security.autoLogoutMinutes = clamp(parseInt(e.target.value, 10) || 0, 0, 240);
        });
        $("#ownPinBtn", root).addEventListener("click", () => openOwnPinModal());

        if (!isAdmin) return;

        // Users
        const users = state.data.users || [];
        const userList = $("#userList", root);
        userList.innerHTML = (users.map((u) => {
          const isMaster = u?.is_master === true || String(u?.id) === "master";
          const username = String(u?.username || "").trim() || (isMaster ? (state.session.masterName || "Master") : "—");
          const role = isMaster ? "master" : String(u?.role || "staff");
          const active = !!u?.is_active;
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(username)} · <span class="pill mono">${escapeHtml(role)}</span></div>
                <div class="meta">${isMaster ? "Hotellin oletus-PIN (master/admin)" : ""}</div>
              </div>
              <div class="actions">
                <button class="btn ghost" data-user-reset="${escapeHtml(username)}" ${isMaster ? "disabled" : ""}>Nollaa PIN</button>
                <button class="btn ${active ? "ghost" : "danger"}" data-user-toggle="${escapeHtml(username)}" ${isMaster ? "disabled" : ""}>${active ? "Aktiivinen" : "Pois käytöstä"}</button>
              </div>
            </div>
          `;
        }).join("")) || `<div class="muted">Ei käyttäjiä.</div>`;

        $("#userAddBtn", root).addEventListener("click", () => openUpsertUserModal());

        $$('[data-user-reset]', userList).forEach((btn) => {
          btn.addEventListener('click', () => {
            const username = btn.getAttribute('data-user-reset');
            if (!username) return;
            openUpsertUserModal({ username, role: "staff", is_active: true });
          });
        });
        $$('[data-user-toggle]', userList).forEach((btn) => {
          btn.addEventListener('click', async () => {
            const username = btn.getAttribute('data-user-toggle');
            const user = users.find((u) => String(u?.username || "") === String(username));
            if (!user) return;
            const next = !user.is_active;
            const pin = await requirePin({ title: "Vahvista", message: "Syötä admin/master PIN.", requireAdmin: true });
            if (!pin) return;
            const out = await api.setHotelUserActiveWithPin(state.session.hotelCode, pin, username, next);
            if (out?.ok !== true) {
              const reason = String(out?.reason || "");
              if (reason === "wrong_pin") toast("error", "Virhe", "Väärä PIN.");
              else toast("error", "Virhe", out?.message || reason || "Päivitys epäonnistui.");
              return;
            }
            await loadUsers();
            toast("success", "Ilmoitus", "Päivitetty.");
          });
        });

        // Locations
        const locs = state.data.locations || [];
        const locList = $("#locList", root);
        locList.innerHTML = (locs.map((l) => {
          const label = l.label || l.code || "—";
          return `
            <div class="item">
              <div class="main">
                <div class="title">${escapeHtml(label)}</div>
                <div class="meta">${escapeHtml(String(l.code || ""))}</div>
              </div>
              <div class="actions">
                <button class="btn danger" data-loc-del="${escapeHtml(String(l.id))}">Poista</button>
              </div>
            </div>
          `;
        }).join("")) || `<div class="muted">Ei hyllypaikkoja.</div>`;

        $("#locAddBtn", root).addEventListener("click", () => openAddLocationModal());

        $$('[data-loc-del]', locList).forEach((btn) => {
          btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-loc-del');
            modalConfirm("Poista hyllypaikka", "Poistetaanko hyllypaikka?", [
              { text: "Peruuta", kind: "ghost" },
              {
                text: "Poista",
                kind: "danger",
                onPress: async () => {
                  try {
                    await api.deleteLocation(id);
                    await loadLocations();
                    toast("success", "Ilmoitus", "Poistettu.");
                  } catch (e) {
                    toast("error", "Virhe", e?.message || "Poisto epäonnistui");
                  }
                },
              },
            ]);
          });
        });
      }

      function render() {
        if (!state.session.ok) {
          renderLogin();
          return;
        }
        renderTopbar();

        if (state.tab === "dashboard") return renderDashboard();
        if (state.tab === "worklist") return renderWorklist();
        if (state.tab === "customers") return renderCustomers();
        if (state.tab === "rows") return renderRows();
        if (state.tab === "calendar") return renderCalendar();
        if (state.tab === "settings") return renderSettings();
        return renderDashboard();
      }

      render();
    </script>
  </body>
</html>
